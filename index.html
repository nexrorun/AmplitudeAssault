<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amplitude Assault - Audio Visualizer Bullet Hell</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        @keyframes glow {
            0% { box-shadow: 0 0 5px #ff0055, 0 0 10px #ff0055; }
            50% { box-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055; }
            100% { box-shadow: 0 0 5px #ff0055, 0 0 10px #ff0055; }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        .float {
            animation: float 3s ease-in-out infinite;
        }
        
        .glow {
            animation: glow 1.5s ease-in-out infinite;
        }
        
        .neon-text {
            text-shadow: 0 0 8px #ff0055, 0 0 16px #ff0055, 0 0 24px #ff0055, 0 0 32px #ff0055;
        }

        /* Title bop animation to gently float/bob to the menu music */
        @keyframes titleBop {
            0%   { transform: translateY(0) scale(1); }
            25%  { transform: translateY(-6px) scale(1.02); }
            50%  { transform: translateY(0) scale(1); }
            75%  { transform: translateY(4px) scale(0.995); }
            100% { transform: translateY(0) scale(1); }
        }
        .title-bop {
            animation: titleBop 3.2s ease-in-out infinite;
            transform-origin: center;
        }
        
        .neon-border {
            box-shadow: 0 0 8px #00ffff, 0 0 16px #00ffff, 0 0 24px #00ffff;
        }
        
        .glow-button {
            transition: all 0.3s ease;
            box-shadow: 0 0 5px currentColor, 0 0 10px currentColor;
        }
        
        .glow-button:hover {
            box-shadow: 0 0 20px currentColor, 0 0 40px currentColor, 0 0 60px currentColor;
            transform: translateY(-2px);
        }
        
        .health-bar {
            transition: width 0.3s ease, background-color 0.3s ease;
            box-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }
        
        .background-grid {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 50%, #16213e 100%);
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .band-display {
            transition: height 0.2s ease;
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.7;
        }
        
        .gradient-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0.6;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinner {
            animation: spin 1s linear infinite;
            filter: drop-shadow(0 0 10px #22d3ee) drop-shadow(0 0 20px #22d3ee);
        }

        .start-ready {
            opacity: 1 !important;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff;
        }

        @keyframes progressGlow {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        @keyframes progressHeadPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 6px #22f2ff, 0 0 12px #22f2ff, 0 0 18px #22f2ff;
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 12px #22f2ff, 0 0 24px #22f2ff, 0 0 36px #22f2ff;
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 6px #22f2ff, 0 0 12px #22f2ff, 0 0 18px #22f2ff;
            }
        }

        @keyframes comboPopIn {
            0% {
                transform: scale(0) rotate(-5deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(2deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes comboShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .combo-display {
            animation: comboPopIn 0.3s ease-out;
            text-shadow: 0 0 8px currentColor, 0 0 16px currentColor;
        }

        .combo-shake {
            animation: comboShake 0.2s ease-out;
        }

        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes healthGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Desktop-only enhanced visuals */
        @media (min-width: 769px) {
            #gameCanvas {
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), 0 0 80px rgba(255, 0, 255, 0.2), inset 0 0 60px rgba(0, 0, 0, 0.5);
                border: 2px solid rgba(0, 255, 255, 0.4);
            }

            .neon-text {
                animation: neonFlicker 3s infinite;
            }

            @keyframes neonFlicker {
                0%, 100% { text-shadow: 0 0 8px #ff0055, 0 0 16px #ff0055, 0 0 24px #ff0055, 0 0 32px #ff0055; }
                50% { text-shadow: 0 0 12px #ff0055, 0 0 24px #ff0055, 0 0 36px #ff0055, 0 0 48px #ff0055; }
            }

            #hud {
                backdrop-filter: blur(8px);
                background: rgba(0, 0, 0, 0.3);
                padding: 1rem;
                border-radius: 8px;
                border: 1px solid rgba(0, 255, 255, 0.2);
            }
        }

        /* Custom Checkbox */
        .custom-checkbox {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .custom-checkbox input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .checkbox-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1a1a2e;
            border: 2px solid #00ffff;
            transition: 0.3s;
            border-radius: 26px;
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }

        .checkbox-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: #00ffff;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 0 8px #00ffff, 0 0 16px #00ffff;
        }

        input:checked + .checkbox-slider {
            background-color: #00ffff;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }

        input:checked + .checkbox-slider:before {
            transform: translateX(24px);
            background-color: #1a1a2e;
            box-shadow: 0 0 8px #1a1a2e;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            text-shadow: 0 0 8px currentColor, 0 0 16px currentColor;
            box-shadow: 0 0 8px currentColor, 0 0 16px currentColor;
        }

        .difficulty-EASY { color: #00ff41; border: 2px solid #00ff41; }
        .difficulty-MEDIUM { color: #ffaa00; border: 2px solid #ffaa00; }
        .difficulty-HARD { color: #ff0055; border: 2px solid #ff0055; }
        .difficulty-CHALLENGER { color: #ff00ff; border: 2px solid #ff00ff; }
        .difficulty-INSANE { color: #ff0000; border: 2px solid #ff0000; }
        .difficulty-EXPERT { color: #aa00ff; border: 2px solid #aa00ff; }
        .difficulty-EXPERT-PLUS { color: #ff00aa; border: 2px solid #ff00aa; }
        .difficulty-EXPERT-PLUS-PLUS { color: #ffffff; border: 2px solid #ffffff; }
        .difficulty-TUTORIAL { color: #00ffff; border: 2px solid #00ffff; }

        /* Mobile-friendly layout */
        @media (max-width: 768px) {
            /* Allow the page to scroll on mobile so long menus and modals can be reached */
            body {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Force ui-layer into block layout on mobile so hidden demo-container cannot reserve space */
            #ui-layer {
                display: block !important;
                overflow-y: auto; /* enable scrolling if UI content exceeds viewport */
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }

            /* But still allow the Tailwind "hidden" class to fully hide the UI on mobile (for gameplay) */
            #ui-layer.hidden {
                display: none !important;
            }

            /* Make the sidebar full-width and scrollable to avoid cutoffs,
               increase padding and slightly larger touch targets for buttons. */
            #menu-sidebar {
                width: 100%;
                max-width: 100%;
                /* Let the sidebar grow taller than the viewport so the page scrolls naturally,
                   but also allow internal scrolling when needed. */
                max-height: none;
                padding: 1.5rem;
                background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(15,15,30,0.98));
                position: relative;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                backdrop-filter: blur(12px);
                overscroll-behavior: contain;
            }

            #menu-sidebar h1 {
                font-size: 1.9rem;
                line-height: 1.15;
                margin-bottom: 0.6rem;
            }

            /* Increase touch target size and font for buttons so they don't get cut off */
            #menu-sidebar button {
                width: 100%;
                padding-top: 0.9rem;
                padding-bottom: 0.9rem;
                font-size: 1.05rem;
                min-height: 48px;
            }

            #status-msg {
                font-size: 0.85rem;
            }

            #profile-info {
                font-size: 0.8rem;
                margin-top: 0.75rem;
            }

            /* Previously the demo area was forcibly hidden on mobile which prevented scrolling to reach UI elements.
               Allow the demo area to remain visible but constrain its height so the sidebar/menu can still scroll.
               The demo canvas itself remains non-scrollable (overflow hidden) so gameplay visuals aren't scrollable. */
            #ui-layer:not(.hidden) #demo-container {
                display: block !important;
                max-height: 40vh;       /* reserve a portion of the screen for the demo visual */
                overflow: hidden;       /* keep the gameplay canvas itself static (no inner scrolling) */
            }

            #demoCanvas {
                width: 100% !important;
                height: 100% !important;
            }

            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
            }

            #hud {
                top: 0.6rem;
                left: 0.6rem;
                font-size: 0.78rem;
            }

            #hud .text-xl {
                font-size: 0.95rem;
            }

            #hud .text-lg {
                font-size: 0.85rem;
            }

            #hud .text-sm {
                font-size: 0.75rem;
            }

            #song-progress-container {
                width: 10.5rem;
            }

            #career-modal > div,
            #offline-modal > div {
                max-width: 100%;
                max-height: 80vh;
                margin: 0.75rem;
                padding: 1rem;
            }

            #career-modal h2,
            #offline-modal h2 {
                font-size: 1.5rem;
            }

            #track-info {
                bottom: 0.6rem;
                right: 0.6rem;
                font-size: 0.72rem;
            }

            #countdown-screen #countdown-text {
                font-size: 1rem;
                text-align: center;
                padding: 0 1rem;
            }

            #countdown-screen .w-32.h-32 {
                width: 5.8rem;
                height: 5.8rem;
            }

            /* Ensure offline modal buttons are comfortably touchable */
            #offline-modal button,
            #career-modal button {
                padding: 0.7rem 1rem;
                font-size: 0.95rem;
            }
        }

        /* Neon-styled range sliders for menu music and level preview */
        #menu-music-volume,
        #level-volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(34,211,238,0.15), rgba(244,63,94,0.25));
            box-shadow: 0 0 8px rgba(34,211,238,0.4);
            outline: none;
            cursor: pointer;
        }

        #menu-music-volume::-webkit-slider-thumb,
        #level-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #06b6d4;
            box-shadow:
                0 0 6px #06b6d4,
                0 0 12px #06b6d4,
                0 0 18px rgba(6,182,212,0.9);
            border: 2px solid #0f172a;
            margin-top: -6px;
        }

        #menu-music-volume::-moz-range-thumb,
        #level-volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #06b6d4;
            box-shadow:
                0 0 6px #06b6d4,
                0 0 12px #06b6d4,
                0 0 18px rgba(6,182,212,0.9);
            border: 2px solid #0f172a;
        }

        #menu-music-volume::-moz-range-track,
        #level-volume-slider::-moz-range-track {
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(34,211,238,0.15), rgba(244,63,94,0.25));
        }

        #menu-music-volume:focus-visible,
        #level-volume-slider:focus-visible {
            outline: none;
            box-shadow:
                0 0 0 2px rgba(15,23,42,1),
                0 0 0 4px rgba(34,211,238,0.7);
        }

        .story-text {
            line-height: 1.6;
            color: #e0e0e0;
            font-style: italic;
        }

        .deadly-mode-active {
            border-color: #ff0000 !important;
            color: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000 !important;
        }

        .deadly-mode-active .checkbox-slider {
            background-color: #ff0000 !important;
            border-color: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000 !important;
        }

        .skin-slot {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .skin-slot:hover:not(.locked) {
            border-color: #a855f7;
            box-shadow: 0 0 10px #a855f7;
            transform: translateY(-2px);
        }

        .skin-slot.selected {
            background: rgba(168, 85, 247, 0.2);
            border-color: #d8b4fe;
            box-shadow: 0 0 15px #a855f7, inset 0 0 10px #a855f7;
        }

        .skin-slot.locked {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(20, 0, 0, 0.6);
            border-color: #441111;
        }

        .skin-icon {
            width: 60%;
            height: 60%;
        }

        .bg-grid-pattern {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body class="bg-gray-900 text-white font-sans gradient-bg">
    <!-- Loading Screen -->
    <div id="loading-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black z-50" style="display: flex;">
        <div class="spinner w-16 h-16 border-4 border-cyan-400 border-t-transparent rounded-full mb-4"></div>
        <p class="text-xl text-cyan-400" style="text-shadow: 0 0 10px #22d3ee, 0 0 20px #22d3ee;">Loading...</p>
        <p id="loading-status" class="text-sm text-gray-400 mt-2">Initializing audio system</p>
        <p id="loading-tip" class="text-xs text-gray-400 mt-2 text-center" style="max-width:420px;">
            If this screen seems stuck for a long time, don't worry ‚Äî menu music or SFX can occasionally fail to load. Try reloading the page 1‚Äì5 times; it usually fixes the issue.
        </p>
    </div>

    <div id="hud" class="absolute top-5 left-5 z-50 pointer-events-none hidden">
        <div id="score-container" class="text-xl font-bold mb-2 flex items-center" style="text-shadow: 0 0 8px #22d3ee, 0 0 16px #22d3ee;">
            SCORE: <span id="score-display" class="ml-2 text-cyan-400">0</span>
        </div>
        <div id="combo-container" class="text-lg font-bold mb-2 hidden combo-display">
            COMBO: <span id="combo-display" class="ml-2 text-yellow-400">0</span>x
            <span id="combo-multiplier" class="ml-2 text-pink-400 text-sm"></span>
            <div id="combo-meter" class="w-32 h-1 bg-gray-700 border border-yellow-400 rounded mt-1 overflow-hidden">
                <div id="combo-meter-fill" class="h-full bg-gradient-to-r from-yellow-400 to-pink-500" style="width: 0%; transition: width 0.2s;"></div>
            </div>
        </div>
        <div id="graze-container" class="text-sm mb-1 flex items-center" style="text-shadow: 0 0 6px #fbbf24, 0 0 12px #fbbf24; color: #fbbf24;">
            GRAZE: <span id="graze-display" class="ml-2">0</span>
        </div>
        <div class="text-sm mb-1 flex items-center" style="text-shadow: 0 0 6px #fbbf24, 0 0 12px #fbbf24;">
            TIME: <span id="time-display" class="ml-2 text-yellow-400">0.0s</span>
        </div>
        <div class="text-sm mb-1 flex items-center" style="text-shadow: 0 0 6px #ec4899, 0 0 12px #ec4899;">
            LEVEL: <span id="level-display" class="ml-2 text-pink-400">1</span>
        </div>
        <div id="deadly-mode-indicator" class="text-sm mb-1 hidden" style="text-shadow: 0 0 6px #ff0000, 0 0 12px #ff0000; color: #ff0000;">
            ‚ö†Ô∏è DEADLY MODE
        </div>
        <div class="w-48 h-2 bg-gray-700 border border-white rounded mt-2 relative overflow-hidden">
            <div id="health-bar" class="h-full health-bar rounded" style="background: linear-gradient(90deg, #00ff00, #00ff88, #00ff00); background-size: 200% 100%;"></div>
            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white to-transparent opacity-20 animate-pulse"></div>
        </div>
        <div id="song-progress-container" class="w-48 h-3 bg-gray-900 border border-gray-700 rounded mt-3 relative overflow-hidden" style="box-shadow: 0 0 8px rgba(34, 242, 255, 0.3), 0 0 16px rgba(34, 242, 255, 0.2);">
            <div class="absolute inset-0 bg-gradient-to-r from-gray-900 via-gray-800 to-gray-900 opacity-70"></div>
            <div class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(255,255,255,0.12),_transparent_60%)] pointer-events-none"></div>
            <div id="song-progress-track" class="relative w-full h-full">
                <div id="song-progress-bar" class="absolute left-0 top-0 h-full bg-gradient-to-r from-cyan-400 via-sky-400 to-blue-500 rounded-r-full" style="width:0%; box-shadow: 0 0 10px #22d3ee, 0 0 20px #22d3ee;">
                    <div class="absolute inset-0 bg-[linear-gradient(120deg,rgba(255,255,255,0.3)_0,transparent_30%,transparent_70%,rgba(255,255,255,0.3)_100%)] opacity-50"
                         style="animation: progressGlow 1.4s linear infinite;"></div>
                </div>
                <div id="song-progress-head" class="absolute -right-1 top-1/2 -translate-y-1/2 w-2 h-2 rounded-full bg-cyan-200"
                     style="transform-origin:center; animation: progressHeadPulse 1.2s ease-in-out infinite;"></div>
            </div>
        </div>

    </div>

    <div id="track-info" class="absolute bottom-5 right-5 text-right text-sm text-gray-400 pointer-events-none" style="text-shadow: 0 0 6px currentColor, 0 0 12px currentColor;">
        Waiting for track...
    </div>

    <div id="ui-layer" class="absolute inset-0 flex bg-black z-10 transition-opacity duration-500 hidden">
        <!-- Left Sidebar Menu -->
        <div id="menu-sidebar" class="w-80 bg-gradient-to-r from-black via-gray-900 to-transparent p-8 flex flex-col justify-center space-y-6 z-20">
            <h1 class="text-5xl font-bold mb-6 neon-text">AMPLITUDE<br>ASSAULT</h1>

            <!-- PROFILE is always visible at the top on all states -->
            <div id="profile-info" class="text-cyan-400 text-sm mb-4" style="text-shadow: 0 0 6px #22d3ee, 0 0 12px #22d3ee;">
                PROFILE LVL 1 ‚Äî EXP 0 / 1000
            </div>

            <!-- GAME SECTION -->
            <div class="border border-cyan-500/40 rounded-lg bg-black/40 px-4 py-3 space-y-3 mb-4">
                <div id="game-section-header" class="flex items-center justify-between mb-1 cursor-pointer select-none">
                    <span class="text-xs font-semibold text-cyan-300 tracking-[0.15em] uppercase">Game</span>
                    <span id="game-section-toggle" class="text-xs text-cyan-300">‚ñº</span>
                </div>

                <div id="game-section-content" class="space-y-3">
                    <input type="file" id="file-input" accept="audio/*" class="hidden">

                    <button id="upload-btn" class="w-full px-6 py-3 bg-transparent border-2 border-cyan-400 text-cyan-400 hover:bg-cyan-400 hover:text-black transition-all duration-200 rounded glow-button text-left text-base font-bold">
                        CHOOSE YOUR SONG
                    </button>
                    <button id="career-btn" class="w-full px-6 py-3 bg-transparent border-2 border-yellow-400 text-yellow-400 hover:bg-yellow-400 hover:text-black transition-all duration-200 rounded glow-button text-left text-base font-bold">
                        CAREER
                    </button>
                    <button id="tutorial-btn" class="w-full px-6 py-3 bg-transparent border-2 border-cyan-400 text-cyan-400 hover:bg-cyan-400 hover:text-black transition-all duration-200 rounded glow-button text-left text-base font-bold">
                        TUTORIAL
                    </button>
                    <button id="start-btn" disabled class="w-full px-6 py-3 bg-transparent border-2 border-pink-400 text-pink-400 hover:bg-pink-400 hover:text-black transition-all duration-200 rounded glow-button text-left text-base font-bold opacity-50">
                        VIEW LEVEL
                    </button>
                </div>
            </div>

            <!-- CUSTOMIZE / OPTIONS SECTION -->
            <div class="border border-purple-500/40 rounded-lg bg-black/30 px-4 py-3 space-y-3 mb-4">
                <div id="customize-section-header" class="flex items-center justify-between mb-1 cursor-pointer select-none">
                    <span class="text-xs font-semibold text-purple-300 tracking-[0.15em] uppercase">Customize</span>
                    <div class="flex items-center gap-2">
                        <button id="lore-book-btn" class="text-[0.7rem] px-2 py-1 border border-cyan-400 text-cyan-300 rounded glow-button hover:bg-cyan-400 hover:text-black">
                            LORE
                        </button>
                        <button id="garage-btn" class="text-[0.7rem] px-2 py-1 border border-purple-400 text-purple-300 rounded glow-button hover:bg-purple-400 hover:text-black">
                            GARAGE
                        </button>
                        <span id="customize-section-toggle" class="text-xs text-purple-300">‚ñº</span>
                    </div>
                </div>

                <div id="customize-section-content" class="space-y-3">
                    <div>
                        <label class="text-[0.7rem] text-gray-400 mb-1 block">
                            Menu Music
                            <input id="menu-music-volume" type="range" min="0" max="100" value="50" class="w-full mt-1">
                        </label>
                    </div>

                    
                    <div class="flex items-center justify-between gap-3">
                        <div class="flex items-center gap-2">
                            <label class="custom-checkbox">
                                <input type="checkbox" id="menu-ai-toggle" checked>
                                <span class="checkbox-slider"></span>
                            </label>
                            <label for="menu-ai-toggle" class="text-xs text-cyan-300" style="text-shadow: 0 0 6px #67e8f9, 0 0 12px #67e8f9;">Show Player</label>
                        </div>

                        <div class="flex items-center gap-2">
                            <label class="custom-checkbox deadly-mode-checkbox">
                                <input type="checkbox" id="deadly-mode-toggle">
                                <span class="checkbox-slider"></span>
                            </label>
                            <label for="deadly-mode-toggle" class="text-xs text-red-400" style="text-shadow: 0 0 6px #ff0000, 0 0 12px #ff0000;">Deadly Mode</label>
                        </div>
                    </div>

                    <!-- Graphics Quality Selector -->
                    <div class="mt-3">
                        <label class="text-[0.7rem] text-gray-400 mb-1 block">
                            Graphics Quality
                            <select id="graphics-quality-select" class="w-full mt-1 bg-black border border-cyan-500 rounded px-2 py-2 text-sm text-gray-200">
                                <option value="ULTRA">Ultra (BLOOM - Performance Heavy)</option>
                                <option value="HIGH">High (All effects)</option>
                                <option value="MEDIUM">Medium (No particles, reduced glow)</option>
                                <option value="BASIC">Basic (No glow, no gradients)</option>
                            </select>
                        </label>
                        <p class="text-[0.65rem] text-gray-500">Choose performance / style preferences. Changes apply immediately.</p>
                    </div>

                    <div class="pt-1">
                        <p class="text-[0.7rem] text-gray-400 mb-2">
                            Download the game to play offline:
                        </p>
                        <button id="offline-info-btn" class="w-full text-left px-4 py-2 bg-transparent border-2 border-emerald-400 text-emerald-400 hover:bg-emerald-400 hover:text-black transition-all duration-200 rounded glow-button text-xs">
                            Download Game
                        </button>
                    </div>
                </div>
            </div>

            <!-- STATUS + LEVEL PREVIEW SECTION -->
            <div class="space-y-2 mt-1">
                <div id="status-msg" class="text-red-400 text-xs min-h-[1.25rem]"></div>
                <div id="selected-difficulty" class="text-xs hidden"></div>
                <!-- Sidebar preview for selected song / career level -->
                <div id="sidebar-preview" class="mt-1 text-[0.7rem] text-gray-300 space-y-2"></div>
            </div>
        </div>
        
        <!-- Demo Gameplay Background -->
        <div id="demo-container" class="flex-1 relative overflow-hidden">
            <canvas id="demoCanvas" class="absolute inset-0 w-full h-full"></canvas>
        </div>
    </div>

    <div id="career-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-95 z-20 hidden">
        <div class="bg-gray-900 border-2 border-cyan-400 rounded-lg p-8 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto" style="box-shadow: 0 0 20px #22d3ee, 0 0 40px #22d3ee;">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400 neon-text">CAREER MODE</h2>
            <div id="career-songs" class="space-y-4">
            </div>
            <button id="close-career" class="mt-6 px-6 py-3 bg-transparent border-2 border-red-400 text-red-400 hover:bg-red-400 hover:text-black transition-all duration-200 rounded-lg glow-button">
                Back
            </button>
        </div>
    </div>

    <!-- Garage (Character Chooser) Modal -->
    <!-- ENDING / FINALE MODAL (shown after beating Mutant career final) -->
    <div id="ending-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-95 z-90 hidden" style="opacity:0; transition: opacity 0.2s;">
        <div class="bg-gray-900 border-2 border-green-400 rounded-lg p-8 max-w-3xl w-full mx-4" style="box-shadow: 0 0 24px #00ff41;">
            <h2 id="ending-title" class="text-3xl font-bold mb-4 text-green-400 neon-text">THE CORE HAS BEEN CLEARED</h2>
            <div id="ending-body" class="text-gray-300 leading-relaxed mb-6">
                <p></p>
            </div>
            <div class="flex justify-end gap-3">
                <button id="ending-close" class="px-4 py-2 bg-transparent border-2 border-gray-400 text-gray-400 hover:bg-gray-400 hover:text-black rounded glow-button">Close</button>
                <button id="ending-exit" class="px-4 py-2 bg-transparent border-2 border-green-400 text-green-400 hover:bg-green-400 hover:text-black rounded glow-button">Return to Menu</button>
            </div>
        </div>
    </div>

    <!-- Lore Book Modal -->
    <div id="lore-book-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-95 z-30 hidden">
        <div class="bg-gradient-to-br from-slate-900 via-gray-900 to-black border-2 border-cyan-500/50 rounded-xl w-full max-w-5xl h-[90vh] flex flex-col relative overflow-hidden shadow-2xl shadow-cyan-900/40">
            <!-- Header -->
            <div class="p-6 border-b border-cyan-500/30 bg-black/40 flex justify-between items-center z-10 backdrop-blur-md">
                <div class="flex items-center gap-4">
                    <div class="w-12 h-12 rounded bg-cyan-900/20 border border-cyan-400 flex items-center justify-center text-cyan-400 text-2xl">
                        <span>üìö</span>
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold text-cyan-400 tracking-wider">SYSTEM ARCHIVE</h2>
                        <p class="text-xs text-gray-400 font-mono mt-1">ACCESS LEVEL: UNRESTRICTED</p>
                    </div>
                </div>
                <button id="close-lore-book" class="px-6 py-2 bg-red-500/10 border border-red-500/50 text-red-400 hover:bg-red-500/20 hover:text-red-200 transition-all rounded font-mono text-sm tracking-widest">
                    DISCONNECT
                </button>
            </div>
            
            <!-- Content -->
            <div class="flex-1 overflow-y-auto custom-scrollbar p-6 space-y-8 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-gray-900 via-black to-black">
                
                <!-- Lore Intro -->
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="p-6 rounded-lg border border-cyan-500/20 bg-cyan-900/5 backdrop-blur-sm relative overflow-hidden group hover:border-cyan-500/40 transition-all">
                        <div class="absolute top-0 right-0 p-4 text-6xl text-cyan-500/5 select-none">DATA</div>
                        <h3 class="text-xl font-bold text-cyan-300 mb-4 flex items-center gap-2">
                            <span class="w-2 h-2 bg-cyan-400 rounded-full animate-pulse"></span>
                            THE INCIDENT
                        </h3>
                        <p class="text-gray-300 text-sm leading-relaxed mb-4">
                            Cycle 404: The Core Protocol was breached. A rhythmic virus, origin unknown, injected itself into the audio mainframe. It doesn't just corrupt data‚Äîit weaponizes sound waves.
                        </p>
                        <p class="text-gray-300 text-sm leading-relaxed">
                            You are a specialized antivirus construct. Your method of operation is synchronization: move with the beat, anticipate the algorithm, and delete the corruption at its source.
                        </p>
                    </div>

                    <div class="p-6 rounded-lg border border-yellow-500/20 bg-yellow-900/5 backdrop-blur-sm relative overflow-hidden group hover:border-yellow-500/40 transition-all">
                        <div class="absolute top-0 right-0 p-4 text-6xl text-yellow-500/5 select-none">CODE</div>
                        <h3 class="text-xl font-bold text-yellow-300 mb-4 flex items-center gap-2">
                            <span class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></span>
                            DIRECTIVES
                        </h3>
                        <ul class="space-y-3 text-sm text-gray-300">
                            <li class="flex gap-3">
                                <span class="text-yellow-500 font-bold">01.</span>
                                <span><strong>Survive the Pulse:</strong> The virus manifests as projectiles synced to the audio spectrum. Bass hits are heavy explosives. Treble is sharp shrapnel.</span>
                            </li>
                            <li class="flex gap-3">
                                <span class="text-yellow-500 font-bold">02.</span>
                                <span><strong>Adapt & Evolve:</strong> Gather data (Score) to upgrade your construct form (Skins). Higher forms do not increase power, but they signify mastery.</span>
                            </li>
                            <li class="flex gap-3">
                                <span class="text-yellow-500 font-bold">03.</span>
                                <span><strong>Purge the Bosses:</strong> Major nodes of corruption have evolved sentience. These "Bosses" control specific sectors. Deletion is mandatory.</span>
                            </li>
                        </ul>
                    </div>
                </div>

                <!-- Entity Database -->
                <div class="border-t border-gray-800 pt-8">
                    <h3 class="text-lg font-mono text-gray-500 mb-6 tracking-widest uppercase">Entity Database_v9.2</h3>
                    
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <!-- Shogun -->
                        <div class="bg-gray-900/50 border border-yellow-500/30 p-4 rounded hover:bg-gray-800/50 transition-colors">
                            <div class="flex justify-between items-start mb-3">
                                <h4 class="text-yellow-400 font-bold text-lg">SHOGUN</h4>
                                <span class="px-2 py-0.5 bg-yellow-500/20 text-yellow-300 text-[10px] rounded border border-yellow-500/30">MELEE CLASS</span>
                            </div>
                            <p class="text-xs text-gray-400 mb-3 leading-relaxed">
                                Heavily armored node favoring close-quarters combat. Teleports to edges before launching devastating cross-screen dashes.
                            </p>
                            <div class="text-[10px] text-gray-500 font-mono">
                                <div>> SPECIAL: Super Dash</div>
                                <div>> WEAKNESS: Post-dash recovery</div>
                            </div>
                        </div>

                        <!-- Sentinel -->
                        <div class="bg-gray-900/50 border border-cyan-500/30 p-4 rounded hover:bg-gray-800/50 transition-colors">
                            <div class="flex justify-between items-start mb-3">
                                <h4 class="text-cyan-400 font-bold text-lg">SENTINEL</h4>
                                <span class="px-2 py-0.5 bg-cyan-500/20 text-cyan-300 text-[10px] rounded border border-cyan-500/30">RANGED CLASS</span>
                            </div>
                            <p class="text-xs text-gray-400 mb-3 leading-relaxed">
                                The watchful eye. Spins continuously, emitting radial bursts of data-shards. Can deploy laser grids to restrict movement.
                            </p>
                            <div class="text-[10px] text-gray-500 font-mono">
                                <div>> SPECIAL: Omni-directional burst</div>
                                <div>> WEAKNESS: Predictable rhythm</div>
                            </div>
                        </div>

                        <!-- Hydra -->
                        <div class="bg-gray-900/50 border border-purple-500/30 p-4 rounded hover:bg-gray-800/50 transition-colors">
                            <div class="flex justify-between items-start mb-3">
                                <h4 class="text-purple-400 font-bold text-lg">HYDRA</h4>
                                <span class="px-2 py-0.5 bg-purple-500/20 text-purple-300 text-[10px] rounded border border-purple-500/30">SWARM CLASS</span>
                            </div>
                            <p class="text-xs text-gray-400 mb-3 leading-relaxed">
                                A cluster node with three independent sub-cores. Each head tracks you differently. Constant movement is required to survive.
                            </p>
                            <div class="text-[10px] text-gray-500 font-mono">
                                <div>> SPECIAL: Venom Volley</div>
                                <div>> WEAKNESS: Shared hitbox</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Threat Registry -->
                <div class="border-t border-gray-800 pt-8">
                    <h3 class="text-lg font-mono text-gray-500 mb-6 tracking-widest uppercase">Threat Registry</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="p-3 bg-gray-900/30 border border-gray-800 rounded">
                            <div class="text-purple-400 font-bold text-sm mb-1">SHARD</div>
                            <p class="text-[10px] text-gray-500">Standard projectile. Fast, straight trajectory. Dodge or break for combo.</p>
                        </div>
                        <div class="p-3 bg-gray-900/30 border border-gray-800 rounded">
                            <div class="text-cyan-400 font-bold text-sm mb-1">SWEEPER</div>
                            <p class="text-[10px] text-gray-500">Wall of data. Horizontal or Vertical. Find the gap instantly.</p>
                        </div>
                        <div class="p-3 bg-gray-900/30 border border-gray-800 rounded">
                            <div class="text-orange-400 font-bold text-sm mb-1">ROCKET</div>
                            <p class="text-[10px] text-gray-500">Homing explosive. Locks on then sprints. Lure it away.</p>
                        </div>
                        <div class="p-3 bg-gray-900/30 border border-gray-800 rounded">
                            <div class="text-red-400 font-bold text-sm mb-1">LINE</div>
                            <p class="text-[10px] text-gray-500">Instant laser beam. Dashed line = warning. Solid line = damage.</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>
    </div>

    <div id="garage-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-95 z-30 hidden">
        <div class="bg-gray-900 border-2 border-purple-500 rounded-lg p-6 md:p-8 max-w-4xl w-full mx-4 max-h-[85vh] flex flex-col" style="box-shadow: 0 0 20px #a855f7, 0 0 40px #a855f7;">
            <div class="flex justify-between items-center mb-6">
                <div>
                    <h2 class="text-3xl font-bold text-purple-400 neon-text">GARAGE</h2>
                    <p class="text-gray-400 text-sm mt-1">Unlock new shapes every 5 levels.</p>
                </div>
                <div class="text-right">
                    <div id="garage-level-display" class="text-xl font-bold text-cyan-400">LVL 1</div>
                    <div id="garage-xp-display" class="text-xs text-gray-500">EXP 0 / 1000</div>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto custom-scrollbar">
                <!-- Preview Area -->
                <div class="flex justify-center mb-8">
                    <div class="w-32 h-32 bg-black border border-gray-700 rounded-lg flex items-center justify-center relative overflow-hidden" style="box-shadow: inset 0 0 20px rgba(0,0,0,0.8);">
                        <div class="absolute inset-0 bg-grid-pattern opacity-20"></div>
                        <canvas id="garage-preview-canvas" width="128" height="128"></canvas>
                    </div>
                </div>

                <!-- Skins Grid -->
                <div id="skins-grid" class="grid grid-cols-4 md:grid-cols-5 gap-4 p-2">
                    <!-- Grid items generated by JS -->
                </div>
            </div>

            <div class="mt-6 flex justify-end">
                <button id="close-garage" class="px-8 py-3 bg-transparent border-2 border-red-400 text-red-400 hover:bg-red-400 hover:text-black transition-all duration-200 rounded-lg glow-button font-bold">
                    CLOSE
                </button>
            </div>
        </div>
    </div>

    <!-- Level Preview Modal -->
    <div id="level-preview-modal" class="absolute inset-0 flex items-start justify-start bg-black z-40 hidden" style="transition: opacity 0.5s;">
        <div class="w-full h-full flex flex-col items-start justify-center p-4 md:p-8 relative">
            <div id="level-preview-content" class="w-full max-w-xl md:max-w-2xl bg-gray-900 rounded-lg p-4 md:p-8 border-2 border-cyan-400 max-h-[85vh] overflow-y-auto ml-0 md:ml-16" style="box-shadow: 0 0 40px rgba(34, 211, 238, 0.5);">
                <div class="flex flex-col md:flex-row gap-4 md:gap-6 mb-4 md:mb-6">
                    <div class="flex-shrink-0 mx-auto md:mx-0">
                        <div id="level-cover-art" class="w-48 h-48 md:w-64 md:h-64 bg-gray-800 rounded-lg border-2 border-cyan-400 flex items-center justify-center overflow-hidden" style="box-shadow: 0 0 20px rgba(34, 211, 238, 0.3);">
                            <div class="spinner w-12 h-12 border-4 border-cyan-400 border-t-transparent rounded-full"></div>
                        </div>
                    </div>
                    <div class="flex-1">
                        <h2 id="level-preview-title" class="text-2xl md:text-3xl font-bold text-cyan-400 mb-2 neon-text">Loading...</h2>
                        <p id="level-preview-difficulty" class="text-base md:text-lg mb-3 md:mb-4"></p>
                        <p id="level-preview-description" class="text-sm text-gray-300 mb-3 md:mb-4 leading-relaxed">Generating level information...</p>
                    </div>
                </div>
                
                <div class="mb-4 md:mb-6">
                    <label class="text-sm text-gray-400 mb-2 block flex items-center justify-between">
                        <span>Preview Volume</span>
                        <span id="volume-display" class="text-cyan-400">50%</span>
                    </label>
                    <input id="level-volume-slider" type="range" min="0" max="100" value="50" class="w-full">
                </div>
                
                <div class="flex flex-col md:flex-row gap-3 md:gap-4">
                    <button id="play-level-btn" class="flex-1 px-6 py-3 bg-transparent border-2 border-pink-400 text-pink-400 hover:bg-pink-400 hover:text-black transition-all duration-200 rounded-lg glow-button text-lg md:text-xl font-bold">
                        PLAY SONG
                    </button>
                    <button id="back-from-preview-btn" class="px-6 py-3 bg-transparent border-2 border-gray-400 text-gray-400 hover:bg-gray-400 hover:text-black transition-all duration-200 rounded-lg glow-button">
                        BACK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="offline-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-95 z-30 hidden">
        <div class="bg-gray-900 border-2 border-emerald-400 rounded-lg p-6 max-w-3xl w-full mx-4 max-h-[85vh] overflow-y-auto" style="box-shadow: 0 0 20px #10b981, 0 0 40px #10b981;">
            <h2 class="text-2xl font-bold mb-4 text-emerald-400 neon-text">Play Amplitude Assault Offline</h2>
            <p class="text-sm text-gray-300 mb-4">
                The whole game fits in a single <span class="text-emerald-400 font-mono">index.html</span> file plus a few music files ‚Äî no installer, no account, just download and play.
            </p>
            <div class="space-y-4 text-xs text-gray-200">
                <div class="border border-emerald-500/40 rounded-md p-3 bg-black/40">
                    <h3 class="font-semibold text-emerald-300 mb-1 flex items-center gap-2">
                        <span class="w-5 h-5 rounded-full bg-emerald-500 text-black flex items-center justify-center text-[0.7rem]">1</span>
                        Get the game file
                    </h3>
                    <button id="download-code-btn" class="mt-1 px-4 py-2 bg-transparent border-2 border-emerald-400 text-emerald-400 hover:bg-emerald-400 hover:text-black transition-all duration-200 rounded glow-button mb-2">
                        Download <span class="font-mono">index.html</span>
                    </button>
                    <p>Click the button above to download a ready‚Äëto‚Äërun copy of the game. Modern browsers sometimes block ‚ÄúSave As‚Äù on complex pages, so this button gives you a clean file directly.</p>
                </div>
                <div class="border border-cyan-500/40 rounded-md p-3 bg-black/40">
                    <h3 class="font-semibold text-cyan-300 mb-1 flex items-center gap-2">
                        <span class="w-5 h-5 rounded-full bg-cyan-400 text-black flex items-center justify-center text-[0.7rem]">2</span>
                        (Optional) Grab the built‚Äëin tracks
                    </h3>
                    <ul class="list-disc list-inside space-y-1 mb-2">
                        <li><a href="/Blow It Away.mp3" class="text-cyan-300 underline" download>Blow It Away.mp3</a></li>
                        <li><a href="/Digital Masquerade.mp3" class="text-cyan-300 underline" download>Digital Masquerade.mp3</a></li>
                        <li><a href="/Dizzy Carousel.mp3" class="text-cyan-300 underline" download>Dizzy Carousel.mp3</a></li>
                        <li><a href="/Mutant.mp3" class="text-cyan-300 underline" download>Mutant.mp3</a></li>
                        <li><a href="/Tutorial SOng.mp3" class="text-cyan-300 underline" download>Tutorial SOng.mp3</a></li>
                        <li><a href="/MainMenu.wav" class="text-cyan-300 underline" download>MainMenu.wav</a></li>
                    </ul>
                    <div class="mt-1 flex flex-wrap gap-2">
                        <!-- use a different id to avoid duplicating 'download-code-btn' (fixes event/id collision when saving) -->
                        <button id="download-index-btn" class="px-4 py-2 bg-transparent border-2 border-emerald-400 text-emerald-400 hover:bg-emerald-400 hover:text-black transition-all duration-200 rounded glow-button mb-2">
                            Download only <span class="font-mono">index.html</span>
                        </button>
                        <button id="download-all-btn" class="px-4 py-2 bg-transparent border-2 border-cyan-400 text-cyan-400 hover:bg-cyan-400 hover:text-black transition-all duration-200 rounded glow-button mb-2">
                            Download everything (game + songs)
                        </button>
                    </div>
                    <p class="mt-1">Put all of these files in the same folder as <span class="font-mono">index.html</span> so career mode can find its music while you‚Äôre offline.</p>
                </div>
                <div class="border border-emerald-500/40 rounded-md p-3 bg-black/40">
                    <h3 class="font-semibold text-emerald-300 mb-1 flex items-center gap-2">
                        <span class="w-5 h-5 rounded-full bg-emerald-500 text-black flex items-center justify-center text-[0.7rem]">3</span>
                        Run it on your device
                    </h3>
                    <ul class="list-disc list-inside space-y-1">
                        <li><span class="font-semibold">Windows / macOS / Linux:</span> Put the files in a folder, then double‚Äëclick <span class="font-mono">index.html</span> to open it in your browser. For best audio compatibility, you can also run a tiny local server (for example <span class="font-mono">python -m http.server</span>) and open <span class="font-mono">http://localhost:8000</span>.</li>
                        <li><span class="font-semibold">ChromeOS:</span> Copy everything into ‚ÄúDownloads‚Äù, then open <span class="font-mono">index.html</span> in Chrome. Some browsers may require a click before audio starts.</li>
                        <li><span class="font-semibold">Android / iOS:</span> Use any local‚Äëfile web server or code‚Äëeditor app that can host HTML, then open its URL in your mobile browser.</li>
                    </ul>
                </div>
                <div class="border border-emerald-500/40 rounded-md p-3 bg-black/40">
                    <h3 class="font-semibold text-emerald-300 mb-1 flex items-center gap-2">
                        <span class="w-5 h-5 rounded-full bg-emerald-500 text-black flex items-center justify-center text-[0.7rem]">4</span>
                        Use your own music
                    </h3>
                    <p>Offline works exactly like online: click ‚ÄúCHOOSE YOUR SONG‚Äù and pick any audio file from your device. The game analyses it locally and builds the level live ‚Äî nothing is uploaded anywhere.</p>
                </div>
            </div>
            <button id="close-offline-btn" class="mt-4 px-4 py-2 bg-transparent border-2 border-red-400 text-red-400 hover:bg-red-400 hover:text-black transition-all duration-200 rounded glow-button">
                Close
            </button>
        </div>
    </div>

    <!-- Gentle weekly reminder to try the offline version -->
    <div id="download-reminder-modal" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-40 hidden">
        <div class="bg-gray-900 border border-cyan-400 rounded-lg p-4 mx-4 max-w-sm w-full" style="box-shadow: 0 0 18px rgba(34,211,238,0.6);">
            <h3 class="text-lg font-bold text-cyan-300 mb-2">Enjoying Amplitude Assault?</h3>
            <p class="text-xs text-gray-300 mb-3">
                You can download the whole game as a single file and keep playing even when you‚Äôre offline.
            </p>
            <div class="flex flex-col gap-2">
                <button id="download-reminder-yes" class="px-4 py-2 bg-transparent border-2 border-emerald-400 text-emerald-400 hover:bg-emerald-400 hover:text-black transition-all duration-200 rounded glow-button text-sm">
                    Show me how to download it
                </button>
                <button id="download-reminder-later" class="px-4 py-2 bg-transparent border border-gray-500 text-gray-300 hover:bg-gray-700 transition-all duration-200 rounded text-xs">
                    Maybe later
                </button>
                <button id="download-reminder-never" class="mt-1 px-2 py-1 bg-transparent border-0 text-[0.7rem] text-gray-500 underline">
                    Don‚Äôt show this again
                </button>
            </div>
        </div>
    </div>

    <div id="visualizer-container" class="absolute inset-0 pointer-events-none">
        <canvas id="gameCanvas" class="block w-full h-full"></canvas>
    </div>

    <script>
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.analyser = null;
                this.source = null;
                this.dataArray = null;
                this.audioBuffer = null;
                this.isPlaying = false;
                this.gainNode = null;
                this.startTime = 0;
                this.startTimestamp = 0;
                
                this.bass = 0;
                this.mid = 0;
                this.treble = 0;
                this.volume = 0;
                this.frequencyData = null;

                // Beat / energy tracking
                this.lastEnergy = 0;
                this.beat = 0;
                this.beatStrength = 0;

                // Default gain value used when starting playback; can be overridden (e.g. by level preview slider)
                this.defaultGain = 0.5;

                // Rate-limit timestamp for device vibration (ms)
                this._lastVibeTime = 0;
            }

            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
                // gainNode is the *output* gain for user volume; analyser always sees full signal
                this.gainNode = this.ctx.createGain();
            }

            async loadFile(file) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') await this.ctx.resume();

                const arrayBuffer = await file.arrayBuffer();
                try {
                    this.audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                    return this.audioBuffer.duration;
                } catch (error) {
                    console.error('Audio decode error:', error);
                    throw new Error('Unable to decode audio data');
                }
            }

            play(offset = 0) {
                if (this.source) {
                    try {
                        // Detach old onended handler so it can't re-trigger gameOver
                        this.source.onended = null;
                        this.source.stop();
                    } catch (e) {
                        // ignore
                    }
                }
                if (!this.ctx || !this.audioBuffer) return;
                this.source = this.ctx.createBufferSource();
                this.source.buffer = this.audioBuffer;
                // Use configured default gain (e.g. from level preview slider) instead of hardcoded 0.5.
                // This controls *output* loudness only; analyser input stays unchanged so difficulty doesn't change with volume.
                const gain = (typeof this.defaultGain === 'number') ? this.defaultGain : 0.5;
                this.gainNode.gain.value = gain;
                // Route: source -> analyser -> output gain -> speakers
                this.source.connect(this.analyser);
                this.analyser.connect(this.gainNode);
                this.gainNode.connect(this.ctx.destination);
                
                const maxOffset = Math.max(0, this.audioBuffer.duration - 0.05);
                const clampedOffset = Math.min(Math.max(offset, 0), maxOffset);
                this.startTime = clampedOffset;
                this.startTimestamp = this.ctx.currentTime;

                this.source.onended = () => {
                    this.isPlaying = false;
                    if (
                        typeof game !== 'undefined' &&
                        game.isRunning &&
                        !game.gameHasEnded &&
                        game.player.health > 0
                    ) {
                        game.gameOver("Song Finished!");
                    }
                    // Reset menu music when it ends
                    if (typeof demoGame !== 'undefined' && demoGame.isRunning && demoGame.audio === this) {
                        setTimeout(() => {
                            if (demoGame.isRunning) {
                                demoGame.audio.play(0);
                            }
                        }, 100);
                    }
                };

                this.source.start(0, clampedOffset);
                this.isPlaying = true;
            }

            async fadeOut(duration = 1000) {
                if (!this.gainNode) return;
                const startVolume = this.gainNode.gain.value;
                const startTime = performance.now();
                
                return new Promise(resolve => {
                    const fade = () => {
                        const elapsed = performance.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        this.gainNode.gain.value = startVolume * (1 - progress);
                        
                        if (progress < 1) {
                            requestAnimationFrame(fade);
                        } else {
                            resolve();
                        }
                    };
                    fade();
                });
            }

            stop() {
                if (this.source) {
                    try {
                        // Prevent any pending onended handler from firing after manual stop
                        this.source.onended = null;
                        this.source.stop();
                    } catch (e) {
                        // ignore
                    }
                    this.isPlaying = false;
                    this.source = null;
                }
            }

            getCurrentTime() {
                if (!this.ctx || !this.audioBuffer) return 0;
                if (!this.isPlaying) return this.startTime || 0;
                return (this.startTime || 0) + (this.ctx.currentTime - (this.startTimestamp || 0));
            }

            update() {
                if (!this.isPlaying) return;

                this.analyser.getByteFrequencyData(this.frequencyData);
                this.analyser.getByteFrequencyData(this.dataArray);

                const bassEnd = 15;
                const midEnd = 100;
                const trebleEnd = 300;

                let b = 0, m = 0, t = 0;

                for(let i = 0; i < bassEnd; i++) b += this.dataArray[i];
                for(let i = bassEnd; i < midEnd; i++) m += this.dataArray[i];
                for(let i = midEnd; i < trebleEnd; i++) t += this.dataArray[i];

                this.bass = (b / bassEnd) / 255;
                this.mid = (m / (midEnd - bassEnd)) / 255;
                this.treble = (t / (trebleEnd - midEnd)) / 255;
                
                this.volume = (this.bass * 0.4 + this.mid * 0.4 + this.treble * 0.2);

                // --- Simple beat / BPM-ish detection (energy-based) ---
                // Use low‚Äìmid band energy as a crude "beat" signal.
                let energy = 0;
                const beatStart = 5;
                const beatEnd = 80;
                for (let i = beatStart; i < Math.min(beatEnd, this.dataArray.length); i++) {
                    energy += this.dataArray[i];
                }
                const normEnergy = energy / ((beatEnd - beatStart) * 255 || 1);

                // Exponential moving average for energy baseline
                if (this.lastEnergy == null) this.lastEnergy = normEnergy;
                const smoothFactor = 0.9;
                this.lastEnergy = this.lastEnergy * smoothFactor + normEnergy * (1 - smoothFactor);

                const diff = normEnergy - this.lastEnergy;
                const beatThreshold = 0.12;
                if (diff > beatThreshold) {
                    // Strong beat "pulse"
                    this.beat = 1;
                    this.beatStrength = Math.min(1, diff * 8);
                } else {
                    this.beat = 0;
                    this.beatStrength = Math.max(0, (this.beatStrength || 0) * 0.9);
                }

                // Mobile vibration on very strong beats / very loud sections (rate-limited)
                try {
                    if (typeof IS_MOBILE !== 'undefined' && IS_MOBILE && navigator.vibrate) {
                        const now = performance.now();
                        const sinceLast = now - (this._lastVibeTime || 0);

                        // Drive vibration more directly from bass:
                        // - Very light / no vibration for soft bass
                        // - Strong, longer vibration for heavy bass hits
                        const bassLevel = this.bass || 0;
                        const strongTransient = diff > (beatThreshold * 1.8);
                        const veryLoud = this.volume > 0.82;

                        // Base duration scales with bass; clamp so we don't go crazy
                        let baseDuration = 0;
                        if (bassLevel > 0.25) {
                            baseDuration = 20 + (bassLevel * 90); // ~20‚Äì110ms
                        }
                        if (veryLoud) {
                            baseDuration += 40;
                        }

                        if ((strongTransient || veryLoud || bassLevel > 0.5) && baseDuration > 0 && sinceLast > 120) {
                            try { navigator.vibrate(Math.min(180, baseDuration)); } catch(e){}
                            this._lastVibeTime = now;
                        }
                    }
                } catch (e) {}
            }
        }

        // Global deadly mode state
        let DEADLY_MODE = false;

        // Career difficulty state (per-slot configurable)
        // EASY: slower, fewer attacks; MEDIUM: baseline; HARD: faster, denser attacks.
        let CAREER_DIFFICULTY = 'MEDIUM';
        let CAREER_SPEED_MULT = 1.0;
        let CAREER_SPAWN_MULT = 1.0;

        function setCareerDifficulty(diff) {
            CAREER_DIFFICULTY = diff;
            if (diff === 'EASY') {
                CAREER_SPEED_MULT = 0.65;
                CAREER_SPAWN_MULT = 1.8;
            } else if (diff === 'HARD') {
                CAREER_SPEED_MULT = 1.35;
                CAREER_SPAWN_MULT = 0.7;
            } else {
                CAREER_SPEED_MULT = 0.85;
                CAREER_SPAWN_MULT = 1.3;
            }
            try {
                localStorage.setItem('sys_career_difficulty', CAREER_DIFFICULTY);
            } catch (e) {}
        }

        // Load saved difficulty once
        try {
            const savedDiff = localStorage.getItem('sys_career_difficulty');
            if (savedDiff === 'EASY' || savedDiff === 'MEDIUM' || savedDiff === 'HARD') {
                setCareerDifficulty(savedDiff);
            } else {
                setCareerDifficulty('MEDIUM');
            }
        } catch (e) {
            setCareerDifficulty('MEDIUM');
        }

        // Mobile detection and speed factor used by many spawners/entities to make gameplay friendlier on phones
        // Broaden detection slightly and bias towards slower behavior on touch/mobile so projectiles feel controlled.
        const IS_MOBILE = ('ontouchstart' in window) || /Mobi|Android|iPhone|iPad/.test(navigator.userAgent) || window.innerWidth <= 900;
        // On mobile we slow entity speeds and increase spawn cooldowns (lower difficulty feel).
        // Slightly slower again for projectiles/obstacles so phones feel a pinch slower than desktop.
        // Slight desktop speed bump so desktop projectiles feel a touch snappier than mobile.
        // Keep mobile unchanged; desktop gets a small +3% speed boost.
        const BASE_SPEED_FACTOR = IS_MOBILE ? 0.72 : 1.03;
        const BASE_SPAWN_SCALE = 1 / BASE_SPEED_FACTOR;

        // Dynamic getters for speed/spawn; Deadly Mode no longer speeds projectiles up,
        // it just increases density and removes checkpoints.
        // Difficulty modifiers now ONLY apply to Career Mode.
        function getSpeedFactor() {
            let mult = 1.0;
            if (typeof game !== 'undefined' && game.isCareerMode) {
                mult = CAREER_SPEED_MULT;
            }
            return BASE_SPEED_FACTOR * mult;
        }
        function getSpawnScale() {
            // Deadly mode spawns patterns much more frequently
            const deadlyMult = DEADLY_MODE ? 0.25 : 1;
            let mult = 1.0;
            if (typeof game !== 'undefined' && game.isCareerMode) {
                mult = CAREER_SPAWN_MULT;
            }
            return BASE_SPAWN_SCALE * mult * deadlyMult;
        }

        // Layout 1: simplified OG-style checkerboard that better matches classic visuals and lets neon projectiles pop
        class CheckerboardVisualizer {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.baseSquareSize = 40;
                this.currentSquareSize = this.baseSquareSize;
                this.offsetY = 0;
                this.frequencies = new Array(32).fill(0);
                this.neonColors = [
                    '#FF006E', '#FF0080', '#FF3300', '#FF6600', '#FFAA00', '#00FF41', 
                    '#00FF88', '#00FFFF', '#0088FF', '#0044FF', '#6600FF', '#AA00FF'
                ];
                this.bossWrapAlpha = 0;
                this.bossX = 0;
                this.bossY = 0;
                this.bossR = 0;
            }

            setSize(width, height) {
                this.width = width;
                this.height = height;
            }

            setBossWrap(alpha, x, y, r) {
                this.bossWrapAlpha = alpha;
                this.bossX = x;
                this.bossY = y;
                this.bossR = r;
            }

            update(frequencyData, intensity) {
                if (!frequencyData || frequencyData.length === 0) return;

                const bands = 32;
                const step = Math.max(1, Math.floor(frequencyData.length / bands));
                let midBandEnergy = 0;
                let bassEnergy = 0;
                let trebleEnergy = 0;

                for (let i = 0; i < bands; i++) {
                    const start = i * step;
                    const end = Math.min(frequencyData.length, (i + 1) * step);
                    let sum = 0;
                    for (let j = start; j < end; j++) {
                        sum += frequencyData[j];
                    }
                    const count = end - start || 1;
                    const avg = (sum / count) / 255;
                    this.frequencies[i] += (avg - this.frequencies[i]) * 0.15;
                    
                    if (i < 5) bassEnergy += avg;
                    if (i >= 8 && i <= 18) midBandEnergy += avg;
                    if (i > 20) trebleEnergy += avg;
                }

                this.bassLevel = bassEnergy / 5;
                this.midLevel = midBandEnergy / 11;
                this.trebleLevel = trebleEnergy / 12;

                const clampedIntensity = Math.max(0, Math.min(1, intensity || 0));
                const zoomPulse = (this.bassLevel * 0.15) + (clampedIntensity * 0.2);
                const densityFactor = 1 - zoomPulse; 
                this.currentSquareSize = this.baseSquareSize * (0.8 + densityFactor * 0.2);

                this.offsetY = 0;
            }

            render(ctx, scale = 1.0) {
                if (!this.frequencies) return;
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                
                const invScale = 1 / Math.max(0.1, scale);
                const renderW = this.width * invScale;
                const renderH = this.height * invScale;
                const offsetX = (this.width - renderW) / 2;
                const offsetY = (this.height - renderH) / 2;
                
                const startCol = Math.floor(offsetX / this.currentSquareSize) - 2;
                const startRow = Math.floor(offsetY / this.currentSquareSize) - 2;
                const cols = Math.ceil(renderW / this.currentSquareSize) + 4;
                const rows = Math.ceil(renderH / this.currentSquareSize) + 4;

                // ULTRA MODE: Synthwave/Neon City Vibe
                if (graphicsLevel === 'ULTRA') {
                    // Draw a subtle horizon glow at the bottom
                    const grad = ctx.createLinearGradient(0, this.height * 0.5, 0, this.height);
                    grad.addColorStop(0, 'rgba(20, 0, 40, 0)');
                    grad.addColorStop(1, 'rgba(80, 0, 120, 0.3)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, this.width, this.height);
                }

                for (let r = 0; r < rows; r++) {
                    const row = startRow + r;
                    for (let c = 0; c < cols; c++) {
                        const col = startCol + c;
                        
                        const x = col * this.currentSquareSize;
                        const y = row * this.currentSquareSize + this.offsetY;
                        const screenX = (x + offsetX) / Math.max(1, this.width);
                        
                        // Mask out the "right stripe" by attenuating intensity on the right half
                        const rightMask = screenX > 0.65 ? 0 : 1;

                        const freqIndex = (col + 100000) % 32;
                        const rawIntensity = this.frequencies[freqIndex] || 0;
                        const freqIntensity = rawIntensity * rightMask;

                        const colorIndex = Math.floor((freqIndex / 32) * this.neonColors.length) % this.neonColors.length;
                        const neonColor = this.neonColors[colorIndex];

                        const globalIntensity = Math.max(0, Math.min(1, (freqIntensity || 0)));
                        const opacity = Math.min(freqIntensity * 0.8 + globalIntensity * 0.4, 1.0);

                        const isBlack = (Math.abs(col) + Math.abs(row)) % 2 === 0;
                        const baseAlpha = 0.4 + globalIntensity * 0.5;

                        // Background squares
                        ctx.fillStyle = isBlack
                            ? `rgba(10, 10, 10, ${baseAlpha})`
                            : `rgba(20, 20, 20, ${baseAlpha})`;
                        ctx.fillRect(x, y, this.currentSquareSize + 1, this.currentSquareSize + 1);

                        let finalOpacity = opacity;
                        if (this.bossWrapAlpha > 0 && this.bossR > 0) {
                            const dx = (x + this.currentSquareSize/2) - this.bossX;
                            const dy = (y + this.currentSquareSize/2) - this.bossY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const wrapRadius = this.bossR * 2;
                            if (dist < wrapRadius) {
                                const wrapFactor = 1 - (dist / wrapRadius);
                                finalOpacity = opacity * (1 - this.bossWrapAlpha) + (opacity * this.bossWrapAlpha * wrapFactor * 2);
                            } else {
                                finalOpacity = opacity * (1 - this.bossWrapAlpha * 0.5);
                            }
                        }

                        // Colored squares fill (MEDIUM/HIGH/ULTRA)
                        if (graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM' || graphicsLevel === 'ULTRA') {
                            ctx.globalAlpha = finalOpacity;
                            ctx.fillStyle = neonColor;
                            
                            // In ULTRA, add a glow to active squares
                            if (graphicsLevel === 'ULTRA' && finalOpacity > 0.2) {
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = neonColor;
                            }
                            
                            ctx.fillRect(x, y, this.currentSquareSize, this.currentSquareSize);
                            ctx.shadowBlur = 0;
                            ctx.globalAlpha = 1;
                        }

                        // Grid lines (HIGH/ULTRA)
                        if (graphicsLevel === 'HIGH' || graphicsLevel === 'ULTRA') {
                            const lineAlpha = finalOpacity * (0.2 + globalIntensity * 0.4);
                            let rL = 255, gL = 255, bL = 255;
                            let lineWidth = 0.5 + (globalIntensity * 0.5);

                            if (this.bassLevel > 0.3) {
                                rL = 255; gL = 100; bL = 150; 
                            } else if (this.trebleLevel > 0.3) {
                                rL = 100; gL = 255; bL = 255; 
                            }
                            
                            if (graphicsLevel === 'ULTRA') {
                                // Brighter, thicker lines in Ultra
                                lineWidth *= 1.5;
                                ctx.shadowBlur = 4;
                                ctx.shadowColor = `rgb(${rL},${gL},${bL})`;
                            }

                            ctx.strokeStyle = `rgba(${rL}, ${gL}, ${bL}, ${lineAlpha})`;
                            ctx.lineWidth = lineWidth;
                            ctx.strokeRect(x, y, this.currentSquareSize, this.currentSquareSize);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
        }

        // Visualizer layout manager
        let VISUAL_LAYOUT = 'checker';
        function createVisualizer(width, height) {
            return new CheckerboardVisualizer(width, height);
        }

        function pickRandomLayout() {
            VISUAL_LAYOUT = 'checker';
        }

        const checkCircleCollision = (c1, c2) => {
            const dx = c1.x - c2.x;
            const dy = c1.y - c2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < (c1.r + c2.r);
        };

        const PLAYER_SKINS = [
            { id: 'orb', name: 'The Orb', unlockLevel: 1, draw: (ctx, x, y, r, c1, c2) => {
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
                ctx.fill();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(x, y, r * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = c2;
                ctx.fill();
            }},
            { id: 'cube', name: 'The Box', unlockLevel: 5, draw: (ctx, x, y, r, c1, c2) => {
                const s = r * 1.6;
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.rect(-s/2, -s/2, s, s);
                ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                ctx.fill();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.rect(-s/4, -s/4, s/2, s/2);
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'viper', name: 'Viper', unlockLevel: 10, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.moveTo(0, -r * 1.2);
                ctx.lineTo(r, r);
                ctx.lineTo(0, r * 0.5);
                ctx.lineTo(-r, r);
                ctx.closePath();
                ctx.fillStyle = `rgba(255, 255, 255, 0.15)`;
                ctx.fill();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, -r * 0.4);
                ctx.lineTo(r * 0.3, r * 0.4);
                ctx.lineTo(-r * 0.3, r * 0.4);
                ctx.closePath();
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'core', name: 'Core', unlockLevel: 15, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.moveTo(0, -r * 1.3);
                ctx.lineTo(r * 1.3, 0);
                ctx.lineTo(0, r * 1.3);
                ctx.lineTo(-r * 1.3, 0);
                ctx.closePath();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, -r * 0.6);
                ctx.lineTo(r * 0.6, 0);
                ctx.lineTo(0, r * 0.6);
                ctx.lineTo(-r * 0.6, 0);
                ctx.closePath();
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'guardian', name: 'Guardian', unlockLevel: 20, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                    const px = Math.cos(angle) * r * 1.2;
                    const py = Math.sin(angle) * r * 1.2;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'hex', name: 'The Hex', unlockLevel: 25, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    const px = Math.cos(angle) * r * 1.1;
                    const py = Math.sin(angle) * r * 1.1;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    const px = Math.cos(angle) * r * 0.5;
                    const py = Math.sin(angle) * r * 0.5;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'nova', name: 'Nova', unlockLevel: 30, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                for(let i=0; i<8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    const rad = i % 2 === 0 ? r * 1.4 : r * 0.6;
                    const px = Math.cos(angle) * rad;
                    const py = Math.sin(angle) * rad;
                    if(i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'ninja', name: 'Shuriken', unlockLevel: 35, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                // Rotate slowly based on time if possible, otherwise static
                const time = performance.now() / 200;
                ctx.rotate(time); 
                
                ctx.beginPath();
                for(let i=0; i<4; i++) {
                    const angle = (Math.PI * 2 / 4) * i;
                    const nextAngle = (Math.PI * 2 / 4) * (i + 1);
                    const px = Math.cos(angle) * r * 0.4;
                    const py = Math.sin(angle) * r * 0.4;
                    const tipX = Math.cos(angle + 0.5) * r * 1.5;
                    const tipY = Math.sin(angle + 0.5) * r * 1.5;
                    
                    if (i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                    ctx.lineTo(tipX, tipY);
                }
                ctx.closePath();
                ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                ctx.fill();
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = c2;
                ctx.fill();
                
                ctx.rotate(-time);
                ctx.translate(-x, -y);
            }},
            { id: 'cross', name: 'The X', unlockLevel: 40, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                ctx.beginPath();
                const w = r * 0.4;
                const l = r * 1.3;
                
                ctx.moveTo(-w, -l); ctx.lineTo(w, -l);
                ctx.lineTo(w, -w); ctx.lineTo(l, -w);
                ctx.lineTo(l, w); ctx.lineTo(w, w);
                ctx.lineTo(w, l); ctx.lineTo(-w, l);
                ctx.lineTo(-w, w); ctx.lineTo(-l, w);
                ctx.lineTo(-l, -w); ctx.lineTo(-w, -w);
                ctx.closePath();
                
                ctx.strokeStyle = c1;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.rect(-w/2, -w/2, w, w);
                ctx.fillStyle = c2;
                ctx.fill();
                ctx.translate(-x, -y);
            }},
            { id: 'glitch', name: 'System Err', unlockLevel: 50, draw: (ctx, x, y, r, c1, c2) => {
                ctx.translate(x, y);
                // Jitter effect
                const jx = (Math.random() - 0.5) * 4;
                const jy = (Math.random() - 0.5) * 4;
                
                ctx.beginPath();
                ctx.rect(-r + jx, -r + jy, r*2, r*2);
                ctx.strokeStyle = c1;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.rect(-r*0.6 - jx, -r*0.6 - jy, r*1.2, r*1.2);
                ctx.strokeStyle = c2;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = c2;
                ctx.fillRect(-2, -2, 4, 4);
                
                ctx.translate(-x, -y);
            }}
        ];

        class Player {
            constructor(canvas) {
                this.x = canvas.width / 2;
                this.y = canvas.height * 0.8;
                this.r = 3;
                this.visualR = 15;
                this.speed = 0;
                this.maxHealth = 150;
                this.health = this.maxHealth;
                this.invulnerable = 0;
                this.color = '#fff';

                this.level = 1;
                // Renamed from skins to colorThemes to avoid confusion with geometry skins
                this.colorThemes = [
                    { ringColor: '#ffffff', coreColor: '#ff0055', glow: 'rgba(255,255,255,0.5)' },
                    { ringColor: '#00ffff', coreColor: '#ff0055', glow: 'rgba(0,255,255,0.6)' },
                    { ringColor: '#ff9900', coreColor: '#00ffff', glow: 'rgba(255,153,0,0.7)' },
                    { ringColor: '#ff00ff', coreColor: '#00ff41', glow: 'rgba(255,0,255,0.8)' },
                    { ringColor: '#ffff00', coreColor: '#ff00ff', glow: 'rgba(255,255,0,0.9)' }
                ];
                
                this.currentSkinId = 'orb'; // Default skin

                this.trail = [];
                this.maxTrailLength = 4;
                
                // Death animation properties
                this.isDying = false;
                this.deathProgress = 0;
                this.cracks = [];
                
                // Graze tracking
                this.lastGrazeTime = 0;

                // Rotation tracking for directional skins
                this.facingAngle = 0;
                this.lastX = this.x;
                this.lastY = this.y;
            }

            setLevel(level) {
                this.level = level;
            }

            setSkin(skinId) {
                this.currentSkinId = skinId;
            }

            update(mouseX, mouseY, canvasScale = 1, gamepadX = 0, gamepadY = 0) {
                if (this.isDying) return;
                
                // Player speed increases with level and combo boost
                const speedBonus = 1 + (this.level - 1) * 0.05;
                const comboBoost = (typeof game !== 'undefined' && game.comboSpeedBoost) ? game.comboSpeedBoost : 1;
                const followSpeed = Math.min(0.2 * speedBonus * comboBoost, 0.7);
                
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Scale mouse coordinates to match canvas resolution
                const scaledMouseX = mouseX;
                const scaledMouseY = mouseY;
                
                // Store old position for rotation calculation
                this.lastX = this.x;
                this.lastY = this.y;
                
                // Gamepad input (direct velocity-based movement)
                if (Math.abs(gamepadX) > 0.01 || Math.abs(gamepadY) > 0.01) {
                    const gamepadSpeed = 6 * speedBonus * comboBoost;
                    this.x += gamepadX * gamepadSpeed;
                    this.y += gamepadY * gamepadSpeed;
                    
                    // Clamp to canvas bounds
                    this.x = Math.max(this.visualR, Math.min(game.width - this.visualR, this.x));
                    this.y = Math.max(this.visualR, Math.min(game.height - this.visualR, this.y));
                } else {
                    // Mouse/touch input (smooth follow)
                    this.x += (scaledMouseX - this.x) * followSpeed;
                    this.y += (scaledMouseY - this.y) * followSpeed;
                }

                // Calculate facing angle based on movement direction
                const dx = this.x - this.lastX;
                const dy = this.y - this.lastY;
                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    this.facingAngle = Math.atan2(dy, dx);
                }

                if (this.invulnerable > 0) this.invulnerable--;
            }

            initDeathAnimation() {
                this.isDying = true;
                this.deathProgress = 0;
                this.cracks = [];
                
                // Generate random cracks
                const numCracks = 8;
                for (let i = 0; i < numCracks; i++) {
                    const angle = (Math.PI * 2 / numCracks) * i + (Math.random() - 0.5) * 0.5;
                    this.cracks.push({
                        angle: angle,
                        length: this.visualR * (0.8 + Math.random() * 0.4)
                    });
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                const themeIndex = Math.min(this.colorThemes.length - 1, Math.max(0, this.level - 1));
                const theme = this.colorThemes[themeIndex];

                // Desktop-only: enhanced player trail (only on HIGH graphics)
                if (!IS_MOBILE && graphicsLevel === 'HIGH' && this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const pos = this.trail[i];
                        const alpha = (i / this.trail.length) * 0.3;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, this.visualR * 0.8, 0, Math.PI * 2);
                        ctx.fillStyle = theme.ringColor;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = theme.ringColor;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    ctx.globalAlpha = 1;
                }

                if (this.isDying) {
                    // Death animation - cracking and shattering
                    const crackProgress = Math.min(this.deathProgress / 0.5, 1); // First half of animation
                    const shatterProgress = Math.max(0, (this.deathProgress - 0.5) / 0.5); // Second half
                    
                    // Draw cracks
                    if (crackProgress > 0) {
                        ctx.strokeStyle = '#ff0055';
                        ctx.lineWidth = 2;
                        if (graphicsLevel === 'HIGH') {
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#ff0055';
                        }
                        
                        for (const crack of this.cracks) {
                            const currentLength = crack.length * crackProgress;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            const endX = this.x + Math.cos(crack.angle) * currentLength;
                            const endY = this.y + Math.sin(crack.angle) * currentLength;
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                    }
                    
                    // Shatter - fragments flying outward
                    if (shatterProgress > 0) {
                        for (let i = 0; i < this.cracks.length; i++) {
                            const crack = this.cracks[i];
                            const distance = shatterProgress * 100;
                            const fragX = this.x + Math.cos(crack.angle) * distance;
                            const fragY = this.y + Math.sin(crack.angle) * distance;
                            const fragSize = this.visualR * 0.3 * (1 - shatterProgress);
                            const alpha = 1 - shatterProgress;
                            
                            ctx.globalAlpha = alpha;
                            ctx.fillStyle = theme.ringColor;
                            if (graphicsLevel === 'HIGH') {
                                ctx.shadowBlur = 8;
                                ctx.shadowColor = theme.ringColor;
                            }
                            ctx.beginPath();
                            ctx.arc(fragX, fragY, fragSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            ctx.globalAlpha = 1;
                        }
                    } else {
                        // Draw main body during crack phase - use standard orb for death shell
                        const opacity = 1 - crackProgress * 0.3;
                        ctx.globalAlpha = opacity;
                        if (graphicsLevel === 'HIGH') {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = theme.ringColor;
                        }
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.visualR, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
                        ctx.fill();
                        ctx.strokeStyle = theme.ringColor;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    
                    return;
                }

                // Draw simplified motion trail (only on MEDIUM and HIGH)
                if ((graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM') && this.trail.length > 1) {
                    const lastPos = this.trail[this.trail.length - 1];
                    ctx.beginPath();
                    ctx.arc(lastPos.x, lastPos.y, this.visualR * 0.7, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                    ctx.fill();
                }

                // Simplified player glow (only on HIGH and MEDIUM)
                if (graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = theme.ringColor;
                }
                
                // Draw custom skin geometry
                const skinDef = PLAYER_SKINS.find(s => s.id === this.currentSkinId) || PLAYER_SKINS[0];
                
                // Apply invulnerability flicker
                if (this.invulnerable > 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // For directional skins, pass the facing angle
                const needsRotation = ['viper', 'ninja', 'nova'].includes(this.currentSkinId);
                if (needsRotation) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    // Offset rotation so "up" (the pointy tip) faces the movement direction
                    ctx.rotate(this.facingAngle + Math.PI / 2);
                    skinDef.draw(ctx, 0, 0, this.visualR, theme.ringColor, theme.coreColor);
                    ctx.restore();
                } else {
                    skinDef.draw(ctx, this.x, this.y, this.visualR, theme.ringColor, theme.coreColor);
                }
                
                if (this.invulnerable > 0) {
                    ctx.globalAlpha = 1;
                }

                ctx.shadowBlur = 0;
            }

            hit(amount) {
                if (this.invulnerable > 0) return;
                
                // Default to smaller damage (1/6 of max) when amount not provided
                const damage = typeof amount === 'number' ? amount : (this.maxHealth / 6);
                this.health -= damage;
                
                // Shorter invulnerability at higher levels (roughly ~0.5s)
                // Very short post-hit invincibility (~0.2s at 60fps)
                const invulnFrames = 12;
                this.invulnerable = invulnFrames;
                
                game.triggerShake(10);
                game.registerDamage();
                game.updateHealth();
                game.showHitFlash();

                // Mobile vibration feedback for hit (rate-limited)
                try {
                    if (typeof IS_MOBILE !== 'undefined' && IS_MOBILE && navigator.vibrate) {
                        const now = performance.now();
                        if (!this._lastHitVibe || now - this._lastHitVibe > 120) {
                            navigator.vibrate(30);
                            this._lastHitVibe = now;
                        }
                    }
                } catch (e) {}

                // Desktop-only: spawn hit particles
                if (!IS_MOBILE && game.particleSystem) {
                    for (let i = 0; i < 8; i++) {
                        game.particleSystem.addParticle(
                            this.x,
                            this.y,
                            'rgb(255, 0, 85)',
                            3,
                            0.8
                        );
                    }
                }
            }
        }

        class Shard {
            constructor(x, y, angle, speed) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.r = 4.5;
                this.active = true;
                this.trail = [];
            }

            update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 3) this.trail.shift();
                
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -50 || this.x > game.width + 50 || this.y < -50 || this.y > game.height + 50) {
                    this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                
                // Neon shard with inner core + faint trail
                ctx.save();
                ctx.translate(this.x, this.y);
                const angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);

                // Trail (HIGH / MEDIUM / ULTRA)
                if (graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM' || graphicsLevel === 'ULTRA') {
                    ctx.globalAlpha = graphicsLevel === 'ULTRA' ? 0.5 : 0.35;
                    const trailGrad = ctx.createLinearGradient(-20, 0, 4, 0);
                    trailGrad.addColorStop(0, 'rgba(168,85,247,0)');
                    trailGrad.addColorStop(1, 'rgba(236,72,153,0.9)');
                    ctx.fillStyle = trailGrad;
                    ctx.beginPath();
                    ctx.moveTo(-20, -2);
                    ctx.lineTo(4, -2);
                    ctx.lineTo(4, 2);
                    ctx.lineTo(-20, 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Outer body
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                const bodyGrad = ctx.createLinearGradient(-4, 0, 8, 0);
                bodyGrad.addColorStop(0, '#ec4899');
                bodyGrad.addColorStop(1, '#a855f7');
                ctx.fillStyle = bodyGrad;
                
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 14;
                    ctx.shadowColor = '#f472b6';
                } else if (graphicsLevel === 'ULTRA') {
                    // Massive bloom in Ultra
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#d946ef';
                }
                ctx.fill();

                // Core line
                ctx.shadowBlur = 0;
                ctx.strokeStyle = graphicsLevel === 'ULTRA' ? '#ffffff' : 'rgba(248,250,252,0.9)';
                ctx.lineWidth = graphicsLevel === 'ULTRA' ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(-2, 0);
                ctx.lineTo(6, 0);
                ctx.stroke();

                // Double glow ring for Ultra
                if (graphicsLevel === 'ULTRA') {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    ctx.arc(0,0, 6, 0, Math.PI*2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Spiral {
            constructor() {
                const side = Math.floor(Math.random() * 4);
                const w = game.width;
                const h = game.height;

                if (side === 0) { // top
                    this.x = Math.random() * w;
                    this.y = -20;
                } else if (side === 1) { // right
                    this.x = w + 20;
                    this.y = Math.random() * h;
                } else if (side === 2) { // bottom
                    this.x = Math.random() * w;
                    this.y = h + 20;
                } else { // left
                    this.x = -20;
                    this.y = Math.random() * h;
                }

                this.targetX = game.player.x;
                this.targetY = game.player.y;
                this.speed = 1.5 * getSpeedFactor();
                this.angle = 0;
                this.spiralRadius = 0;
                this.maxSpiralRadius = 60;
                this.r = 6;
                this.active = true;
                this.life = 0;
                this.trail = [];
                this.hasReachedTarget = false;
                
                // Calculate direction to move past target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.moveAngle = Math.atan2(dy, dx);
            }

            update() {
                this.life++;
                
                // Spiral outward for first 60 frames
                if (this.life < 60) {
                    this.spiralRadius = (this.life / 60) * this.maxSpiralRadius;
                }
                
                // Move in the direction of the initial target, but keep going
                this.x += Math.cos(this.moveAngle) * this.speed;
                this.y += Math.sin(this.moveAngle) * this.speed;
                
                // Apply spiral motion - slow the orbital rotation on mobile so orbs don't feel too fast on phones
                // Use a smaller mobile spin scale and slightly reduced per-frame increment for smoother, slower orbits on phones
                const mobileSpinScale = (typeof IS_MOBILE !== 'undefined' && IS_MOBILE) ? 0.25 : 1;
                this.angle += 0.035 * mobileSpinScale;
                const spiralX = Math.cos(this.angle) * this.spiralRadius;
                const spiralY = Math.sin(this.angle) * this.spiralRadius;
                
                const finalX = this.x + spiralX;
                const finalY = this.y + spiralY;
                
                this.trail.push({ x: finalX, y: finalY });
                if (this.trail.length > 4) this.trail.shift();
                
                // Deactivate if far off-screen
                if (this.x < -200 || this.x > game.width + 200 || this.y < -200 || this.y > game.height + 200) {
                    this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                const finalX = this.x + Math.cos(this.angle) * this.spiralRadius;
                const finalY = this.y + Math.sin(this.angle) * this.spiralRadius;
                
                // Neon pulse orb
                const outerR = this.r + 3;
                ctx.save();
                
                // Glow (HIGH / MEDIUM / ULTRA)
                if (graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM' || graphicsLevel === 'ULTRA') {
                    ctx.beginPath();
                    ctx.arc(finalX, finalY, outerR * (graphicsLevel === 'ULTRA' ? 1.5 : 1.0), 0, Math.PI * 2);
                    const glowGrad = ctx.createRadialGradient(
                        finalX, finalY, 0,
                        finalX, finalY, outerR * (graphicsLevel === 'ULTRA' ? 1.5 : 1.0)
                    );
                    glowGrad.addColorStop(0, graphicsLevel === 'ULTRA' ? 'rgba(255, 255, 100, 0.4)' : 'rgba(252,211,77,0.2)');
                    glowGrad.addColorStop(1, 'rgba(251,191,36,0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.arc(finalX, finalY, this.r, 0, Math.PI * 2);
                ctx.fillStyle = '#fde047';
                
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 16;
                    ctx.shadowColor = '#facc15';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffff00';
                }
                ctx.fill();

                // Center detail
                ctx.beginPath();
                ctx.arc(finalX, finalY, this.r * 0.45, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();

                // Ultra extra ring
                if (graphicsLevel === 'ULTRA') {
                    ctx.beginPath();
                    ctx.arc(finalX, finalY, this.r + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
                ctx.restore();
            }

            checkCollision(player) {
                const finalX = this.x + Math.cos(this.angle) * this.spiralRadius;
                const finalY = this.y + Math.sin(this.angle) * this.spiralRadius;
                const graceRadius = (typeof game !== 'undefined' && game.comboGraceRadius) ? game.comboGraceRadius : 0;
                return checkCircleCollision(
                    { x: finalX, y: finalY, r: this.r },
                    { x: player.x, y: player.y, r: player.r + graceRadius }
                );
            }
        }

        class Line {
            constructor() {
                this.p1 = this.randomEdgePoint();
                this.p2 = this.randomEdgePoint();
                
                while (Math.abs(this.p1.x - this.p2.x) < 100 && Math.abs(this.p1.y - this.p2.y) < 100) {
                    this.p2 = this.randomEdgePoint();
                }

                this.life = 0;
                this.warnTime = 40;
                this.activeTime = 15;
                this.width = 0;
                this.active = true;
                this.isLethal = false;
            }

            randomEdgePoint() {
                const side = Math.floor(Math.random() * 4);
                const w = game.width;
                const h = game.height;
                if(side === 0) return {x: Math.random()*w, y: 0};
                if(side === 1) return {x: w, y: Math.random()*h};
                if(side === 2) return {x: Math.random()*w, y: h};
                return {x: 0, y: Math.random()*h};
            }

            update() {
                this.life++;
                if (this.life < this.warnTime) {
                    this.width = 1;
                } else if (this.life < this.warnTime + this.activeTime) {
                    this.isLethal = true;
                    this.width = 10 + (Math.sin(this.life) * 5);
                } else {
                    this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                
                ctx.beginPath();
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                
                if (this.isLethal) {
                    // Simplified gradient on BASIC
                    if (graphicsLevel === 'BASIC') {
                        ctx.strokeStyle = '#fb7185';
                    } else {
                        const grad = ctx.createLinearGradient(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                        grad.addColorStop(0, graphicsLevel === 'ULTRA' ? '#ff0055' : '#fb7185');
                        grad.addColorStop(0.5, graphicsLevel === 'ULTRA' ? '#ffffff' : '#fb7185'); // Bright core in Ultra
                        grad.addColorStop(1, graphicsLevel === 'ULTRA' ? '#ff0055' : '#f97316');
                        ctx.strokeStyle = grad;
                    }
                    ctx.lineWidth = this.width;
                    if (graphicsLevel === 'HIGH') {
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#fb7185';
                    } else if (graphicsLevel === 'ULTRA') {
                        ctx.shadowBlur = 40;
                        ctx.shadowColor = '#ff0033';
                    }
                } else {
                    ctx.strokeStyle = `rgba(255, 0, 85, 0.5)`;
                    ctx.lineWidth = 1;
                    if (graphicsLevel === 'HIGH') {
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#ff0055';
                    } else if (graphicsLevel === 'ULTRA') {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff0055';
                    }
                    ctx.setLineDash([10, 10]);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;
            }

            checkCollision(player) {
                if (!this.isLethal) return false;
                
                const A = this.p1.x - this.p2.x;
                const B = this.p1.y - this.p2.y;
                const mag = Math.sqrt(A*A + B*B);
                
                const dist = Math.abs((this.p2.y - this.p1.y) * player.x - (this.p2.x - this.p1.x) * player.y + this.p2.x * this.p1.y - this.p2.y * this.p1.x) / mag;
                
                return dist < (this.width/2 + player.r);
            }
        }

        class Bomb {
            constructor() {
                this.x = Math.random() * (game.width - 100) + 50;
                this.y = Math.random() * (game.height - 100) + 50;
                this.timer = 60;
                this.radius = 80;
                this.active = true;
                this.particles = [];
            }

            update() {
                this.timer--;
                if (this.timer <= 0) {
                    this.explode();
                    this.active = false;
                }
            }

            explode() {
                game.triggerShake(15);
                const count = 8;
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i;
                    // Respect getSpeedFactor, but keep bomb shards snappy on mobile so explosions still feel threatening
                    const baseShardSpeed = (typeof IS_MOBILE !== 'undefined' && IS_MOBILE) ? 2.8 : 2.5;
                    const shardSpeed = baseShardSpeed * getSpeedFactor();
                    game.shards.push(new Shard(this.x, this.y, angle, shardSpeed));
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                const t = 1 - this.timer / 60;

                // Outer danger ring
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(248,250,252,0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 6]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Pulsing inner ring
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * t, 0, Math.PI * 2);
                const ringGrad = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * t
                );
                ringGrad.addColorStop(0, 'rgba(250,204,21,0.35)');
                ringGrad.addColorStop(1, 'rgba(250,204,21,0)');
                ctx.fillStyle = ringGrad;
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#facc15';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#ffaa00';
                }
                ctx.fill();
                
                // Shockwave ring for Ultra
                if (graphicsLevel === 'ULTRA') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * t * 0.8, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Core
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = graphicsLevel === 'ULTRA' ? '#ffffff' : '#f97316';
                if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0000';
                }
                ctx.fill();

                ctx.restore();
            }
        }

        // --- CUSTOM SONG BOSSES (for non-career tracks) ---
        // Shogun: REDESIGNED - High opacity, solid structure, neon accents
        class ShogunBoss {
            constructor(game) {
                this.game = game;
                this.x = game.width / 2;
                this.y = game.height * 0.25;
                this.r = 50;
                this.state = 'intro';
                this.alpha = 0;
                this.coreRotation = 0;
                this.chargeTimer = 0;
                this.superTimer = 0;
                this.superCooldown = 9;
                this.magnetTimer = 0;
                this.currentDash = null;
                this.trailPositions = [];
                this.targetX = 0;
                this.targetY = 0;
                this.pulse = 0;
                this.moveStart = {x:0, y:0};
            }

            update(dt) {
                const g = this.game;
                const player = g.player;

                this.coreRotation += dt * 3;
                this.pulse += dt * 5;
                
                if (this.state === 'intro') {
                    this.alpha = Math.min(1, this.alpha + dt * 2);
                } else if (this.state === 'hidden') {
                    this.alpha = Math.max(0, this.alpha - dt * 3);
                } else {
                    this.alpha = 1;
                }

                this.chargeTimer += dt;
                this.superTimer += dt;
                this.magnetTimer += dt;

                if (this.magnetTimer > 3.0 && this.state !== 'hidden' && this.state !== 'intro') {
                    this.magnetTimer = 0;
                    if (g.shards) {
                        let grabbed = 0;
                        for (let s of g.shards) {
                            const dx = s.x - this.x;
                            const dy = s.y - this.y;
                            if (Math.sqrt(dx*dx + dy*dy) < 350) {
                                const angle = Math.atan2(player.y - s.y, player.x - s.x);
                                const speed = 14 * getSpeedFactor();
                                s.vx = Math.cos(angle) * speed;
                                s.vy = Math.sin(angle) * speed;
                                s.active = true;
                                grabbed++;
                                if (grabbed >= 10) break;
                            }
                        }
                        if (grabbed > 0 && !IS_MOBILE && g.particleSystem) {
                             for(let i=0; i<8; i++) {
                                 g.particleSystem.addParticle(this.x, this.y, 'rgb(255, 255, 0)', 4, 0.5);
                             }
                        }
                    }
                }

                if (this.state === 'intro') {
                    this.y += dt * 140;
                    if (this.y >= this.game.height * 0.25) {
                        this.y = this.game.height * 0.25;
                        this.state = 'idle';
                    }
                } else if (this.state === 'idle') {
                    if (this.superTimer >= this.superCooldown) {
                        // Phase 1: Move to SIDE edge aligned with player
                        this.state = 'superMove';
                        this.chargeTimer = 0;
                        
                        // Pick random axis: 0 = Horz (Left/Right), 1 = Vert (Top/Bottom)
                        const axis = Math.random() < 0.5 ? 0 : 1;
                        if (axis === 0) {
                            // Horizontal dash: Go to Left/Right edge, align Y with player
                            this.targetX = (player.x < this.game.width / 2) ? this.game.width + 100 : -100;
                            this.targetY = player.y;
                        } else {
                            // Vertical dash: Go to Top/Bottom edge, align X with player
                            this.targetX = player.x;
                            this.targetY = (player.y < this.game.height / 2) ? this.game.height + 100 : -100;
                        }
                        this.moveStart = {x: this.x, y: this.y};
                    } else if (this.chargeTimer >= 1.2) {
                        this.state = 'chargePrep';
                        this.chargeTimer = 0;
                        this.targetX = player.x;
                        this.targetY = player.y;
                    }
                } else if (this.state === 'superMove') {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // Move very fast to start position
                    if (dist < 20) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.state = 'superPrep';
                        this.chargeTimer = 0;
                        // Calculate dash destination (opposite side)
                        if (this.x < 0) { // from Left
                            this.targetX = this.game.width + 200; this.targetY = this.y;
                        } else if (this.x > this.game.width) { // from Right
                            this.targetX = -200; this.targetY = this.y;
                        } else if (this.y < 0) { // from Top
                            this.targetX = this.x; this.targetY = this.game.height + 200;
                        } else { // from Bottom
                            this.targetX = this.x; this.targetY = -200;
                        }
                    } else {
                        this.x += (dx / dist) * dt * 1500;
                        this.y += (dy / dist) * dt * 1500;
                    }
                } else if (this.state === 'chargePrep') {
                    this.chargeTimer += dt;
                    if (this.chargeTimer >= 0.4) {
                        this.chargeTimer = 0;
                        this.state = 'chargeDash';
                        const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                        const speed = 16 * getSpeedFactor();
                        this.currentDash = { vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, time: 0, maxTime: 0.7 };
                        this.trailPositions = [];
                    }
                } else if (this.state === 'chargeDash') {
                    if (this.currentDash) {
                        this.trailPositions.push({x: this.x, y: this.y});
                        if (this.trailPositions.length > 20) this.trailPositions.shift();
                        this.x += this.currentDash.vx;
                        this.y += this.currentDash.vy;
                        this.currentDash.time += dt;
                        const dist = Math.hypot(this.x - player.x, this.y - player.y);
                        if (dist < this.r + (player.r || 0)) {
                            if (player && typeof player.hit === 'function') {
                                player.hit(player.maxHealth / 3);
                            }
                        }
                        if (this.currentDash.time >= this.currentDash.maxTime) {
                            this.currentDash = null;
                            this.state = 'idle';
                            this.chargeTimer = 0;
                            this.trailPositions = [];
                        }
                    } else { this.state = 'idle'; }
                } else if (this.state === 'superPrep') {
                    this.chargeTimer += dt;
                    if (this.chargeTimer >= 0.8) {
                        this.state = 'superDash';
                        this.chargeTimer = 0;
                        const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                        const speed = 40 * getSpeedFactor(); // Extremely fast cross-screen
                        this.currentDash = { vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, time: 0, maxTime: 2.0, angle: angle };
                        this.trailPositions = [];
                        g.triggerShake(25);
                    }
                } else if (this.state === 'superDash') {
                    if (this.currentDash) {
                        this.trailPositions.push({x: this.x, y: this.y});
                        if (this.trailPositions.length > 50) this.trailPositions.shift();
                        this.x += this.currentDash.vx;
                        this.y += this.currentDash.vy;
                        this.currentDash.time += dt;
                        
                        if (!IS_MOBILE && g.particleSystem) {
                             g.particleSystem.addParticle(this.x, this.y, 'rgb(255, 200, 0)', 5, 0.8);
                        }

                        // Wide collision box for super dash (it's a wall of death)
                        const dist = Math.hypot(this.x - player.x, this.y - player.y);
                        if (dist < this.r * 2.5) {
                            if (player && typeof player.hit === 'function') {
                                player.hit(player.maxHealth || 9999);
                            } else if (player && typeof player.health === 'number') {
                                player.health = 0;
                            }
                            if (this.game && typeof this.game.updateHealth === 'function') {
                                this.game.updateHealth();
                            }
                            return;
                        }
                        
                        const dToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                        if (dToTarget < 50 || this.x < -200 || this.x > this.game.width + 200 || this.y < -200 || this.y > this.game.height + 200) {
                            this.currentDash = null;
                            this.state = 'idle';
                            this.superTimer = 0;
                            this.trailPositions = [];
                            // Return to center area safely
                            this.x = Math.max(100, Math.min(this.game.width - 100, this.x));
                            this.y = Math.max(100, Math.min(this.game.height * 0.4, this.y));
                        }
                    } else { this.state = 'idle'; }
                }
            }

            draw(ctx) {
                if (this.alpha <= 0.01) return;
                ctx.save();
                ctx.globalAlpha = 1.0; // Enforce full opacity for body
                
                // Trails
                if (this.trailPositions.length > 0) {
                    ctx.strokeStyle = this.state === 'superDash' ? '#ffd700' : '#facc15';
                    ctx.lineWidth = this.state === 'superDash' ? 12 : 8;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#fbbf24';
                    ctx.beginPath();
                    ctx.moveTo(this.trailPositions[0].x, this.trailPositions[0].y);
                    for (let i = 1; i < this.trailPositions.length; i++) {
                        ctx.lineTo(this.trailPositions[i].x, this.trailPositions[i].y);
                    }
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Telegraph
                if (this.state === 'chargePrep' || this.state === 'superPrep') {
                    ctx.save();
                    const intensity = 0.5 + Math.sin(this.pulse * 2) * 0.5;
                    ctx.strokeStyle = this.state === 'superPrep' ? `rgba(255,0,0,${intensity})` : `rgba(255,255,0,${intensity})`;
                    ctx.lineWidth = 4;
                    ctx.setLineDash([15, 10]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.targetX, this.targetY);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.translate(this.x, this.y);
                
                // Solid Main Body (Hexagonal Armor)
                ctx.fillStyle = '#1e1e2e';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const r = this.r;
                    ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
                ctx.closePath();
                ctx.fill();
                
                // Neon Border
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                ctx.strokeStyle = '#facc15'; // Gold
                ctx.lineWidth = 3;
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#facc15';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#ffcc00';
                    ctx.lineWidth = 5;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Inner Detail (Circuitry)
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.r * 0.5, 0); ctx.lineTo(this.r * 0.5, 0);
                ctx.moveTo(0, -this.r * 0.5); ctx.lineTo(0, this.r * 0.5);
                ctx.stroke();

                // Rotating Core
                ctx.save();
                ctx.rotate(this.coreRotation);
                ctx.fillStyle = '#dc2626'; // Red core
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ef4444';
                ctx.beginPath();
                ctx.rect(-12, -12, 24, 24);
                ctx.fill();
                ctx.restore();

                // "Helmet" / Face
                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.moveTo(-20, -25);
                ctx.lineTo(20, -25);
                ctx.lineTo(0, 10);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        // Sentinel: REDESIGNED - High opacity, mechanical eye
        class SentinelBoss {
            constructor(game) {
                this.game = game;
                this.x = game.width / 2;
                this.y = game.height * 0.3;
                this.r = 52;
                this.alpha = 0;
                this.ringAngle = 0;
                this.ringTimer = 0;
                this.laserTimer = 0; // New ability
                this.spinSpeed = 2.5;
                this.pulsePhase = 0;
            }

            update(dt) {
                const g = this.game;
                const p = g.player;
                this.alpha = 1;
                this.x += (p.x - this.x) * dt * 1.5;
                this.pulsePhase += dt * 3;
                this.ringTimer += dt;
                this.laserTimer += dt;
                this.ringAngle += dt * this.spinSpeed;
                
                if (this.ringTimer >= 1.2) {
                    this.ringTimer = 0;
                    const count = 20;
                    for (let i = 0; i < count; i++) {
                        const ang = this.ringAngle + (Math.PI * 2 * i) / count;
                        const sx = this.x + Math.cos(ang) * (this.r + 15);
                        const sy = this.y + Math.sin(ang) * (this.r + 15);
                        const speed = 2.8 * getSpeedFactor();
                        this.game.shards.push(new Shard(sx, sy, ang, speed));
                    }
                }

                // Ability 2: Laser Grid (Scanning Beams)
                if (this.laserTimer >= 4.0) {
                    this.laserTimer = 0;
                    // Spawn horizontal or vertical sweepers
                    if (Math.random() < 0.5) {
                         // Horizontal sweep
                         const s = new Sweeper();
                         s.orientation = 'H';
                         s.y = -100;
                         s.speed = 5 * getSpeedFactor();
                         g.sweepers.push(s);
                    } else {
                         // Vertical line trap (implemented as narrow sweepers or just Lines)
                         // Let's use Line entities for "laser beams"
                         const l = new Line();
                         l.p1 = {x: 0, y: p.y};
                         l.p2 = {x: g.width, y: p.y};
                         l.warnTime = 30; // fast warning
                         l.activeTime = 20; 
                         g.lines.push(l);
                    }
                }
            }

            draw(ctx) {
                if (this.alpha <= 0.01) return;
                ctx.save();
                ctx.globalAlpha = 1.0;
                ctx.translate(this.x, this.y);

                // Main Sphere Body
                ctx.fillStyle = '#0f172a'; // Dark slate
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                ctx.fill();
                
                // Cyan Glow Rim
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 4;
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#06b6d4';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#00ffff';
                    ctx.lineWidth = 6;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Rotating Outer Ring Segments
                ctx.save();
                ctx.rotate(this.ringAngle);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 6;
                for(let i=0; i<4; i++) {
                    ctx.rotate(Math.PI/2);
                    ctx.beginPath();
                    ctx.arc(0, 0, this.r + 8, -0.3, 0.3);
                    ctx.stroke();
                }
                ctx.restore();

                // Central Eye (Iris)
                const eyeSize = 24 + Math.sin(this.pulsePhase) * 4;
                ctx.fillStyle = '#ef4444'; // Red eye
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#f87171';
                ctx.beginPath();
                ctx.arc(0, 0, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupil
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Hydra: REDESIGNED - Solid snake heads, improved visibility
        class HydraBoss {
            constructor(game) {
                this.game = game;
                this.x = game.width / 2;
                this.y = game.height * 0.28;
                this.r = 62;
                this.alpha = 0;
                this.heads = [];
                this.coreRotation = 0;
                this.venomTimer = 0; // New ability
                
                const headCount = 3;
                for (let i = 0; i < headCount; i++) {
                    const baseAngle = (Math.PI * 2 * i) / headCount;
                    this.heads.push({
                        x: 0, y: 0, vx: 0, vy: 0,
                        baseAngle: baseAngle,
                        attackType: i,
                        attackTimer: Math.random() * 2,
                        neckSegments: []
                    });
                }
            }

            update(dt) {
                const g = this.game;
                const p = g.player;
                this.alpha = 1;
                this.x += Math.cos(performance.now() / 1200) * dt * 70;
                this.y = this.game.height * 0.28 + Math.sin(performance.now() / 1500) * 8;
                this.coreRotation += dt * 0.5;
                this.venomTimer += dt;

                // Ability: Venom Volley - Every 6s, all heads fire a shotgun spread
                if (this.venomTimer >= 6.0) {
                    this.venomTimer = 0;
                    for (const head of this.heads) {
                        const worldX = this.x + head.x;
                        const worldY = this.y + head.y;
                        const angleToPlayer = Math.atan2(p.y - worldY, p.x - worldX);
                        for(let k=0; k<5; k++) {
                            const spread = (k - 2) * 0.2;
                            const speed = (4 + Math.random() * 2) * getSpeedFactor();
                            g.shards.push(new Shard(worldX, worldY, angleToPlayer + spread, speed));
                        }
                    }
                }

                for (let i = 0; i < this.heads.length; i++) {
                    const head = this.heads[i];
                    const orbitRadius = this.r * 2.0;
                    const targetAngle = head.baseAngle + Math.sin(performance.now() / 1000 + i) * 0.4;
                    const targetX = Math.cos(targetAngle) * orbitRadius;
                    const targetY = Math.sin(targetAngle) * orbitRadius;
                    
                    const dx = targetX - head.x;
                    const dy = targetY - head.y;
                    head.vx += dx * 9 * dt;
                    head.vy += dy * 9 * dt;
                    head.vx *= 0.86;
                    head.vy *= 0.86;
                    head.x += head.vx * dt * 60;
                    head.y += head.vy * dt * 60;
                    
                    head.attackTimer += dt;
                    if (head.attackTimer >= 2.5) {
                        head.attackTimer = 0;
                        const worldX = this.x + head.x;
                        const worldY = this.y + head.y;
                        if (head.attackType === 0) {
                            for (let j = 0; j < 2; j++) {
                                const angle = Math.atan2(p.y - worldY, p.x - worldX) + (j - 0.5) * 0.3;
                                const speed = 3.2 * getSpeedFactor();
                                g.shards.push(new Shard(worldX, worldY, angle, speed));
                            }
                        } else if (head.attackType === 1) {
                            const rocket = new Rocket();
                            rocket.x = worldX; rocket.y = worldY;
                            g.rockets.push(rocket);
                        } else {
                            const spiral = new Spiral();
                            spiral.x = worldX; spiral.y = worldY;
                            spiral.moveAngle = Math.atan2(p.y - worldY, p.x - worldX);
                            g.spirals.push(spiral);
                        }
                    }
                    
                    const segmentCount = 6;
                    head.neckSegments = [];
                    for (let s = 0; s <= segmentCount; s++) {
                        const t = s / segmentCount;
                        head.neckSegments.push({x: head.x * t, y: head.y * t});
                    }
                }
            }

            draw(ctx) {
                if (this.alpha <= 0.01) return;
                ctx.save();
                ctx.globalAlpha = 1.0;
                ctx.translate(this.x, this.y);

                // Draw Necks
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 14;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                for (const head of this.heads) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    for (const seg of head.neckSegments) ctx.lineTo(seg.x, seg.y);
                    ctx.stroke();
                    
                    // Inner cable
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#94a3b8';
                    ctx.stroke();
                    ctx.lineWidth = 14;
                    ctx.strokeStyle = '#334155';
                }

                // Main Body
                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                ctx.fill();
                
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 3;
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#22d3ee';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#00ffff';
                    ctx.lineWidth = 5;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Central Reactor
                ctx.fillStyle = '#06b6d4';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();

                // Draw Heads
                for (const head of this.heads) {
                    ctx.save();
                    ctx.translate(head.x, head.y);
                    
                    let color = (head.attackType === 0) ? '#a855f7' : (head.attackType === 1 ? '#f97316' : '#facc15');
                    
                    // Head shape
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath();
                    ctx.arc(0, 0, 22, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = color;
                    ctx.stroke();
                    
                    // Eyes
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(-8, -5, 5, 0, Math.PI * 2);
                    ctx.arc(8, -5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }

                ctx.restore();
            }
        }

        // Manages detection of intense sections and spawning bosses dynamically
        class CustomBossManager {
            constructor(game) {
                this.game = game;
                this.activeBoss = null;
                this.intenseTime = 0;
                this.chillTime = 0;
            }

            reset() {
                this.activeBoss = null;
                this.intenseTime = 0;
                this.chillTime = 0;
            }

            pickBossType() {
                const roll = Math.random();
                if (roll < 0.34) return 'shogun';
                if (roll < 0.67) return 'sentinel';
                return 'hydra';
            }

            generateBossName(type) {
                // Base name on song title
                let name = "UNKNOWN";
                if (this.game.currentSongTitle) {
                    // Strip "Category: " prefix
                    let clean = this.game.currentSongTitle.split(': ').pop() || "";
                    // Remove extension
                    clean = clean.replace(/\.[^/.]+$/, "");
                    
                    // Stop words to remove
                    const stopWords = ['the', 'a', 'an', 'of', 'in', 'on', 'at', 'to', 'for', 'with', 'by', 'my', 'is', 'are', 'mix', 'remix', 'feat', 'ft', 'original', 'edit'];
                    const words = clean.split(/[\s\-_]+/).filter(w => w.length > 2 && !stopWords.includes(w.toLowerCase()));
                    
                    if (words.length > 0) {
                        // Take up to 2 distinct words
                        name = words.slice(0, 2).join(' ').toUpperCase();
                    }
                }
                
                // Append suffix based on type
                if (type === 'shogun') return `${name} PRIME`;
                if (type === 'sentinel') return `${name} SYSTEM`;
                return `${name} CORE`;
            }

            spawnBoss(forceType = null) {
                const type = forceType || this.pickBossType();

                if (type === 'shogun') {
                    this.activeBoss = new ShogunBoss(this.game);
                } else if (type === 'sentinel') {
                    this.activeBoss = new SentinelBoss(this.game);
                } else {
                    this.activeBoss = new HydraBoss(this.game);
                }
                
                const name = this.generateBossName(type);
                if (typeof this.game.showBossName === 'function') this.game.showBossName(name);
                
                // Start intro
                if (this.activeBoss.setState) this.activeBoss.setState('intro');
                
                this.chillTime = 0;
            }

            update(dt, audio) {
                const g = this.game;
                if (!audio || !audio.audioBuffer) return;

                const volume = audio.volume || 0;
                const bass = audio.bass || 0;

                // Detection: loud and bassy
                const intense = (volume > 0.78 || bass > 0.68);

                if (this.activeBoss) {
                    this.activeBoss.update(dt);

                    // If intensity drops, accumulate chill time
                    if (!intense) {
                        this.chillTime += dt;
                        // Despawn after ~7 seconds of calm
                        if (this.chillTime > 7.0) {
                            // Fade out
                            if (this.activeBoss.state !== 'hidden') {
                                this.activeBoss.setState('hidden');
                            }
                            // Actually remove once faded
                            if (this.activeBoss.alpha <= 0.05) {
                                this.activeBoss = null;
                                this.chillTime = 0;
                                // ready for next spawn
                            }
                        }
                    } else {
                        this.chillTime = 0;
                        if (this.activeBoss.state === 'hidden') this.activeBoss.setState('attack');
                    }
                } else {
                    // No active boss
                    if (intense) {
                        this.intenseTime += dt;
                        // Spawn after 3 seconds of sustained intensity
                        if (this.intenseTime >= 3.0) {
                            this.spawnBoss();
                            this.intenseTime = 0;
                        }
                    } else {
                        // Decay timer
                        this.intenseTime = Math.max(0, this.intenseTime - dt);
                    }
                }
            }
        }

        class Boss {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.x = width / 2;
                this.y = height * 0.25;
                // Base size before device scaling
                let baseOuter = 55 * 2.6; // ~143
                let baseCore = 26 * 2.6;  // ~68

                // On smaller/mobile displays, scale the boss down so it fits and feels fairer.
                if (typeof IS_MOBILE !== 'undefined' && IS_MOBILE) {
                    const minSide = Math.min(width, height);
                    const scale = minSide < 700 ? 0.7 : 0.85;
                    baseOuter *= scale;
                    baseCore *= scale;
                }

                this.r = Math.floor(baseOuter);
                this.coreR = Math.floor(baseCore);
                this.state = 'hidden'; // 'hidden','intro','attack','easy','death'
                this.alpha = 0;
                this.introProgress = 0;
                this.deathProgress = 0;
                this.coreRotation = 0;
                this.ringRotation = 0;
                this.pulse = 0;
                this.lastTime = 0;
                this.cooldowns = {
                    radial: 0,
                    fan: 0,
                    spiral: 0,
                    rockets: 0,
                    shockwave: 0
                };
                this.buffLevel = 1;
                // Enhanced stats for more aggressive behavior, but soften a bit on mobile.
                if (typeof IS_MOBILE !== 'undefined' && IS_MOBILE) {
                    this.aggressionMultiplier = 1.15; // slightly buffed over base, but milder than desktop
                    this.speedMultiplier = 1.0;       // keep projectile speeds closer to normal on phones
                } else {
                    this.aggressionMultiplier = 1.35; // attacks spawn 35% more frequently
                    this.speedMultiplier = 1.2;       // projectiles 20% faster
                }
            }

            setState(state) {
                if (this.state === state) return;
                this.state = state;
                if (state === 'intro') {
                    this.introProgress = 0;
                }
                if (state === 'death') {
                    this.deathProgress = 0;
                }
            }

            setBuffLevel(level) {
                this.buffLevel = level;
            }

            update(game, dt, t, config) {
                const { enableRadial, enableFan, enableSpiral, enableRockets, isIntroOnly, isEasyPhase, enableShockwave, enableSlam } = config;

                const speedMul = this.buffLevel * this.aggressionMultiplier;
                const baseCooldown = (name, base) => base / speedMul;
                const projectileSpeedMul = this.speedMultiplier;

                // simple alpha handling
                if (this.state === 'hidden') {
                    this.alpha = Math.max(0, this.alpha - dt * 3);
                } else if (this.state === 'intro' || this.state === 'attack' || this.state === 'easy') {
                    // slower fade-in so intro animations have time to play and feel dramatic
                    this.alpha = Math.min(1, this.alpha + dt * 1.2);
                }

                this.coreRotation += dt * 2.7;
                this.ringRotation -= dt * 1.9;
                this.pulse = 0.5 + Math.sin(t * 4) * 0.25;

                // mark "phase 2" (more intimidating attack phases) so draw() can highlight the boss
                this.isPhase2 = !!(enableFan || enableRockets || enableSpiral);

                // Initialize slam/puddle system if missing
                if (!this.puddles) this.puddles = [];
                if (!this.slamState) this.slamState = 'idle'; // idle, rise, hover, drop, impact
                if (!this.slamTimer) this.slamTimer = 0;
                if (typeof this.cooldowns.slam === 'undefined') this.cooldowns.slam = 0;

                // intro progress used for rise animation ‚Äî slow and smooth so it lasts visibly until the next scripted event
                if (this.state === 'intro') {
                    this.introProgress = Math.min(1, this.introProgress + dt * 0.45);
                }

                // death animation
                if (this.state === 'death') {
                    this.deathProgress = Math.min(1, this.deathProgress + dt * 0.7);
                    this.alpha = 1 - this.deathProgress;
                    if (this.deathProgress >= 1 && !game._mutantBossCleared) {
                        game._mutantBossCleared = true;
                    }
                }

                // Mutant boss movement: aggressive drift + light tracking
                // Overridden if slamming
                const isActiveState = (this.state === 'attack' || this.state === 'easy') && this.slamState === 'idle';
                if (isActiveState) {
                    // Horizontal lane that leans toward the player but never locks perfectly
                    const laneCenter = this.width * 0.5 + Math.sin(t * 0.4) * (this.width * 0.2);
                    const playerInfluence = game.player.x * 0.3 + laneCenter * 0.7;
                    const targetX = playerInfluence;
                    const targetY = this.height * 0.22 + Math.sin(t * 1.4) * 18;

                    this.x += (targetX - this.x) * dt * 3.5;
                    this.y += (targetY - this.y) * dt * 4.0;
                }

                // attack patterns (skip while purely intro / death)
                const canAttack = (this.state === 'attack' || this.state === 'easy') && !isIntroOnly && this.alpha > 0.2 && this.state !== 'death';

                // cooldown tick
                Object.keys(this.cooldowns).forEach(k => {
                    if (this.cooldowns[k] > 0) this.cooldowns[k] -= dt;
                });

                if (canAttack) {
                    // default radial bursts - even denser and faster
                    if (enableRadial && this.cooldowns.radial <= 0) {
                        const count = isEasyPhase ? 18 : 32;
                        const speedBase = isEasyPhase ? 2.2 : 3.4;
                        for (let i = 0; i < count; i++) {
                            const ang = (Math.PI * 2 * i) / count + t * 0.9;
                            const speed = (speedBase + Math.random() * 0.9) * getSpeedFactor() * speedMul * projectileSpeedMul;
                            const sx = this.x + Math.cos(ang) * (this.r + 8);
                            const sy = this.y + Math.sin(ang) * (this.r + 8);
                            game.shards.push(new Shard(sx, sy, ang, speed));
                        }
                        this.cooldowns.radial = baseCooldown('radial', isEasyPhase ? 1.6 : 0.95);
                    }

                    // fan patterns (extra attack) - wider spread, more rays, faster
                    if (enableFan && this.cooldowns.fan <= 0) {
                        const baseAngle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                        const spread = Math.PI / 2.5;
                        const rays = 9;
                        for (let i = 0; i < rays; i++) {
                            const a = baseAngle - spread / 2 + (spread / (rays - 1)) * i;
                            const speed = 3.6 * getSpeedFactor() * speedMul * projectileSpeedMul;
                            const sx = this.x + Math.cos(a) * (this.r + 12);
                            const sy = this.y + Math.sin(a) * (this.r + 12);
                            game.shards.push(new Shard(sx, sy, a, speed));
                        }
                        this.cooldowns.fan = baseCooldown('fan', isEasyPhase ? 2.0 : 1.1);
                    }

                    // spiral orbs (extra attack) - spawn in pairs, faster
                    if (enableSpiral && this.cooldowns.spiral <= 0) {
                        const count = 2;
                        for (let i = 0; i < count; i++) {
                            const s = new Spiral();
                            s.x = this.x + (Math.random() - 0.5) * this.r * 0.5;
                            s.y = this.y + (Math.random() - 0.5) * this.r * 0.5;
                            s.moveAngle = Math.atan2(game.player.y - this.y, game.player.x - this.x) + (i - 0.5) * 0.4;
                            s.spiralRadius = 16 * (this.r / 55);
                            s.speed *= projectileSpeedMul;
                            game.spirals.push(s);
                        }
                        this.cooldowns.spiral = baseCooldown('spiral', 1.8);
                    }

                    // rockets (primary big rocket attack) - more rockets, shorter lock, faster speed
                    if (enableRockets && this.cooldowns.rockets <= 0) {
                        const rocketCount = isEasyPhase ? 3 : 6;
                        for (let i = 0; i < rocketCount; i++) {
                            const hr = new HugeRocket(this);
                            hr.x += (Math.random() - 0.5) * (this.r * 0.5);
                            hr.y += (Math.random() - 0.5) * (this.r * 0.4);

                            // Faster lock, higher max speed
                            hr.lockDuration = 70;
                            hr.maxSpeed = 14 * getSpeedFactor() * projectileSpeedMul;
                            hr.r = Math.max(hr.r, 18);
                            hr.turnRate = 0.07;

                            game.rockets.push(hr);
                        }
                        this.cooldowns.rockets = baseCooldown('rockets', isEasyPhase ? 2.2 : 0.95);
                    }

                    // NEW: shockwave secondary attack (phase2 spin-flurry then ring)
                    if (enableShockwave && this.cooldowns.shockwave <= 0) {
                        // Initialize spin flurry state if necessary
                        if (!this._spinActive || this._spinActive === false) {
                            this._spinActive = true;
                            this._spinTimer = 0;
                            this._spinDuration = 2.0; // seconds of spinning flurry (shortened)
                            this._spinAccum = 0; // accumulator for spawn timing
                        }

                        // If spin is active, do continuous directional flurry - denser, faster
                        if (this._spinActive && this._spinTimer < this._spinDuration) {
                            this._spinTimer += dt;
                            this._spinAccum += dt;
                            const spawnInterval = 0.06; // even faster spawn rate
                            while (this._spinAccum >= spawnInterval) {
                                this._spinAccum -= spawnInterval;

                                // Spawn more shards per burst
                                const flurryCount = 16 + Math.floor(Math.random() * 10);
                                for (let i = 0; i < flurryCount; i++) {
                                    const ang = Math.random() * Math.PI * 2;
                                    const baseSpeed = 4.2 + Math.random() * 2.0;
                                    const speed = baseSpeed * getSpeedFactor() * speedMul * projectileSpeedMul * (0.95 + Math.random() * 0.25);
                                    const sx = this.x + Math.cos(ang) * (this.r + 10 + Math.random() * 20);
                                    const sy = this.y + Math.sin(ang) * (this.r + 10 + Math.random() * 20);
                                    const s = new Shard(sx, sy, ang, speed);
                                    s.r = 2.5 + Math.random() * 3.5;
                                    game.shards.push(s);
                                }

                                if (game.particleSystem && Math.random() < 0.4) {
                                    for (let i = 0; i < 8; i++) {
                                        const ang = Math.random() * Math.PI * 2;
                                        const dist = this.r * 0.6 + Math.random() * (this.r * 1.0);
                                        const px = this.x + Math.cos(ang) * dist;
                                        const py = this.y + Math.sin(ang) * dist;
                                        game.particleSystem.addParticle(px, py, 'rgb(255,180,140)', 3, 0.8);
                                    }
                                }
                            }

                            this.cooldowns.shockwave = baseCooldown('shockwave', 0.02);
                        } else {
                            // spin finished: spawn larger, faster ring
                            const pieces = 40 + Math.floor(16 * (this.r / 55));
                            for (let i = 0; i < pieces; i++) {
                                const ang = (Math.PI * 2 * i) / pieces + (Math.random() - 0.5) * 0.08;
                                const speed = 2.8 * getSpeedFactor() * speedMul * projectileSpeedMul * (1 + Math.random() * 0.12);
                                const sx = this.x + Math.cos(ang) * (this.r + 32);
                                const sy = this.y + Math.sin(ang) * (this.r + 32);
                                const bigShard = new Shard(sx, sy, ang, speed);
                                bigShard.r = Math.max(7, bigShard.r * 1.8);
                                game.shards.push(bigShard);
                            }

                            if (game.particleSystem) {
                                for (let i = 0; i < 64; i++) {
                                    const ang = Math.random() * Math.PI * 2;
                                    const dist = this.r * 1.0 + Math.random() * (this.r * 1.2);
                                    const px = this.x + Math.cos(ang) * dist;
                                    const py = this.y + Math.sin(ang) * dist;
                                    game.particleSystem.addParticle(px, py, 'rgb(255,140,100)', 5, 1.5);
                                }
                            }

                            this._spinActive = false;
                            this._spinTimer = 0;
                            this._spinAccum = 0;
                            this.cooldowns.shockwave = baseCooldown('shockwave', 4.8);
                        }
                    }

                    // SLAM ATTACK (Puddle Explosion)
                    if (enableSlam && this.slamState === 'idle' && this.cooldowns.slam <= 0) {
                        this.slamState = 'rise';
                        this.slamTimer = 0;
                    }
                }

                // Handle Slam State Machine
                if (this.slamState !== 'idle') {
                    this.slamTimer += dt;
                    if (this.slamState === 'rise') {
                        // Move to top center
                        const tx = this.width / 2;
                        const ty = 80;
                        this.x += (tx - this.x) * dt * 5;
                        this.y += (ty - this.y) * dt * 5;
                        if (this.slamTimer > 1.0) {
                            this.slamState = 'hover';
                            this.slamTimer = 0;
                        }
                    } else if (this.slamState === 'hover') {
                        // Shake/Telegraph
                        this.x = (this.width / 2) + (Math.random() - 0.5) * 10;
                        if (this.slamTimer > 0.5) {
                            this.slamState = 'drop';
                            this.slamTimer = 0;
                        }
                    } else if (this.slamState === 'drop') {
                        // Fall fast
                        this.y += dt * 2500 * getSpeedFactor();
                        if (this.y >= this.height - 50) {
                            this.y = this.height - 50;
                            this.slamState = 'impact';
                            this.slamTimer = 0;
                            game.triggerShake(40);
                            
                            // Spawn Puddles (Hazard Zone)
                            // Create a wave of "bubbles" at the bottom
                            const count = 12;
                            const spacing = this.width / count;
                            for(let i=0; i<=count; i++) {
                                this.puddles.push({
                                    x: i * spacing,
                                    y: this.height,
                                    r: 0,
                                    maxR: (80 + Math.random() * 40) * 4,
                                    life: 2.5,
                                    maxLife: 2.5,
                                    growthSpeed: 400
                                });
                            }
                            
                            // Mobile vibration
                            try { if(navigator.vibrate) navigator.vibrate(200); } catch(e){}
                        }
                    } else if (this.slamState === 'impact') {
                        // Stay on ground briefly
                        if (this.slamTimer > 0.5) {
                            this.slamState = 'return';
                            this.slamTimer = 0;
                        }
                    } else if (this.slamState === 'return') {
                        // Float back up
                        const targetY = this.height * 0.22;
                        this.y += (targetY - this.y) * dt * 2;
                        if (Math.abs(this.y - targetY) < 20) {
                            this.slamState = 'idle';
                            this.cooldowns.slam = baseCooldown('slam', 6.0);
                        }
                    }
                }

                // Update Puddles
                for (let i = this.puddles.length - 1; i >= 0; i--) {
                    const p = this.puddles[i];
                    if (p.r < p.maxR) {
                        p.r += dt * p.growthSpeed;
                    }
                    p.life -= dt;
                    if (p.life <= 0) {
                        this.puddles.splice(i, 1);
                    }
                }
            }

            checkPuddleCollision(player) {
                if (!this.puddles) return false;
                for (const p of this.puddles) {
                    // Check intersection with semi-circles growing from bottom
                    const dx = player.x - p.x;
                    const dy = player.y - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < p.r + player.r) return true;
                }
                return false;
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                if (this.alpha <= 0) return;

                ctx.save();
                ctx.globalAlpha = this.alpha;

                // rising intro: lerp y from off-screen
                let renderY = this.y;
                if (this.state === 'intro') {
                    const startY = -this.r * 2;
                    renderY = startY + (this.y - startY) * this.introProgress;
                }

                // slight bob
                const bob = Math.sin(performance.now() / 600) * 10;
                renderY += bob;

                // Draw Puddles (Background layer relative to boss)
                if (this.puddles && this.puddles.length > 0) {
                    ctx.save();
                    for (const p of this.puddles) {
                        const alpha = Math.min(1, p.life * 2);
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ff0055';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, Math.PI, 0); // Semi-circle
                        ctx.fill();
                        
                        // Inner hot core
                        ctx.fillStyle = '#ff99aa';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r * 0.7, Math.PI, 0);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                // Main body distorted circle
                ctx.beginPath();
                const spikes = 24;
                // If slamming, look spikier/angrier
                const isSlamming = this.slamState && this.slamState !== 'idle';
                
                for (let i = 0; i <= spikes; i++) {
                    const angle = (Math.PI * 2 * i) / spikes;
                    const spikeAmp = isSlamming ? 0.2 : 0.05;
                    const baseR = this.r * (0.9 + Math.sin(performance.now() / (isSlamming ? 50 : 200) + i) * spikeAmp);
                    const x = this.x + Math.cos(angle) * baseR;
                    const y = renderY + Math.sin(angle) * baseR;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = isSlamming ? '#4a0000' : '#1a0505';
                ctx.fill();
                ctx.strokeStyle = '#ff0055';
                ctx.lineWidth = 3;
                if (graphicsLevel === 'ULTRA') {
                     ctx.shadowBlur = 30;
                     ctx.shadowColor = '#ff0055';
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // PHASE 2 RED RING - BIGGER AND THICKER
                if (this.isPhase2 || isSlamming) {
                    ctx.save();
                    const ringPulse = 1.0 + Math.sin(performance.now() / 150) * 0.1;
                    ctx.beginPath();
                    ctx.arc(this.x, renderY, this.r * 1.6 * ringPulse, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 12; // Very thick
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff0000';
                    ctx.stroke();
                    
                    // Inner faint ring
                    ctx.beginPath();
                    ctx.arc(this.x, renderY, this.r * 1.3, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.restore();
                }

                // Rotating Core
                ctx.save();
                ctx.translate(this.x, renderY);
                ctx.rotate(this.coreRotation);
                
                // Core shape
                ctx.beginPath();
                ctx.rect(-this.coreR, -this.coreR, this.coreR*2, this.coreR*2);
                const coreGrad = ctx.createLinearGradient(-this.coreR, -this.coreR, this.coreR, this.coreR);
                coreGrad.addColorStop(0, '#ff0055');
                coreGrad.addColorStop(1, '#ff9900');
                ctx.fillStyle = coreGrad;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0055';
                ctx.fill();

                // Eye
                ctx.beginPath();
                ctx.arc(0, 0, this.coreR * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                
                // Pupil
                const lookX = Math.cos(performance.now() / 1000) * 5;
                const lookY = Math.sin(performance.now() / 1000) * 5;
                ctx.beginPath();
                ctx.arc(lookX, lookY, this.coreR * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#ff0000';
                ctx.fill();

                ctx.restore();
                ctx.restore();
            }
        }

        class Sweeper {
            constructor() {
                // Randomly choose Horizontal (Top->Bottom) or Vertical (Left->Right)
                this.orientation = Math.random() < 0.5 ? 'H' : 'V';
                this.thickness = 40;
                this.gapSize = 150;
                this.speed = 3 * getSpeedFactor();
                this.active = true;

                if (this.orientation === 'H') {
                    this.y = -this.thickness;
                    this.x = 0;
                    const maxGapPos = Math.max(0, game.width - this.gapSize - 50);
                    this.gapPos = Math.max(50, Math.min(maxGapPos, Math.random() * game.width));
                } else {
                    this.x = -this.thickness;
                    this.y = 0;
                    const maxGapPos = Math.max(0, game.height - this.gapSize - 50);
                    this.gapPos = Math.max(50, Math.min(maxGapPos, Math.random() * game.height));
                }
            }

            update() {
                if (this.orientation === 'H') {
                    this.y += this.speed;
                    if (this.y > game.height) this.active = false;
                } else {
                    this.x += this.speed;
                    if (this.x > game.width) this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                
                ctx.shadowBlur = 18;
                ctx.shadowColor = '#22d3ee';
                
                let neon;
                if (this.orientation === 'H') {
                    neon = ctx.createLinearGradient(0, 0, game.width, 0);
                } else {
                    neon = ctx.createLinearGradient(0, 0, 0, game.height);
                }
                neon.addColorStop(0, '#22d3ee');
                neon.addColorStop(0.5, '#a855f7');
                neon.addColorStop(1, '#22d3ee');
                ctx.fillStyle = neon;

                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#22d3ee';
                } else if (graphicsLevel === 'ULTRA') {
                    ctx.shadowBlur = 35;
                    ctx.shadowColor = '#00ffff';
                    // Brighter core
                    const bright = ctx.createLinearGradient(0, 0, this.orientation === 'H' ? game.width : 0, this.orientation === 'H' ? 0 : game.height);
                    bright.addColorStop(0, '#ffffff');
                    bright.addColorStop(0.5, '#00ffff');
                    bright.addColorStop(1, '#ffffff');
                    ctx.fillStyle = bright;
                }

                if (this.orientation === 'H') {
                    if (this.gapPos > 0) {
                        ctx.fillRect(0, this.y, this.gapPos, this.thickness);
                    }
                    const rightStart = this.gapPos + this.gapSize;
                    if (rightStart < game.width) {
                        ctx.fillRect(rightStart, this.y, game.width - rightStart, this.thickness);
                    }
                } else {
                    if (this.gapPos > 0) {
                        ctx.fillRect(this.x, 0, this.thickness, this.gapPos);
                    }
                    const bottomStart = this.gapPos + this.gapSize;
                    if (bottomStart < game.height) {
                        ctx.fillRect(this.x, bottomStart, this.thickness, game.height - bottomStart);
                    }
                }
                ctx.shadowBlur = 0;
            }

            checkCollision(player) {
                if (this.orientation === 'H') {
                    if (player.y + player.r > this.y && player.y - player.r < this.y + this.thickness) {
                        if (player.x > this.gapPos && player.x < this.gapPos + this.gapSize) {
                            return false;
                        }
                        return true;
                    }
                } else {
                    if (player.x + player.r > this.x && player.x - player.r < this.x + this.thickness) {
                        if (player.y > this.gapPos && player.y < this.gapPos + this.gapSize) {
                            return false;
                        }
                        return true;
                    }
                }
                return false;
            }
        }

        class Rocket {
            constructor() {
                // Spawn from a random edge
                const side = Math.floor(Math.random() * 4);
                const w = game.width;
                const h = game.height;

                if (side === 0) { // top
                    this.x = Math.random() * w;
                    this.y = -20;
                } else if (side === 1) { // right
                    this.x = w + 20;
                    this.y = Math.random() * h;
                } else if (side === 2) { // bottom
                    this.x = Math.random() * w;
                    this.y = h + 20;
                } else { // left
                    this.x = -20;
                    this.y = Math.random() * h;
                }

                this.speed = 3 * getSpeedFactor();
                this.vx = 0;
                this.vy = 0;
                this.r = 8;
                this.trackingFrames = 180; // ~3 seconds at 60fps
                this.totalFrames = 0;
                this.active = true;
                this.trail = [];
                this.turnRate = 0.05; // How fast the rocket can turn
            }

            update() {
                this.totalFrames++;

                if (this.totalFrames <= this.trackingFrames) {
                    // Smooth homing with gradual turning
                    const dx = game.player.x - this.x;
                    const dy = game.player.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    const currentAngle = Math.atan2(this.vy, this.vx);
                    
                    // Calculate angle difference and normalize to [-PI, PI]
                    let angleDiff = targetAngle - currentAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Turn gradually towards target
                    const newAngle = currentAngle + angleDiff * this.turnRate;
                    this.vx = Math.cos(newAngle) * this.speed;
                    this.vy = Math.sin(newAngle) * this.speed;
                }
                
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 12) this.trail.shift();
                
                // After trackingFrames, continue straight with last vx,vy
                this.x += this.vx;
                this.y += this.vy;

                // Deactivate if far off-screen
                if (this.x < -100 || this.x > game.width + 100 || this.y < -100 || this.y > game.height + 100) {
                    this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                const angle = Math.atan2(this.vy, this.vx);
                
                ctx.save();
                
                // Draw smoke/fire trail (only on HIGH and MEDIUM)
                if (graphicsLevel === 'HIGH' || graphicsLevel === 'MEDIUM') {
                    for (let i = 0; i < this.trail.length; i++) {
                        const t = this.trail[i];
                        const alpha = (i / this.trail.length) * 0.6;
                        const size = 3 + (i / this.trail.length) * 5;
                        
                        // Fire (orange-red gradient)
                        if (i > this.trail.length * 0.6) {
                            ctx.globalAlpha = alpha * 0.8;
                            const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size);
                            grad.addColorStop(0, '#ff6600');
                            grad.addColorStop(0.5, '#ff3300');
                            grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                            ctx.fill();
                        } 
                        // Smoke (gray)
                        else {
                            ctx.globalAlpha = alpha * 0.5;
                            const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, size);
                            grad.addColorStop(0, '#666666');
                            grad.addColorStop(1, 'rgba(100, 100, 100, 0)');
                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.globalAlpha = 1;
                }

                ctx.translate(this.x, this.y);
                ctx.rotate(angle);

                // Rocket body
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(-4, 6);
                ctx.lineTo(-8, 0);
                ctx.lineTo(-4, -6);
                ctx.closePath();
                const bodyGrad = ctx.createLinearGradient(-8, 0, 12, 0);
                bodyGrad.addColorStop(0, '#fb923c');
                bodyGrad.addColorStop(1, '#f97316');
                ctx.fillStyle = bodyGrad;
                if (graphicsLevel === 'HIGH') {
                    ctx.shadowBlur = 16;
                    ctx.shadowColor = '#fdba74';
                }
                ctx.fill();

                // Nose highlight
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(6, -2);
                ctx.lineTo(9, 0);
                ctx.lineTo(6, 2);
                ctx.stroke();

                ctx.restore();
            }

            checkCollision(player) {
                const graceRadius = (typeof game !== 'undefined' && game.comboGraceRadius) ? game.comboGraceRadius : 0;
                return checkCircleCollision(
                    { x: this.x, y: this.y, r: this.r },
                    { x: player.x, y: player.y, r: player.r + graceRadius }
                );
            }
        }

        // HugeRocket: boss-fired slow-lock then sprint rocket (visually large, then locks and accelerates)
        class HugeRocket {
            constructor(boss) {
                this.x = boss.x;
                this.y = boss.y + (Math.random() - 0.5) * 40; // slight vertical offset
                this.vx = 0;
                this.vy = 0;
                this.r = 18; // larger visual radius for greater presence
                this.lockTime = 0; // frames spent locking (frame-count semantics)
                this.lockDuration = 90; // longer lock so player sees the lock-on (~1.5s at 60fps)
                this.launched = false;
                this.speed = 0;
                // After launch, this will sprint out much faster than ordinary projectiles (scaled by getSpeedFactor)
                this.maxSpeed = 12 * getSpeedFactor();
                this.active = true;
                this.tracking = true;
                this.targetAngle = 0;
                this.turnRate = 0.08; // moderate turn so it's dangerous but dodgeable
            }

            update() {
                // while locking, remain near spawn and slowly track the player angle
                if (!this.launched) {
                    this.lockTime++;
                    // visually jitter slightly while locking
                    this.x += (Math.random() - 0.5) * 0.5;
                    this.y += (Math.random() - 0.5) * 0.5;

                    // continually compute desired angle to player
                    const dx = game.player.x - this.x;
                    const dy = game.player.y - this.y;
                    this.targetAngle = Math.atan2(dy, dx);

                    if (this.lockTime >= this.lockDuration) {
                        // launch: set velocity aimed at last known angle and very high speed
                        this.launched = true;
                        const ang = this.targetAngle;
                        this.speed = this.maxSpeed * (1 + Math.random() * 0.12);
                        this.vx = Math.cos(ang) * this.speed;
                        this.vy = Math.sin(ang) * this.speed;
                    }
                } else {
                    // in-flight: after launch the HugeRocket travels straight at the locked angle as a very fast, non-homing projectile
                    // (we intentionally DO NOT adjust velocity mid-flight so it behaves like a sprinting shard)
                    this.x += this.vx;
                    this.y += this.vy;
                }

                // deactivate when offscreen
                if (this.x < -200 || this.x > game.width + 200 || this.y < -200 || this.y > game.height + 200) {
                    this.active = false;
                }
            }

            draw(ctx) {
                const graphicsLevel = (typeof window !== 'undefined' && window.GRAPHICS_LEVEL) ? window.GRAPHICS_LEVEL : 'HIGH';
                ctx.save();
                ctx.translate(this.x, this.y);
                const angle = this.launched ? Math.atan2(this.vy, this.vx) : (performance.now() / 600);
                ctx.rotate(angle);

                // big glow while locking
                if (!this.launched) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.r * 1.9, 0, Math.PI * 2);
                    const g = ctx.createRadialGradient(0,0,this.r*0.3,0,0,this.r*1.9);
                    g.addColorStop(0, 'rgba(255,80,30,0.22)');
                    g.addColorStop(1, 'rgba(255,80,30,0)');
                    ctx.fillStyle = g;
                    ctx.fill();

                    // visible lock ring
                    ctx.beginPath();
                    ctx.arc(0, 0, this.r * 1.2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 60, 10, 0.95)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([6,4]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = '#ff7a00';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff7a00';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // streamlined body in flight (larger)
                    ctx.beginPath();
                    ctx.moveTo(this.r + 8, 0);
                    ctx.lineTo(-this.r + 8, this.r * 0.7);
                    ctx.lineTo(-this.r - 4, 0);
                    ctx.lineTo(-this.r + 8, -this.r * 0.7);
                    ctx.closePath();
                    const grad = ctx.createLinearGradient(-this.r, 0, this.r, 0);
                    grad.addColorStop(0, '#ff7a00');
                    grad.addColorStop(1, '#ff3300');
                    ctx.fillStyle = grad;
                    ctx.shadowBlur = 26;
                    ctx.shadowColor = '#ff7a00';
                    ctx.fill();

                    // flame tail
                    ctx.shadowBlur = 14;
                    const tailGrad = ctx.createLinearGradient(-this.r*1.8, 0, -this.r*0.8, 0);
                    tailGrad.addColorStop(0, 'rgba(0,0,0,0)');
                    tailGrad.addColorStop(1, 'rgba(255,120,20,0.95)');
                    ctx.fillStyle = tailGrad;
                    ctx.beginPath();
                    ctx.ellipse(-this.r - 10, 0, this.r * 1.05, this.r * 0.45, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            checkCollision(player) {
                const graceRadius = (typeof game !== 'undefined' && game.comboGraceRadius) ? game.comboGraceRadius : 0;
                return checkCircleCollision(
                    { x: this.x, y: this.y, r: this.r },
                    { x: player.x, y: player.y, r: player.r + graceRadius }
                );
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            addParticle(x, y, color, size, life) {
                this.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: color,
                    size: size,
                    life: life,
                    maxLife: life
                });
            }

            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life -= 0.02;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render(ctx) {
                // Respect graphics quality setting: only render particles on HIGH
                if (typeof window !== 'undefined' && window.GRAPHICS_LEVEL && window.GRAPHICS_LEVEL !== 'HIGH') {
                    if (!this.enabled) return;
                    // For MEDIUM/BASIC we simply skip particle draws
                    return;
                }
                for (const p of this.particles) {
                    const alpha = p.life / p.maxLife;
                    ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class DemoGame {
            constructor() {
                this.canvas = document.getElementById('demoCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = new AudioEngine();
                
                this.width = this.canvas.offsetWidth;
                this.height = this.canvas.offsetHeight;
                // Remove reduced resolution scaling - use 1:1
                this.canvasScale = 1;
                this.canvas.width = this.width * this.canvasScale;
                this.canvas.height = this.height * this.canvasScale;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';

                this.player = new Player(this.canvas);
                this.player.x = this.width / 2;
                this.player.y = this.height / 2;
                this.visualizer = createVisualizer(this.width, this.height);
                this.particleSystem = new ParticleSystem();
                
                this.shards = [];
                this.lines = [];
                this.bombs = [];
                this.sweepers = [];
                this.spirals = [];
                
                this.cooldowns = {
                    line: 0,
                    bomb: 0,
                    sweeper: 0,
                    shard: 0,
                    spiral: 0
                };
                
                this.isRunning = false;
                this.shake = 0;
                
                this.aiTarget = { x: this.width / 2, y: this.height / 2 };
                this.aiThinkTimer = 0;

                // Control whether the demo player's avatar is visible (checkbox toggles this)
                this.playerVisible = false;

                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                // Size the demo canvas to its container (or viewport as fallback)
                const parent = this.canvas.parentElement;
                this.width = (parent && parent.offsetWidth) || window.innerWidth;
                this.height = (parent && parent.offsetHeight) || window.innerHeight;
                // Remove reduced resolution scaling - use 1:1
                this.canvasScale = 1;
                this.canvas.width = this.width * this.canvasScale;
                this.canvas.height = this.height * this.canvasScale;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';

                if (this.visualizer) {
                    this.visualizer.setSize(this.canvas.width, this.canvas.height);
                }

                if (this.player) {
                    // Keep AI player roughly centered in the demo area
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                }
            }

            async init() {
                const loadingStatus = document.getElementById('loading-status');
                const loadingScreen = document.getElementById('loading-screen');
                const uiLayer = document.getElementById('ui-layer');
                
                try {
                    loadingStatus.innerText = 'Loading menu music...';
                    const response = await fetch('/MainMenu.wav');
                    const blob = await response.blob();
                    const file = new File([blob], 'MainMenu.wav', { type: 'audio/wav' });
                    await this.audio.loadFile(file);
                    
                    loadingStatus.innerText = 'Loading sound effects...';
                    await this.loadSticksSound();
                    
                    loadingStatus.innerText = 'Starting...';
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // Ensure demo canvas is sized correctly now that it is visible
                    this.resize();
                    
                    // Hide loading screen
                    loadingScreen.style.display = 'none';
                    uiLayer.classList.remove('hidden');
                    
                    // Only start audio/loop if audio loaded successfully
                    try {
                        // On mobile we play the menu music but do not start the demo rendering loop
                        // to keep the main menu compact and ensure buttons remain visible.
                        const demoContainer = document.getElementById('demo-container');
                        if (IS_MOBILE) {
                            // Play menu music but hide the demo view so it doesn't take menu space
                            this.audio.play();
                            // ensure UI is visible (buttons accessible)
                            uiLayer.classList.remove('hidden');
                            if (demoContainer) demoContainer.style.display = 'none';
                            this.isRunning = false;
                        } else {
                            // Desktop: show demo visuals and loop
                            this.audio.play();
                            // start subtle title animation so the menu feels alive with the music
                            try {
                                const titleEl = document.querySelector('h1');
                                if (titleEl) titleEl.classList.add('title-bop');
                            } catch (e) {}
                            this.isRunning = true;
                            this.loop();
                        }
                    } catch (e) {
                        console.error('Failed to start demo audio:', e);
                    }
                } catch (e) {
                    console.error('Demo init error:', e);
                    // Even on error, hide loading screen so the UI doesn't get stuck
                    loadingScreen.style.display = 'none';
                    uiLayer.classList.remove('hidden');
                }
            }

            async loadSticksSound() {
                try {
                    const response = await fetch('/Sticks hitting.mp3');
                    const blob = await response.blob();
                    window.sticksAudioBlob = blob;

                    // Pre-decode sticks audio so we can trigger it quickly during hover
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    const sticksCtx = new AudioCtx();
                    const arrayBuffer = await blob.arrayBuffer();
                    const audioBuffer = await sticksCtx.decodeAudioData(arrayBuffer);
                    window.sticksAudioCtx = sticksCtx;
                    window.sticksAudioBuffer = audioBuffer;
                } catch (e) {
                    console.error('Failed to load sticks sound:', e);
                }
            }

            aiUpdate() {
                this.aiThinkTimer++;
                
                // Find nearest threat
                let nearestThreat = null;
                let nearestDist = Infinity;
                
                for (const shard of this.shards) {
                    const dist = Math.hypot(shard.x - this.player.x, shard.y - this.player.y);
                    if (dist < nearestDist && dist < 200) {
                        nearestDist = dist;
                        nearestThreat = shard;
                    }
                }
                
                if (nearestThreat && nearestDist < 150) {
                    // Evade perpendicular to threat direction
                    const dx = nearestThreat.x - this.player.x;
                    const dy = nearestThreat.y - this.player.y;
                    const angle = Math.atan2(dy, dx);
                    const evadeAngle = angle + Math.PI / 2;
                    
                    this.aiTarget.x = this.player.x + Math.cos(evadeAngle) * 100;
                    this.aiTarget.y = this.player.y + Math.sin(evadeAngle) * 100;
                } else if (this.aiThinkTimer > 90) {
                    // Random movement - slower update
                    this.aiThinkTimer = 0;
                    this.aiTarget.x = Math.random() * this.width;
                    this.aiTarget.y = Math.random() * this.height;
                }
                
                // Clamp to canvas
                this.aiTarget.x = Math.max(50, Math.min(this.width - 50, this.aiTarget.x));
                this.aiTarget.y = Math.max(50, Math.min(this.height - 50, this.aiTarget.y));
            }

            stop() {
                this.isRunning = false;
                if (this.audio && this.audio.isPlaying) {
                    this.audio.stop();
                }
            }

            resumeDemo() {
                if (!this.audio || !this.audio.audioBuffer) return;
                if (this.isRunning) return;
                try {
                    this.isRunning = true;
                    this.audio.play(0);
                    this.loop();
                } catch (e) {
                    console.error('Failed to resume demo audio:', e);
                    this.isRunning = false;
                }
            }

            async fadeOutDemo() {
                const menuSidebar = document.getElementById('menu-sidebar');
                const demoContainer = document.getElementById('demo-container');
                
                // Fade out music
                await Promise.all([
                    this.audio.fadeOut(1500),
                    new Promise(resolve => {
                        menuSidebar.style.transition = 'opacity 1.5s';
                        menuSidebar.style.opacity = '0';
                        setTimeout(resolve, 1500);
                    }),
                    new Promise(resolve => {
                        demoContainer.style.transition = 'opacity 1.5s';
                        demoContainer.style.opacity = '0';
                        setTimeout(resolve, 1500);
                    })
                ]);
                
                this.stop();
            }

            loop() {
                if (!this.isRunning) return;

                this.audio.update();
                this.visualizer.update(this.audio.dataArray, this.audio.volume);
                this.spawnLogic();
                this.aiUpdate();

                this.ctx.save();

                // Dynamic gradient background based on intensity
                const intensity = this.audio.volume;
                const bassGlow = this.audio.bass * 100;
                const midGlow = this.audio.mid * 100;
                const trebleGlow = this.audio.treble * 100;
                
                // Ensure radial gradient covers corners even on wide screens
                const radius = Math.max(this.width, this.height) * 1.5;
                const gradient = this.ctx.createRadialGradient(
                    this.width / 2, this.height / 2, 0,
                    this.width / 2, this.height / 2, radius
                );
                gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Disabled particle spawning for performance

                this.visualizer.render(this.ctx);

                this.ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.player.update(this.aiTarget.x, this.aiTarget.y);
                if (this.playerVisible !== false) {
                    this.player.draw(this.ctx);
                }

                this.lines = this.lines.filter(l => l.active);
                this.lines.forEach(l => {
                    l.update();
                    l.draw(this.ctx);
                });

                this.bombs = this.bombs.filter(b => b.active);
                this.bombs.forEach(b => {
                    b.update();
                    b.draw(this.ctx);
                });

                this.sweepers = this.sweepers.filter(s => s.active);
                this.sweepers.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });

                this.shards = this.shards.filter(s => s.active);
                this.shards.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });

                this.spirals = this.spirals.filter(s => s.active);
                this.spirals.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                });

                this.particleSystem.update();
                this.particleSystem.render(this.ctx);

                this.ctx.restore();

                requestAnimationFrame(() => this.loop());
            }

            spawnLogic() {
                for(let k in this.cooldowns) {
                    if(this.cooldowns[k] > 0) this.cooldowns[k]--;
                }

                const beatStrength = this.audio.beatStrength || 0;
                const onBeat = this.audio.beat === 1;

                if (this.audio.bass > 0.65 && this.cooldowns.bomb <= 0) {
                    this.bombs.push(new Bomb());
                    // make spawns rarer on mobile by scaling cooldowns up
                    this.cooldowns.bomb = Math.ceil(60 * getSpawnScale());
                }

                if (this.audio.mid > 0.5 && this.cooldowns.line <= 0) {
                    this.lines.push(new Line());
                    this.cooldowns.line = Math.ceil(40 * getSpawnScale());
                }

                if (this.audio.volume > 0.7 && this.cooldowns.sweeper <= 0) {
                    this.sweepers.push(new Sweeper());
                    this.cooldowns.sweeper = Math.ceil(120 * getSpawnScale());
                }

                // Treble-driven shard spam, modulated by intensity
                if (this.audio.treble > 0.35 && this.cooldowns.shard <= 0) {
                    const extra = 1 + Math.floor(this.audio.treble * 2);
                    for (let i = 0; i < extra; i++) {
                        const x = Math.random() * this.width;
                        const angle = Math.atan2(this.player.y - 0, this.player.x - x) + (Math.random()-0.5);
                        const speedBoost = 2 + (this.audio.treble * 3) + beatStrength * 1.5;
                        this.shards.push(new Shard(x, -10, angle, speedBoost * getSpeedFactor()));
                    }
                    this.cooldowns.shard = Math.ceil(12 * getSpawnScale());
                }

                // Beat-locked spiral bursts: feel like they fire on the kick
                if (onBeat && this.cooldowns.spiral <= 0) {
                    const count = 1 + Math.floor(beatStrength * 3);
                    for (let i = 0; i < count; i++) {
                        this.spirals.push(new Spiral());
                    }
                    this.cooldowns.spiral = Math.ceil(60 * getSpawnScale());
                } else if (this.audio.mid > 0.6 && this.cooldowns.spiral <= 0) {
                    this.spirals.push(new Spiral());
                    this.cooldowns.spiral = Math.ceil(80 * getSpawnScale());
                }
            }
        }

        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1.0;
                this.vy = -1;
            }

            update() {
                this.y += this.vy;
                this.life -= 0.02;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = 'bold 20px Orbitron';
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = new AudioEngine();
                
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                // Remove reduced resolution scaling - use 1:1
                this.canvasScale = 1;
                this.canvas.width = this.width * this.canvasScale;
                this.canvas.height = this.height * this.canvasScale;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';

                this.player = new Player(this.canvas);
                this.visualizer = createVisualizer(this.width, this.height);
                this.particleSystem = new ParticleSystem();
                
                this.shards = [];
                this.lines = [];
                this.bombs = [];
                this.sweepers = [];
                this.rockets = [];
                this.spirals = [];
                this.boss = null;
                this.isMutantBoss = false;
                this.customBossManager = new CustomBossManager(this);
                this.isCustomSongBossEligible = false;
                this._mutantBossPhase = null;
                this._mutantBossPrevPhase = null;
                this._mutantBossDeathTriggered = false;
                
                // Replay system
                this.replayFrames = [];
                this.isReplaying = false;
                this.replayIndex = 0;
                
                this.mouseX = this.width / 2;
                this.mouseY = this.height / 2;

                this.score = 0;
                this.lastScore = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.maxCombo = 0;
                this.comboSpeedBoost = 1;
                this.comboGraceRadius = 0;
                this.grazeScore = 0;
                this.grazeCount = 0;
                this.lastCheckpointTime = 0;
                this.checkpoints = [];
                this.isRunning = false;
                this.countdownActive = false;
                this.countdownProgress = 0;
                this.gameScale = 1.0;
                this.targetGameScale = 1.0;
                this.startSequenceActive = false;
                this.startSequenceTimer = 0;
                this.paused = false;
                this.floatingTexts = [];
                
                this.shake = 0;
                this.lastDamageTime = performance.now();
                this.regenDelay = 2000;
                this.regenRate = 0.3;

                this.profile = {
                    level: 1,
                    exp: 0,
                    expToNext: 1000,
                    currentSkin: 'orb'
                };
                // Three career save slots (per-slot completion and difficulty)
                this.careerSlots = [
                    { id: 0, difficulty: CAREER_DIFFICULTY, completed: [] },
                    { id: 1, difficulty: CAREER_DIFFICULTY, completed: [] },
                    { id: 2, difficulty: CAREER_DIFFICULTY, completed: [] }
                ];
                this.currentCareerSlot = 0;
                this.loadProfile();
                this.player.setSkin(this.profile.currentSkin);

                this.careerSongs = [
                    { 
                        path: '/Blow It Away.mp3', 
                        title: 'Quickdraw', 
                        completed: false, 
                        difficulty: 'MEDIUM',
                        story: `Mission 1: The first wave has arrived. A rogue AI has breached the mainframe, sending rhythmic pulses of corrupted data. Your neural interface syncs with the audio stream ‚Äî every beat is a battle command. Survive the digital onslaught and prove you can handle the chaos.`
                    },
                    { 
                        path: '/Digital Masquerade.mp3', 
                        title: 'Digital Massacre', 
                        completed: false, 
                        difficulty: 'HARD',
                        story: `Mission 2: The AI adapts. What began as scattered attacks has evolved into coordinated strikes. You're deep in the system now ‚Äî firewalls crumbling, defenses overwhelmed. The masquerade is over. This is war. Can you survive the massacre?`
                    },
                    { 
                        path: '/Dizzy Carousel.mp3', 
                        title: 'CLOWN', 
                        completed: false, 
                        difficulty: 'CHALLENGER',
                        story: `Mission 3: Reality fractures. The AI's core protocol reveals itself ‚Äî a twisted carnival of code, spinning endlessly. Spiraling patterns, disorienting loops, relentless rotation. The system mocks you with chaos. Break through the madness or be consumed by the carousel.`
                    },
                    { 
                        path: '/Mutant.mp3', 
                        title: 'Mutant', 
                        completed: false, 
                        locked: true, 
                        difficulty: 'EXPERT++',
                        story: `Final Mission: The core has mutated beyond recognition. This is the heart of the corruption ‚Äî an impossible fusion of every pattern you've faced, amplified beyond limits. The system's last defense. Everything you've learned is tested here. Victory means liberation. Failure means deletion. There is no middle ground.`
                    }
                ];
                this.loadCareer();
                this.currentSongTitle = '';
                this.songDifficulty = '';
                this.isCareerMode = false;
                this.isTutorialMode = false;
                this.previewVolume = 0.5;

                // Prevent multiple gameOver calls / conflicting end states
                this.gameHasEnded = false;

                this.progressBarEl = document.getElementById('song-progress-bar');
                
                this.hitFlashOpacity = 0;
                this.levelUpNotification = null;

                this.cooldowns = {
                    line: 0,
                    bomb: 0,
                    sweeper: 0,
                    shard: 0,
                    rocket: 0,
                    spiral: 0
                };

                this.startTime = 0;
                this.countdownActive = false;
                this._mutantBossPhase = null;
                this._mutantBossPrevPhase = null;
                this._mutantBossDeathTriggered = false;
                this.countdownProgress = 0;

                // Tutorial state
                this.tutorialEvents = [];
                this.tutorialStartTime = 0;
                this.tutorialSpawnTimers = {
                    shard: 0,
                    bomb: 0,
                    sweeper: 0,
                    spiral: 0,
                    rocket: 0,
                    mixed: 0
                };

                window.addEventListener('resize', () => this.resize());
                window.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    if (this.countdownActive) {
                        const cursor = document.getElementById('player-cursor');
                        cursor.style.left = (e.clientX - 8) + 'px';
                        cursor.style.top = (e.clientY - 8) + 'px';
                    }
                });
                
                // Gamepad state tracking
                this.gamepadIndex = null;
                this.gamepadDeadzone = 0.15;
                this.gamepadSensitivity = 8;
                
                // Poll for gamepad connections
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    if (this.gamepadIndex === null) {
                        this.gamepadIndex = e.gamepad.index;
                        this.showGamepadNotification(e.gamepad.id);
                    }
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    if (this.gamepadIndex === e.gamepad.index) {
                        this.gamepadIndex = null;
                    }
                });

                window.addEventListener('touchmove', (e) => {
                    // Only block default touch scrolling while gameplay canvas/UI is hidden AND no modal (e.g. level preview) is open.
                    // When the UI is visible (menus/modals), allow normal page scrolling so mobile users can reach controls.
                    const uiLayerEl = document.getElementById('ui-layer');
                    const levelModal = document.getElementById('level-preview-modal');
                    const modalOpen = levelModal && !levelModal.classList.contains('hidden');
                    if (uiLayerEl && uiLayerEl.classList.contains('hidden') && !modalOpen) {
                        e.preventDefault();
                    }

                    // Still update input coordinates
                    if (e.touches && e.touches[0]) {
                        this.mouseX = e.touches[0].clientX;
                        this.mouseY = e.touches[0].clientY;
                    }

                    if (this.countdownActive) {
                        const cursor = document.getElementById('player-cursor');
                        const touch = (e.touches && e.touches[0]) || null;
                        if (touch && cursor) {
                            cursor.style.left = (touch.clientX - 8) + 'px';
                            cursor.style.top = (touch.clientY - 8) + 'px';
                        }
                    }
                }, {passive: false});

                document.body.addEventListener('touchmove', (e) => {
                    // Only block default touch scrolling while gameplay canvas/UI is hidden (i.e. during active gameplay).
                    // When the UI is visible (menus/modals), allow normal page scrolling so menus and long modals can be scrolled on mobile.
                    const uiLayerEl = document.getElementById('ui-layer');
                    const levelModal = document.getElementById('level-preview-modal');
                    const modalOpen = levelModal && !levelModal.classList.contains('hidden');
                    if (uiLayerEl && uiLayerEl.classList.contains('hidden') && !modalOpen) {
                        // gameplay is active ‚Äî prevent page scroll to avoid moving the canvas
                        e.preventDefault();
                    }
                    // otherwise allow the touchmove so menus and long modals can be scrolled on mobile
                }, { passive: false });

                document.getElementById('upload-btn').addEventListener('click', () => document.getElementById('file-input').click());
                
                // Collapsible sections for Game / Customize to keep UI compact
                try {
                    const gameHeader = document.getElementById('game-section-header');
                    const gameContent = document.getElementById('game-section-content');
                    const gameToggle = document.getElementById('game-section-toggle');
                    const customizeHeader = document.getElementById('customize-section-header');
                    const customizeContent = document.getElementById('customize-section-content');
                    const customizeToggle = document.getElementById('customize-section-toggle');

                    // Animated collapse/expand helper using max-height + opacity for smooth transitions.
                    const setCollapsed = (contentEl, toggleEl, collapsed, skipClassToggle) => {
                        if (!contentEl || !toggleEl) return;
                        // ensure styles for animation
                        contentEl.style.overflow = 'hidden';
                        contentEl.style.transition = 'max-height 320ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease';

                        if (collapsed) {
                            // start collapse
                            // if it's currently "auto" (none) set to measured height first so transition runs
                            if (!contentEl.style.maxHeight || contentEl.style.maxHeight === 'none') {
                                contentEl.style.maxHeight = contentEl.scrollHeight + 'px';
                            }
                            // force reflow so transition picks up
                            void contentEl.offsetHeight;
                            contentEl.style.maxHeight = '0px';
                            contentEl.style.opacity = '0';
                            toggleEl.textContent = '‚ñ∫';
                            // mark hidden after animation for accessibility unless caller asks otherwise
                            setTimeout(() => {
                                if (!skipClassToggle) contentEl.classList.add('hidden');
                                // keep maxHeight=0 to represent collapsed state
                            }, 340);
                        } else {
                            // make visible immediately
                            if (!skipClassToggle) contentEl.classList.remove('hidden');
                            // set measured maxHeight to animate
                            contentEl.style.opacity = '1';
                            const target = contentEl.scrollHeight + 'px';
                            contentEl.style.maxHeight = target;
                            toggleEl.textContent = '‚ñº';
                            // when transition completes, clear maxHeight so content can be fluid
                            setTimeout(() => {
                                // only clear if still expanded
                                if (contentEl.style.maxHeight === target) {
                                    contentEl.style.maxHeight = 'none';
                                }
                            }, 360);
                        }
                    };

                    // Initialize layout: Game section is always open on load, Customize section is always collapsed
                    if (gameContent && gameToggle && customizeContent && customizeToggle) {
                        // Ensure initial class state is consistent: Game open, Customize closed
                        setCollapsed(gameContent, gameToggle, false, true);
                        setCollapsed(customizeContent, customizeToggle, true, true);
                        // remove 'none' maxHeight so scrollHeight is correct for measured values
                        gameContent.style.maxHeight = 'none';
                        customizeContent.style.maxHeight = '0px';
                    }

                    // Toggle logic: ensure at least one section remains open; closing an open section will open the other.
                    if (gameHeader && gameContent && gameToggle) {
                        gameHeader.addEventListener('click', () => {
                            const isGameCollapsed = (gameContent.classList.contains('hidden') || gameContent.style.maxHeight === '0px');
                            if (isGameCollapsed) {
                                // open Game, collapse Customize
                                setCollapsed(gameContent, gameToggle, false);
                                setCollapsed(customizeContent, customizeToggle, true);
                            } else {
                                // closing Game -> ensure Customize opens
                                setCollapsed(gameContent, gameToggle, true);
                                setCollapsed(customizeContent, customizeToggle, false);
                            }
                        });
                    }

                    if (customizeHeader && customizeContent && customizeToggle) {
                        customizeHeader.addEventListener('click', () => {
                            const isCustomizeCollapsed = (customizeContent.classList.contains('hidden') || customizeContent.style.maxHeight === '0px');
                            if (isCustomizeCollapsed) {
                                // open Customize, collapse Game
                                setCollapsed(customizeContent, customizeToggle, false);
                                setCollapsed(gameContent, gameToggle, true);
                            } else {
                                // closing Customize -> ensure Game opens
                                setCollapsed(customizeContent, customizeToggle, true);
                                setCollapsed(gameContent, gameToggle, false);
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Collapsible menu init failed', e);
                }

                document.getElementById('file-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if(file) {
                        const btn = document.getElementById('start-btn');
                        const status = document.getElementById('status-msg');
                        status.innerText = "Loading audio...";
                        try {
                            const duration = await this.audio.loadFile(file);
                            await this.analyzeSongDifficulty(file.name, duration);
                            status.innerText = "Ready to rock.";
                            btn.disabled = false;
                            btn.classList.remove('opacity-50');
                            btn.classList.add('start-ready');
                            btn.innerText = 'VIEW LEVEL';
                            this.isCareerMode = false;
                            this.isTutorialMode = false;
                            document.getElementById('track-info').innerText = file.name;
                            this.updateDifficultyDisplay();
                            btn.onclick = () => {
                                this.showSongScreen();
                            };
                        } catch (err) {
                            console.error('Failed to load selected song:', err);
                            status.innerText = "Failed to load audio. Try a different file.";
                            btn.disabled = true;
                            btn.classList.add('opacity-50');
                        }
                    }
                });

                document.getElementById('career-btn').addEventListener('click', () => {
                    this.showCareerModal();
                });

                document.getElementById('garage-btn').addEventListener('click', () => {
                    this.openGarage();
                });

                document.getElementById('lore-book-btn').addEventListener('click', () => {
                    this.openLoreBook();
                });

                document.getElementById('close-lore-book').addEventListener('click', () => {
                    document.getElementById('lore-book-modal').classList.add('hidden');
                });

                document.getElementById('tutorial-btn').addEventListener('click', () => {
                    this.startTutorial();
                });

                document.getElementById('close-garage').addEventListener('click', () => {
                    document.getElementById('garage-modal').classList.add('hidden');
                });

                // Deadly Mode toggle
                const deadlyToggle = document.getElementById('deadly-mode-toggle');
                if (deadlyToggle) {
                    deadlyToggle.addEventListener('change', () => {
                        DEADLY_MODE = deadlyToggle.checked;
                        const checkbox = document.querySelector('.deadly-mode-checkbox');
                        if (DEADLY_MODE) {
                            checkbox.classList.add('deadly-mode-active');
                        } else {
                            checkbox.classList.remove('deadly-mode-active');
                        }
                    });
                }

                const offlineInfoBtn = document.getElementById('offline-info-btn');
                const offlineModal = document.getElementById('offline-modal');
                const closeOfflineBtn = document.getElementById('close-offline-btn');
                const downloadCodeBtn = document.getElementById('download-code-btn');

                if (offlineInfoBtn && offlineModal && closeOfflineBtn && downloadCodeBtn) {
                    offlineInfoBtn.addEventListener('click', () => {
                        offlineModal.classList.remove('hidden');
                    });
                    
                    // Prevent modal from auto-opening on page load
                    offlineModal.classList.add('hidden');
                    closeOfflineBtn.addEventListener('click', () => {
                        offlineModal.classList.add('hidden');
                    });
                    // Helper to add a fetched file into JSZip; returns true if successful.
                    async function addFetchedFileToZip(zip, path, zipPath) {
                        try {
                            const resp = await fetch(path);
                            if (!resp.ok) throw new Error('Failed to fetch ' + path);
                            const blob = await resp.blob();
                            zip.file(zipPath || path.split('/').pop(), blob);
                            return true;
                        } catch (e) {
                            console.warn('Could not include', path, e);
                            return false;
                        }
                    }

                    downloadCodeBtn.addEventListener('click', async () => {
                        try {
                            // Clone the current document
                            const htmlDoc = document.documentElement.cloneNode(true);
                            
                            // Remove the offline modal from the cloned document to prevent auto-open on load
                            const clonedOfflineModal = htmlDoc.querySelector('#offline-modal');
                            if (clonedOfflineModal) {
                                clonedOfflineModal.remove();
                            }
                            
                            // Remove offline info button references from cloned document
                            const clonedOfflineBtn = htmlDoc.querySelector('#offline-info-btn');
                            if (clonedOfflineBtn) {
                                clonedOfflineBtn.parentElement.remove();
                            }
                            
                            // Create zip and include cleaned index.html
                            const zip = new JSZip();
                            const html = '<!DOCTYPE html>\n' + htmlDoc.outerHTML;
                            zip.file('index.html', html);

                            // Offer the zip for download
                            const content = await zip.generateAsync({ type: 'blob' });
                            const url = URL.createObjectURL(content);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'amplitude_assault.zip';
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            setTimeout(() => URL.revokeObjectURL(url), 2000);
                        } catch (e) {
                            console.error('Failed to download code zip:', e);
                        }
                    });

                    const downloadAllBtn = document.getElementById('download-all-btn');
                    if (downloadAllBtn) {
                        downloadAllBtn.addEventListener('click', async () => {
                            try {
                                const zip = new JSZip();
                                
                                // Clone and clean HTML (remove offline modal to prevent auto-open)
                                const htmlDoc = document.documentElement.cloneNode(true);
                                const clonedOfflineModal = htmlDoc.querySelector('#offline-modal');
                                if (clonedOfflineModal) clonedOfflineModal.remove();
                                const clonedOfflineBtn = htmlDoc.querySelector('#offline-info-btn');
                                if (clonedOfflineBtn) clonedOfflineBtn.parentElement.remove();
                                
                                zip.file('index.html', '<!DOCTYPE html>\n' + htmlDoc.outerHTML);

                                // List of built-in assets to include
                                const assets = [
                                    '/Blow It Away.mp3',
                                    '/Digital Masquerade.mp3',
                                    '/Dizzy Carousel.mp3',
                                    '/Mutant.mp3',
                                    '/Tutorial SOng.mp3',
                                    '/MainMenu.wav',
                                    '/Sticks hitting.mp3'
                                ];

                                // Fetch and add each asset (if available)
                                const additions = assets.map(p => addFetchedFileToZip(zip, p, p.split('/').pop()));
                                await Promise.all(additions);

                                // Generate and trigger download
                                const content = await zip.generateAsync({ type: 'blob' });
                                const url = URL.createObjectURL(content);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = 'amplitude_assault_full.zip';
                                document.body.appendChild(a);
                                a.click();
                                a.remove();
                                setTimeout(() => URL.revokeObjectURL(url), 2000);
                            } catch (e) {
                                console.error('Failed to create full download zip:', e);
                            }
                        });
                    }

                    // Lightweight weekly reminder asking about offline play
                    try {
                        const REMIND_DISABLE_KEY = 'sys_download_reminder_disable';
                        const REMIND_LAST_KEY = 'sys_download_reminder_last';
                        const disabled = localStorage.getItem(REMIND_DISABLE_KEY) === '1';
                        if (!disabled) {
                            const last = Number(localStorage.getItem(REMIND_LAST_KEY) || 0);
                            const now = Date.now();
                            const weekMs = 7 * 24 * 60 * 60 * 1000;
                            if (now - last > weekMs) {
                                const remindModal = document.getElementById('download-reminder-modal');
                                if (remindModal) {
                                    const yesBtn = document.getElementById('download-reminder-yes');
                                    const laterBtn = document.getElementById('download-reminder-later');
                                    const neverBtn = document.getElementById('download-reminder-never');
                                    remindModal.classList.remove('hidden');
                                    const closeModal = (opts = {}) => {
                                        remindModal.classList.add('hidden');
                                        if (opts.markSeen) {
                                            localStorage.setItem(REMIND_LAST_KEY, String(now));
                                        }
                                        if (opts.disable) {
                                            localStorage.setItem(REMIND_DISABLE_KEY, '1');
                                        }
                                    };
                                    if (yesBtn) {
                                        yesBtn.onclick = () => {
                                            closeModal({ markSeen: true });
                                            const btn = document.getElementById('offline-info-btn');
                                            if (btn) btn.click();
                                        };
                                    }
                                    if (laterBtn) {
                                        laterBtn.onclick = () => closeModal({ markSeen: true });
                                    }
                                    if (neverBtn) {
                                        neverBtn.onclick = () => closeModal({ markSeen: true, disable: true });
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Download reminder init failed', e);
                    }
                }

                const menuAiToggle = document.getElementById('menu-ai-toggle');
                if (menuAiToggle) {
                    menuAiToggle.checked = false;
                    // demoGame may not be instantiated yet in the script flow; guard accesses.
                    try {
                        if (typeof demoGame !== 'undefined' && demoGame) demoGame.playerVisible = false;
                    } catch (e) { /* ignore */ }
                    // Toggle only the demo player's visibility; do not stop or clear the demo itself
                    menuAiToggle.addEventListener('change', () => {
                        try {
                            if (typeof demoGame !== 'undefined' && demoGame) demoGame.playerVisible = !!menuAiToggle.checked;
                        } catch (e) { /* ignore */ }
                    });
                }

                // Menu music volume slider - controls demo/menu and game audio gain nodes
                const menuMusicSlider = document.getElementById('menu-music-volume');
                if (menuMusicSlider) {
                    // Load saved menu volume
                    const savedMenuVolume = localStorage.getItem('menu_music_volume');
                    if (savedMenuVolume !== null) {
                        menuMusicSlider.value = savedMenuVolume;
                    }

                    const applyVolume = (val) => {
                        const v = Number(val) / 100;
                        try {
                            if (demoGame && demoGame.audio) {
                                if (demoGame.audio.gainNode) demoGame.audio.gainNode.gain.value = v;
                                demoGame.audio.defaultGain = v;
                            }
                        } catch (e) { /* ignore */ }
                        try {
                            if (game && game.audio) {
                                if (game.audio.gainNode) game.audio.gainNode.gain.value = v;
                                game.audio.defaultGain = v;
                            }
                        } catch (e) { /* ignore */ }
                        // Save menu volume to localStorage
                        localStorage.setItem('menu_music_volume', val);
                    };

                    // Apply on input for immediate feedback
                    menuMusicSlider.addEventListener('input', (e) => applyVolume(e.target.value));

                    // If demo audio already initialized, set initial value
                    setTimeout(() => {
                        try {
                            applyVolume(menuMusicSlider.value);
                        } catch (e) {}
                    }, 300);

                    // Graphics quality: High / Medium / Basic
                    try {
                        // Default to HIGH
                        window.GRAPHICS_LEVEL = localStorage.getItem('graphics_quality') || 'HIGH';

                        // Helper to apply graphics level to any existing systems safely
                        function applyGraphicsLevel(level) {
                            // persist choice
                            try { localStorage.setItem('graphics_quality', level); } catch (err) {}
                            window.GRAPHICS_LEVEL = level;

                            // particle systems enabled only on HIGH
                            const enabled = (level === 'HIGH');

                            try {
                                if (typeof demoGame !== 'undefined' && demoGame && demoGame.particleSystem) {
                                    demoGame.particleSystem.enabled = enabled;
                                }
                            } catch (e) {}

                            try {
                                if (typeof game !== 'undefined' && game && game.particleSystem) {
                                    game.particleSystem.enabled = enabled;
                                }
                            } catch (e) {}
                        }

                        const graphicsSelect = document.getElementById('graphics-quality-select');
                        if (graphicsSelect) {
                            // Initialize select UI
                            graphicsSelect.value = window.GRAPHICS_LEVEL;
                            // Apply initial value right away in case demo/game already exist
                            applyGraphicsLevel(window.GRAPHICS_LEVEL);

                            graphicsSelect.addEventListener('change', (e) => {
                                const val = e.target.value || 'HIGH';
                                applyGraphicsLevel(val);
                            });
                        } else {
                            // ensure setting is applied even if the select isn't found yet
                            applyGraphicsLevel(window.GRAPHICS_LEVEL);
                        }

                        // Ensure particle systems pick up default setting if they appear later
                        // (they'll be set again by applyGraphicsLevel when the select is present)
                    } catch (e) {
                        console.warn('Graphics init failed', e);
                    }
                }

                document.getElementById('close-career').addEventListener('click', () => {
                    document.getElementById('career-modal').classList.add('hidden');
                });

                this.updateLevelDisplay();

                // Pause listener
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                        if (this.isRunning && !this.countdownActive && !this.gameHasEnded) {
                            this.togglePause();
                        }
                    }
                });
            }

            togglePause() {
                this.paused = !this.paused;
                if (this.paused) {
                    if (this.audio && this.audio.isPlaying) {
                        this.audio.ctx.suspend();
                    }
                } else {
                    if (this.audio && this.audio.isPlaying) {
                        this.audio.ctx.resume();
                    }
                }
            }

            addFloatingText(x, y, text, color) {
                this.floatingTexts.push(new FloatingText(x, y, text, color));
            }

            async startTutorial() {
                this.isTutorialMode = true;
                this.isCareerMode = false;
                this.isCustomSongBossEligible = false;
                this.currentSongTitle = 'Tutorial: Learn the Basics';
                this.songDifficulty = 'TUTORIAL';
                
                const status = document.getElementById('status-msg');
                status.innerText = "Loading tutorial...";
                
                try {
                    const response = await fetch('/Tutorial SOng.mp3');
                    const blob = await response.blob();
                    const file = new File([blob], 'Tutorial Song.mp3', { type: 'audio/mpeg' });
                    await this.audio.loadFile(file);
                    
                    this.setupTutorialEvents();
                    
                    const btn = document.getElementById('start-btn');
                    btn.disabled = false;
                    btn.classList.remove('opacity-50');
                    btn.classList.add('start-ready');
                    document.getElementById('track-info').innerText = 'Tutorial Mode';
                    this.updateDifficultyDisplay();
                    btn.onclick = () => {
                        btn.innerText = 'VIEW LEVEL';
                        this.showSongScreen();
                    };
                    status.innerText = "Tutorial ready!";
                } catch (e) {
                    console.error('Failed to load tutorial:', e);
                    status.innerText = "Failed to load tutorial. Please try again.";
                }
            }

            async generateTutorialAudio() {
                // Create a 270-second (4.5 minute) silent audio buffer
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioCtx();
                const sampleRate = ctx.sampleRate;
                const duration = 281; // ~4 minutes 41 seconds
                const length = sampleRate * duration;
                
                const audioBuffer = ctx.createBuffer(2, length, sampleRate);
                
                // Generate a simple oscillating tone for tutorial sections
                const leftChannel = audioBuffer.getChannelData(0);
                const rightChannel = audioBuffer.getChannelData(1);
                
                for (let i = 0; i < length; i++) {
                    const time = i / sampleRate;
                    // Create different frequency patterns for different sections
                    let value = 0;
                    
                    // Bass pattern (0-30s)
                    if (time < 30) {
                        value = Math.sin(2 * Math.PI * 80 * time) * 0.3;
                    }
                    // Mid pattern (30-60s)
                    else if (time < 60) {
                        value = Math.sin(2 * Math.PI * 400 * time) * 0.2;
                    }
                    // Treble pattern (60-90s)
                    else if (time < 90) {
                        value = Math.sin(2 * Math.PI * 2000 * time) * 0.15;
                    }
                    // Combined patterns (90-270s)
                    else {
                        const bassWave = Math.sin(2 * Math.PI * 80 * time) * 0.2;
                        const midWave = Math.sin(2 * Math.PI * 400 * time) * 0.15;
                        const trebleWave = Math.sin(2 * Math.PI * 2000 * time) * 0.1;
                        value = bassWave + midWave + trebleWave;
                    }
                    
                    leftChannel[i] = value;
                    rightChannel[i] = value;
                }
                
                if (!this.audio.ctx) this.audio.init();
                this.audio.audioBuffer = audioBuffer;
                
                // Set up tutorial events
                this.setupTutorialEvents();
            }

            setupTutorialEvents() {
                // Legacy structure kept for compatibility; tutorial now uses continuous spawns by time range.
                this.tutorialEvents = [];
                // Spawn timers for continuous tutorial phases
                this.tutorialSpawnTimers = {
                    shard: 0,
                    bomb: 0,
                    sweeper: 0,
                    spiral: 0,
                    rocket: 0,
                    mixed: 0
                };
            }

            updateDifficultyDisplay() {
                const difficultyEl = document.getElementById('selected-difficulty');
                if (this.songDifficulty && this.songDifficulty !== 'AUTO') {
                    const diffClass = `difficulty-${this.songDifficulty.replace(/\+/g, '-PLUS')}`;
                    difficultyEl.innerHTML = `<span class="difficulty-badge ${diffClass}">${this.songDifficulty}</span>`;
                    difficultyEl.classList.remove('hidden');
                } else {
                    difficultyEl.classList.add('hidden');
                }
            }

            async analyzeSongDifficulty(filename, duration) {
                // Custom songs are eligible for dynamic bosses
                this.isCustomSongBossEligible = true;
                const cleanName = filename.replace(/\.[^/.]+$/, "");
                
                if (duration < 10) {
                    this.songDifficulty = 'AUTO';
                    this.currentSongTitle = 'Practice Run';
                    return;
                }

                // Analyze the actual audio data for better difficulty assessment
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Calculate expected projectile density
                const estimatedBassHits = duration * 2; // ~2 bass hits per second
                const estimatedMidHits = duration * 1.5;
                const estimatedTrebleHits = duration * 10; // treble spawns frequently
                const totalProjectiles = estimatedBassHits + estimatedMidHits + estimatedTrebleHits;
                
                // Difficulty based on projectile density and duration
                let difficultyScore = (totalProjectiles / duration) / 2; // projectiles per second
                
                // Duration multiplier
                if (duration > 240) difficultyScore *= 1.8;
                else if (duration > 180) difficultyScore *= 1.5;
                else if (duration > 120) difficultyScore *= 1.3;
                else if (duration > 60) difficultyScore *= 1.1;
                
                // Assign difficulty tier
                if (difficultyScore < 3) this.songDifficulty = 'EASY';
                else if (difficultyScore < 5) this.songDifficulty = 'MEDIUM';
                else if (difficultyScore < 7) this.songDifficulty = 'HARD';
                else if (difficultyScore < 9) this.songDifficulty = 'CHALLENGER';
                else if (difficultyScore < 12) this.songDifficulty = 'INSANE';
                else if (difficultyScore < 15) this.songDifficulty = 'EXPERT';
                else if (difficultyScore < 18) this.songDifficulty = 'EXPERT+';
                else this.songDifficulty = 'EXPERT++';

                // Generate song category name based on difficulty
                const categories = {
                    'EASY': [
                        'Gentle Breeze', 'Calm Waters', 'Morning Sun', 'Peaceful Valley', 'Quiet Stream',
                        'Soft Whisper', 'Lazy Afternoon', 'Starlit Night', 'Meadow Walk', 'Tranquil Dawn',
                        'Sweet Dreams', 'Lullaby', 'Easy Ride', 'Smooth Sailing', 'Light Steps',
                        'Cozy Fire', 'Garden Path', 'Butterfly Dance', 'Feather Fall', 'Cloud Nine',
                        'Sunshine Day', 'Spring Rain', 'Dewdrop', 'Tender Moments', 'Warm Embrace'
                    ],
                    'MEDIUM': [
                        'Rising Tide', 'Gathering Storm', 'Mountain Trail', 'Ocean Waves', 'Forest Run',
                        'City Lights', 'Night Drive', 'River Rapids', 'Desert Wind', 'Thunder Rolls',
                        'Lightning Flash', 'Neon Dreams', 'Urban Beat', 'Skyline Rush', 'Voltage Rise',
                        'Pulse Drive', 'Chrome Highway', 'Digital Rain', 'Speed Demon', 'Power Surge',
                        'Electric Soul', 'Turbo Charge', 'Nitro Boost', 'Afterburner', 'Sonic Boom'
                    ],
                    'HARD': [
                        'Raging Inferno', 'Cyclone Strike', 'Avalanche Drop', 'Seismic Shift', 'Volcano Eruption',
                        'Tidal Wave', 'Meteor Shower', 'Black Hole', 'Supernova', 'Chaos Theory',
                        'Destruction', 'Annihilation', 'Devastation', 'Cataclysm', 'Armageddon',
                        'Apocalypse', 'Doomsday', 'Scorched Earth', 'Hellfire', 'Infernal'
                    ],
                    'CHALLENGER': [
                        'Dimension Breaker', 'Reality Tear', 'Void Walker', 'Time Collapse', 'Space Ripper',
                        'Quantum Chaos', 'Singularity', 'Event Horizon', 'Cosmic Horror', 'Universe End',
                        'Eternal Darkness', 'Infinite Loop', 'Paradox Engine', 'Fractal Nightmare', 'Warp Speed',
                        'Hyperspace', 'Multiverse', 'Otherworld', 'Beyond Limits', 'Transcendence',
                        'Ascension', 'Godmode', 'Omnipotent', 'Unstoppable', 'Invincible'
                    ],
                    'INSANE': [
                        'Mind Shatter', 'Sanity Break', 'Psycho Killer', 'Delirium', 'Madness Descent',
                        'Fever Dream', 'Hallucination', 'Paranoia', 'Hysteria', 'Frenzy',
                        'Berserker', 'Bloodlust', 'Rampage', 'Carnage', 'Massacre',
                        'Slaughter', 'Butcher', 'Ripper', 'Maniac', 'Lunatic',
                        'Psychopath', 'Twisted', 'Deranged', 'Corrupted', 'Possessed'
                    ],
                    'EXPERT': [
                        'Death Wish', 'Suicide Mission', 'Last Stand', 'Final Hour', 'Judgment Day',
                        'Grim Reaper', 'Angel of Death', 'Executioner', 'Harbinger', 'Omen',
                        'Prophecy', 'Destiny', 'Fate Sealed', 'No Escape', 'Game Over',
                        'The End', 'Finality', 'Conclusion', 'Termination', 'Cessation',
                        'Omega', 'Epilogue', 'Curtain Call', 'Swan Song', 'Requiem'
                    ],
                    'EXPERT+': [
                        'Impossible Dream', 'Beyond Human', 'Superhuman', 'Legendary', 'Mythical',
                        'Divine Challenge', 'God Tier', 'Celestial', 'Immortal', 'Eternal',
                        'Supreme', 'Ultimate', 'Absolute', 'Perfect', 'Flawless',
                        'Pristine', 'Immaculate', 'Untouchable', 'Unreachable', 'Unbeatable',
                        'Insurmountable', 'Unconquerable', 'Indomitable', 'Invulnerable', 'Unbreakable'
                    ],
                    'EXPERT++': [
                        'Singularity Point', 'Heat Death', 'Big Crunch', 'Reality Collapse', 'Existence Void',
                        'Nothingness', 'Oblivion Gate', 'Entropy End', 'Zero Point', 'Null Space',
                        'Dark Matter', 'Anti-Life', 'DeathItself', 'Pure Chaos', 'Infinite Death',
                        'Endless Suffering', 'Eternal Torment', 'Perpetual Pain', 'Permanent End', 'Final Death',
                        'True Oblivion', 'Complete Erasure', 'Total Annihilation', 'Absolute Zero', 'The Void'
                    ]
                };
                
                const categoryList = categories[this.songDifficulty] || categories['MEDIUM'];
                const hash = cleanName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const categoryName = categoryList[hash % categoryList.length];
                
                this.currentSongTitle = `${categoryName}: ${cleanName}`;
            }

            async showCareerModal() {
                const modal = document.getElementById('career-modal');
                const container = document.getElementById('career-songs');
                container.innerHTML = '';

                // Slot selector header
                const slotHeader = document.createElement('div');
                slotHeader.className = 'mb-4 p-3 border border-cyan-500/40 rounded-lg bg-black/40 space-y-2';

                const titleRow = document.createElement('div');
                titleRow.className = 'flex items-center justify-between';
                titleRow.innerHTML = `
                    <span class="text-xs font-semibold text-cyan-300 tracking-[0.15em] uppercase">Save Slots</span>
                    <span class="text-[0.65rem] text-gray-400">Each slot has its own progress & difficulty</span>
                `;
                slotHeader.appendChild(titleRow);

                const slotsRow = document.createElement('div');
                slotsRow.className = 'grid grid-cols-1 sm:grid-cols-3 gap-2 mt-2';

                this.careerSlots.forEach((slot, idx) => {
                    const slotDiv = document.createElement('div');
                    const isActive = idx === this.currentCareerSlot;
                    slotDiv.className = `p-2 rounded border text-xs cursor-pointer ${
                        isActive ? 'border-cyan-400 bg-cyan-400/10' : 'border-gray-700 bg-gray-900'
                    }`;

                    const completedCount = (slot.completed || []).filter(Boolean).length;
                    const total = this.careerSongs.length;

                    slotDiv.innerHTML = `
                        <div class="flex items-center justify-between mb-1">
                            <span class="font-semibold text-cyan-200">Slot ${idx + 1}</span>
                            <div class="flex items-center gap-2">
                                <span class="text-[0.65rem] text-gray-400">${completedCount}/${total} cleared</span>
                                <button data-reset-slot="${idx}" class="px-2 py-0.5 text-[0.6rem] border border-red-400 text-red-300 rounded hover:bg-red-400 hover:text-black transition-colors">RESET</button>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-[0.65rem] text-gray-400">Difficulty</span>
                            <select data-slot-index="${idx}" class="bg-black border border-cyan-500 rounded px-1 py-0.5 text-[0.65rem]">
                                <option value="EASY"${slot.difficulty === 'EASY' ? ' selected' : ''}>Easy</option>
                                <option value="MEDIUM"${slot.difficulty === 'MEDIUM' ? ' selected' : ''}>Medium</option>
                                <option value="HARD"${slot.difficulty === 'HARD' ? ' selected' : ''}>Hard</option>
                            </select>
                        </div>
                    `;

                    slotDiv.addEventListener('click', () => {
                        this.currentCareerSlot = idx;
                        setCareerDifficulty(this.careerSlots[idx].difficulty || 'MEDIUM');
                        this.saveCareer();
                        this.showCareerModal(); // re-render for active styling
                    });

                    slotsRow.appendChild(slotDiv);
                });

                slotHeader.appendChild(slotsRow);
                container.appendChild(slotHeader);

                // Check if all non-locked songs are completed in current slot to unlock Mutant
                const currentSlot = this.careerSlots[this.currentCareerSlot] || { completed: [] };
                const regularSongs = this.careerSongs.filter(s => !s.locked);
                const allCompleted = regularSongs.every((_, idx) => currentSlot.completed[idx]);

                if (allCompleted) {
                    const mutantSong = this.careerSongs.find(s => s.locked);
                    if (mutantSong) mutantSong.locked = false;
                }

                this.careerSongs.forEach((song, idx) => {
                    const div = document.createElement('div');
                    const slotCompleted = !!(currentSlot.completed && currentSlot.completed[idx]);

                    if (song.locked) {
                        div.className = 'p-4 bg-gray-900 border-2 border-gray-800 rounded-lg opacity-50';
                        div.innerHTML = `
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 class="text-xl font-bold text-gray-600">??? LOCKED ???</h3>
                                    <p class="text-sm text-gray-600">Complete all missions in this slot to unlock</p>
                                </div>
                                <span class="ml-2 px-2 py-1 bg-red-500 text-black text-xs rounded">LOCKED</span>
                            </div>
                        `;
                    } else {
                        div.className = 'p-4 bg-gray-800 border-2 border-gray-700 rounded-lg hover:border-cyan-400 transition-all cursor-pointer';
                        div.style.boxShadow = '0 0 8px rgba(34, 211, 238, 0.3)';
                        
                        const statusBadge = slotCompleted
                            ? '<span class="ml-2 px-2 py-1 bg-green-500 text-black text-xs rounded" style="box-shadow: 0 0 8px #00ff41;">COMPLETED</span>'
                            : '';
                        
                        div.innerHTML = `
                            <div class="flex items-center justify-between mb-2">
                                <div>
                                    <h3 class="text-xl font-bold text-white" style="text-shadow: 0 0 8px currentColor;">${song.title}</h3>
                                    <p class="text-sm text-gray-400 mt-1">${song.path.split('/').pop()}</p>
                                </div>
                                ${statusBadge}
                            </div>
                            <p class="text-xs story-text mt-2">${song.story}</p>
                        `;
                        
                        div.onclick = async () => {
                            modal.classList.add('hidden');
                            document.getElementById('status-msg').innerText = "Loading career song...";
                            
                            try {
                                const response = await fetch(song.path);
                                const blob = await response.blob();
                                const file = new File([blob], song.path.split('/').pop(), { type: 'audio/mpeg' });
                                
                                await this.audio.loadFile(file);
                                this.currentSongTitle = song.title;
                                this.songDifficulty = '';
                                this.isCareerMode = true;
                                this.isCustomSongBossEligible = false;
                                this.isMutantBoss = !!(song.title === 'Mutant' || (song.path && song.path.toLowerCase().includes('mutant')));
                                this.isTutorialMode = false;
                                this.currentCareerSong = song;
                                this.currentCareerSongIndex = idx;
                                
                                document.getElementById('status-msg').innerText = "Ready to rock.";
                                document.getElementById('track-info').innerText = `Career: Slot ${this.currentCareerSlot + 1} ‚Äî ${song.title} [${CAREER_DIFFICULTY}]`;
                                this.updateDifficultyDisplay();
                                const btn = document.getElementById('start-btn');
                                btn.disabled = false;
                                btn.classList.remove('opacity-50');
                                btn.classList.add('start-ready');
                                btn.onclick = () => {
                                    btn.innerText = 'VIEW LEVEL';
                                    this.showSongScreen();
                                };
                            } catch (error) {
                                console.error('Failed to load career song:', error);
                                document.getElementById('status-msg').innerText = "Failed to load song. Please try another.";
                                modal.classList.remove('hidden');
                            }
                        };
                    }
                    
                    container.appendChild(div);
                });

                // Wire difficulty dropdowns (after elements exist)
                const selects = container.querySelectorAll('select[data-slot-index]');
                selects.forEach(sel => {
                    // Make selects more touch-friendly: increase tap area and prevent parent click from stealing events
                    sel.style.minWidth = sel.style.minWidth || '96px';
                    sel.style.touchAction = sel.style.touchAction || 'auto';
                    sel.style.webkitAppearance = sel.style.webkitAppearance || 'menulist-button';
                    sel.style.pointerEvents = sel.style.pointerEvents || 'auto';
                    
                    // Prevent the parent slot div click from firing when interacting with the select on touch devices
                    const stopBubble = (ev) => { ev.stopPropagation && ev.stopPropagation(); };
                    sel.addEventListener('pointerdown', stopBubble, { passive: true });
                    sel.addEventListener('touchstart', stopBubble, { passive: true });
                    sel.addEventListener('mousedown', stopBubble, { passive: true });
                    sel.addEventListener('click', stopBubble, { passive: true });

                    sel.addEventListener('change', (e) => {
                        const idx = Number(e.target.dataset.slotIndex || 0);
                        const val = e.target.value;
                        if (!this.careerSlots[idx]) return;
                        this.careerSlots[idx].difficulty = (val === 'EASY' || val === 'HARD') ? val : 'MEDIUM';
                        if (idx === this.currentCareerSlot) {
                            setCareerDifficulty(this.careerSlots[idx].difficulty);
                        }
                        this.saveCareer();
                    });
                });

                // Wire reset buttons (per-slot)
                const resetButtons = container.querySelectorAll('button[data-reset-slot]');
                resetButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const idx = Number(btn.getAttribute('data-reset-slot') || 0);
                        if (!this.careerSlots[idx]) return;
                        this.careerSlots[idx].completed = [];
                        this.careerSlots[idx].difficulty = 'MEDIUM';
                        if (idx === this.currentCareerSlot) {
                            setCareerDifficulty('MEDIUM');
                        }
                        this.saveCareer();
                        this.showCareerModal();
                    });
                });

                modal.classList.remove('hidden');
            }

            loadProfile() {
                try {
                    const raw = localStorage.getItem('sys_profile_v1');
                    if (raw) {
                        const data = JSON.parse(raw);
                        if (typeof data.level === 'number' && typeof data.exp === 'number' && typeof data.expToNext === 'number') {
                            this.profile = { ...this.profile, ...data };
                            // Ensure valid skin
                            if (!PLAYER_SKINS.find(s => s.id === this.profile.currentSkin)) {
                                this.profile.currentSkin = 'orb';
                            }
                        }
                    }
                } catch (e) {
                    // ignore
                }
            }

            loadCareer() {
                try {
                    const raw = localStorage.getItem('sys_career_slots_v1');
                    if (raw) {
                        const data = JSON.parse(raw);
                        if (Array.isArray(data) && data.length === 3) {
                            this.careerSlots = data.map((slot, idx) => ({
                                id: idx,
                                difficulty: (slot.difficulty === 'EASY' || slot.difficulty === 'HARD' || slot.difficulty === 'MEDIUM') ? slot.difficulty : 'MEDIUM',
                                completed: Array.isArray(slot.completed) ? slot.completed : []
                            }));
                            // Use first slot's difficulty as current
                            setCareerDifficulty(this.careerSlots[0].difficulty);
                            this.currentCareerSlot = 0;
                        }
                    } else {
                        // Backward compat: old schema with per-song completion
                        const legacyRaw = localStorage.getItem('sys_career_v1');
                        if (legacyRaw) {
                            const legacy = JSON.parse(legacyRaw);
                            if (Array.isArray(legacy)) {
                                this.careerSlots[0].completed = legacy.map(s => !!s.completed);
                                setCareerDifficulty(this.careerSlots[0].difficulty);
                                this.currentCareerSlot = 0;
                            }
                        }
                    }
                } catch (e) {
                    // ignore
                }
            }

            saveCareer() {
                try {
                    localStorage.setItem('sys_career_slots_v1', JSON.stringify(this.careerSlots));
                    localStorage.setItem('sys_career_difficulty', CAREER_DIFFICULTY);
                } catch (e) {
                    // ignore
                }
            }

            saveProfile() {
                try {
                    localStorage.setItem('sys_profile_v1', JSON.stringify(this.profile));
                } catch (e) {
                    // ignore
                }
            }

            gainExp(amount) {
                if (amount <= 0) return;
                this.profile.exp += amount;

                let leveledUp = false;
                while (this.profile.exp >= this.profile.expToNext) {
                    this.profile.exp -= this.profile.expToNext;
                    this.profile.level += 1;
                    this.profile.expToNext = Math.floor(this.profile.expToNext * 1.25 + 250);
                    leveledUp = true;
                }

                if (leveledUp) {
                    this.triggerShake(12);
                    this.player.setLevel(this.profile.level);
                    this.showLevelUpNotification();
                }

                this.saveProfile();
                this.updateLevelDisplay();
            }

            updateLevelDisplay() {
                const levelEl = document.getElementById('level-display');
                const profileEl = document.getElementById('profile-info');
                levelEl.innerText = this.profile.level;
                if (profileEl) {
                    profileEl.innerText = `PROFILE LVL ${this.profile.level} ‚Äî EXP ${Math.floor(this.profile.exp)} / ${this.profile.expToNext}`;
                }
                
                // Update garage level display
                const gLevel = document.getElementById('garage-level-display');
                const gExp = document.getElementById('garage-xp-display');
                if (gLevel) gLevel.innerText = `LVL ${this.profile.level}`;
                if (gExp) gExp.innerText = `EXP ${Math.floor(this.profile.exp)} / ${this.profile.expToNext}`;
            }

            openLoreBook() {
                const modal = document.getElementById('lore-book-modal');
                modal.classList.remove('hidden');
            }

            openGarage() {
                const modal = document.getElementById('garage-modal');
                const grid = document.getElementById('skins-grid');
                grid.innerHTML = '';
                
                const previewCanvas = document.getElementById('garage-preview-canvas');
                const pCtx = previewCanvas.getContext('2d');
                const currentLevel = this.profile.level;
                const currentTheme = this.player.colorThemes[Math.min(this.player.colorThemes.length - 1, Math.max(0, currentLevel - 1))];

                let previewRotation = 0;

                const drawPreview = (skinId) => {
                    pCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    
                    // Simple glow
                    pCtx.save();
                    pCtx.translate(previewCanvas.width/2, previewCanvas.height/2);
                    
                    // Rotate directional skins for preview
                    const needsRotation = ['viper', 'ninja', 'nova'].includes(skinId);
                    if (needsRotation) {
                        previewRotation += 0.02;
                        pCtx.rotate(previewRotation);
                    }
                    
                    // Draw skin
                    const skin = PLAYER_SKINS.find(s => s.id === skinId);
                    if (skin) {
                        pCtx.shadowBlur = 20;
                        pCtx.shadowColor = currentTheme.ringColor;
                        skin.draw(pCtx, 0, 0, 40, currentTheme.ringColor, currentTheme.coreColor);
                    }
                    
                    pCtx.restore();
                };

                // Animate preview
                let previewInterval = null;
                const startPreviewAnimation = (skinId) => {
                    if (previewInterval) clearInterval(previewInterval);
                    previewRotation = 0;
                    previewInterval = setInterval(() => drawPreview(skinId), 1000/30);
                };

                const stopPreviewAnimation = () => {
                    if (previewInterval) {
                        clearInterval(previewInterval);
                        previewInterval = null;
                    }
                };

                // Draw initial preview
                startPreviewAnimation(this.profile.currentSkin);

                PLAYER_SKINS.forEach(skin => {
                    const isLocked = currentLevel < skin.unlockLevel;
                    const isSelected = skin.id === this.profile.currentSkin;
                    
                    const slot = document.createElement('div');
                    slot.className = `skin-slot ${isSelected ? 'selected' : ''} ${isLocked ? 'locked' : ''}`;
                    
                    // Mini canvas for icon
                    const iconCanvas = document.createElement('canvas');
                    iconCanvas.width = 64;
                    iconCanvas.height = 64;
                    iconCanvas.className = 'skin-icon';
                    const iCtx = iconCanvas.getContext('2d');
                    
                    // Draw icon
                    iCtx.translate(32, 32);
                    if (isLocked) {
                        // Draw lock
                        iCtx.fillStyle = '#666';
                        iCtx.font = '24px Arial';
                        iCtx.textAlign = 'center';
                        iCtx.textBaseline = 'middle';
                        iCtx.fillText('üîí', 0, 0);
                        iCtx.font = '10px Arial';
                        iCtx.fillText(`LVL ${skin.unlockLevel}`, 0, 20);
                    } else {
                        // Draw shape
                        skin.draw(iCtx, 0, 0, 20, isSelected ? '#a855f7' : '#888', isSelected ? '#d8b4fe' : '#444');
                    }
                    
                    slot.appendChild(iconCanvas);
                    
                    if (!isLocked) {
                        slot.onclick = () => {
                            // Update selection
                            this.profile.currentSkin = skin.id;
                            this.player.setSkin(skin.id);
                            this.saveProfile();
                            
                            // Update demo player too if visible
                            if (typeof demoGame !== 'undefined') {
                                demoGame.player.setSkin(skin.id);
                            }
                            
                            // Redraw UI
                            document.querySelectorAll('.skin-slot').forEach(s => s.classList.remove('selected'));
                            slot.classList.add('selected');
                            
                            // Redraw icon with active colors
                            iCtx.clearRect(-32, -32, 64, 64);
                            skin.draw(iCtx, 0, 0, 20, '#a855f7', '#d8b4fe');
                            
                            // Reset other icons (simple redraw of whole grid might be cleaner but this is faster)
                            this.openGarage(); // Reload grid to reset colors
                        };
                        
                        // Hover preview
                        slot.onmouseenter = () => {
                            startPreviewAnimation(skin.id);
                        };
                    }

                    // Tooltip
                    slot.title = `${skin.name} (Lvl ${skin.unlockLevel})`;
                    
                    grid.appendChild(slot);
                });

                // Reset preview on mouse leave grid
                grid.onmouseleave = () => {
                    startPreviewAnimation(this.profile.currentSkin);
                };

                // Cleanup interval when modal closes
                const closeBtn = document.getElementById('close-garage');
                const originalClose = closeBtn.onclick;
                closeBtn.onclick = () => {
                    stopPreviewAnimation();
                    if (originalClose) originalClose();
                    modal.classList.add('hidden');
                };

                modal.classList.remove('hidden');
            }

            updateCombo() {
                const comboContainer = document.getElementById('combo-container');
                const comboDisplay = document.getElementById('combo-display');
                const comboMultiplier = document.getElementById('combo-multiplier');
                const comboMeterFill = document.getElementById('combo-meter-fill');
                
                if (this.combo >= 5) {
                    comboContainer.classList.remove('hidden');
                    comboDisplay.innerText = this.combo;
                    
                    const multiplier = Math.min(Math.floor(this.combo / 10) + 1, 5);
                    comboMultiplier.innerText = `(${multiplier}x SCORE)`;
                    
                    // Update combo meter fill (0-100 combo = 0-100%)
                    const fillPct = Math.min(100, this.combo);
                    if (comboMeterFill) {
                        comboMeterFill.style.width = fillPct + '%';
                        
                        // Change color based on combo level
                        if (this.combo >= 100) {
                            comboMeterFill.style.background = 'linear-gradient(90deg, #a855f7, #ec4899)';
                        } else if (this.combo >= 50) {
                            comboMeterFill.style.background = 'linear-gradient(90deg, #f59e0b, #ec4899)';
                        } else if (this.combo >= 25) {
                            comboMeterFill.style.background = 'linear-gradient(90deg, #22d3ee, #f59e0b)';
                        } else {
                            comboMeterFill.style.background = 'linear-gradient(90deg, #fbbf24, #ec4899)';
                        }
                    }
                    
                    // Shake animation on combo increase
                    comboContainer.classList.remove('combo-shake');
                    void comboContainer.offsetWidth; // Force reflow
                    comboContainer.classList.add('combo-shake');
                } else {
                    comboContainer.classList.add('hidden');
                    if (comboMeterFill) {
                        comboMeterFill.style.width = '0%';
                    }
                }
            }

            incrementCombo() {
                this.combo++;
                this.comboTimer = 180; // 3 seconds at 60fps
                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }
                
                // Milestone rewards
                if (this.combo === 10 || this.combo === 25 || this.combo === 50 || this.combo === 100) {
                    this.triggerComboMilestone(this.combo);
                }
                
                this.updateCombo();
            }

            resetCombo() {
                // Combo no longer resets on damage - it just stops growing
                // Keep current combo value intact
            }
            
            triggerComboMilestone(milestone) {
                // Visual feedback
                this.triggerShake(15);
                const comboContainer = document.getElementById('combo-container');
                if (comboContainer) {
                    comboContainer.style.animation = 'none';
                    setTimeout(() => {
                        comboContainer.style.animation = 'comboPopIn 0.5s ease-out, comboShake 0.3s ease-out 0.2s';
                    }, 10);
                }
                
                // Audio feedback - play a power-up sound
                try {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioCtx();
                    const duration = 0.3;
                    const sampleRate = ctx.sampleRate;
                    const buffer = ctx.createBuffer(1, duration * sampleRate, sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Rising tone
                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / sampleRate;
                        const freq = 400 + (milestone * 5);
                        const envelope = Math.exp(-t * 6);
                        data[i] = Math.sin(2 * Math.PI * freq * t) * envelope * 0.3;
                    }
                    
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    const gainNode = ctx.createGain();
                    gainNode.gain.value = 0.4;
                    source.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    source.start(0);
                } catch (e) {
                    console.error('Failed to play milestone sound:', e);
                }
                
                // Temporary buffs based on milestone
                if (milestone >= 25) {
                    this.comboSpeedBoost = 1.15; // 15% speed boost
                    this.comboGraceRadius = 5; // Extra hitbox tolerance
                }
                if (milestone >= 50) {
                    this.comboSpeedBoost = 1.25; // 25% speed boost
                    this.comboGraceRadius = 8;
                }
                if (milestone >= 100) {
                    this.comboSpeedBoost = 1.4; // 40% speed boost
                    this.comboGraceRadius = 12;
                }
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                // Remove reduced resolution scaling - use 1:1
                this.canvasScale = 1;
                this.canvas.width = this.width * this.canvasScale;
                this.canvas.height = this.height * this.canvasScale;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';
                if (this.visualizer) {
                    this.visualizer.setSize(this.canvas.width, this.canvas.height);
                }
            }

            async showSongScreen() {
                // Open level preview modal instead
                await this.showLevelPreview();
            }

            async showLevelPreview() {
                const modal = document.getElementById('level-preview-modal');
                const coverArt = document.getElementById('level-cover-art');
                const titleEl = document.getElementById('level-preview-title');
                const difficultyEl = document.getElementById('level-preview-difficulty');
                const descriptionEl = document.getElementById('level-preview-description');
                const sidebarPreview = document.getElementById('sidebar-preview');
                const volumeSlider = document.getElementById('level-volume-slider');
                const volumeDisplay = document.getElementById('volume-display');
                const playBtn = document.getElementById('play-level-btn');
                const backBtn = document.getElementById('back-from-preview-btn');
                
                // Create live preview canvas for the level
                let previewCanvas = document.getElementById('level-preview-canvas');
                if (!previewCanvas) {
                    previewCanvas = document.createElement('canvas');
                    previewCanvas.id = 'level-preview-canvas';
                    previewCanvas.width = 540;
                    previewCanvas.height = 960;
                    previewCanvas.style.width = '100%';
                    previewCanvas.style.height = '100%';
                    previewCanvas.style.display = 'block';
                    previewCanvas.style.borderRadius = '8px';
                }
                const pctx = previewCanvas.getContext('2d');
                
                // Preview state
                const previewState = {
                    running: false,
                    player: { x: 270, y: 680, r: 3, visualR: 15 },
                    shards: [],
                    rockets: [],
                    spirals: [],
                    lines: [],
                    bombs: [],
                    sweepers: [],
                    boss: null,
                    customBossManager: null,
                    visualizer: createVisualizer(540, 960),
                    particleSystem: new ParticleSystem(),
                    lastSpawn: 0,
                    particles: [] // Rising intimidation particles
                };
                
                // Check if this song has a boss
                const hasBoss = this.isMutantBoss || (this.isCustomSongBossEligible && !this.isCareerMode && !this.isTutorialMode);
                
                if (this.isMutantBoss) {
                    previewState.boss = new Boss(540, 960);
                    previewState.boss.setState('attack');
                    previewState.boss.setBuffLevel(1);
                } else if (hasBoss) {
                    previewState.customBossManager = new CustomBossManager({ width: 540, height: 960, player: previewState.player, shards: previewState.shards, rockets: previewState.rockets, spirals: previewState.spirals });
                    // Force spawn a random boss immediately for preview
                    previewState.customBossManager.spawnBoss();
                }
                
                const graphicsLevel = window.GRAPHICS_LEVEL || 'HIGH';
                
                // Rising particles for intimidation (only on MEDIUM and HIGH)
                const spawnRisingParticles = () => {
                    if (graphicsLevel === 'BASIC') return;
                    const now = performance.now();
                    if (now - (previewState.lastParticleSpawn || 0) > 50) {
                        for (let i = 0; i < 2; i++) {
                            previewState.particles.push({
                                x: Math.random() * 540,
                                y: 960 + Math.random() * 100,
                                vy: -0.5 - Math.random() * 1.5,
                                size: 2 + Math.random() * 4,
                                alpha: 0.3 + Math.random() * 0.4
                            });
                        }
                        previewState.lastParticleSpawn = now;
                    }
                };
                
                const updatePreview = () => {
                    if (!previewState.running) return;
                    
                    const now = performance.now();
                    const dt = 0.016;
                    
                    // Update audio analysis
                    if (this.audio && this.audio.isPlaying) {
                        this.audio.update();
                        if (previewState.visualizer) {
                            previewState.visualizer.update(this.audio.dataArray, this.audio.volume || 0);
                        }
                    }
                    
                    // Spawn rising particles
                    spawnRisingParticles();
                    
                    // Update rising particles
                    for (let i = previewState.particles.length - 1; i >= 0; i--) {
                        const p = previewState.particles[i];
                        p.y += p.vy;
                        p.alpha -= 0.002;
                        if (p.alpha <= 0 || p.y < -50) {
                            previewState.particles.splice(i, 1);
                        }
                    }
                    
                    // Simple spawning for preview
                    if (now - previewState.lastSpawn > 800) {
                        const roll = Math.random();
                        if (roll < 0.3) {
                            const x = Math.random() * 540;
                            const angle = Math.atan2(previewState.player.y, previewState.player.x - x);
                            previewState.shards.push(new Shard(x, -10, angle, 2.5 * getSpeedFactor()));
                        } else if (roll < 0.5) {
                            previewState.rockets.push(new Rocket());
                            if (previewState.rockets.length > 0) {
                                previewState.rockets[previewState.rockets.length - 1].x = Math.random() * 540;
                                previewState.rockets[previewState.rockets.length - 1].y = -20;
                            }
                        } else if (roll < 0.7) {
                            const s = new Spiral();
                            s.x = Math.random() * 540;
                            s.y = Math.random() * 200;
                            previewState.spirals.push(s);
                        }
                        previewState.lastSpawn = now;
                    }
                    
                    // Update entities
                    previewState.shards = previewState.shards.filter(s => s.active);
                    previewState.shards.forEach(s => s.update());
                    
                    previewState.rockets = previewState.rockets.filter(r => r.active);
                    previewState.rockets.forEach(r => r.update());
                    
                    previewState.spirals = previewState.spirals.filter(s => s.active);
                    previewState.spirals.forEach(s => s.update());
                    
                    // Update boss
                    if (previewState.boss) {
                        previewState.boss.update({ width: 540, height: 960, player: previewState.player, shards: previewState.shards, rockets: previewState.rockets, spirals: previewState.spirals, triggerShake: () => {}, particleSystem: previewState.particleSystem }, dt, this.audio ? this.audio.getCurrentTime() : 0, {
                            enableRadial: true,
                            enableFan: true,
                            enableSpiral: true,
                            enableRockets: true,
                            isIntroOnly: false,
                            isEasyPhase: false,
                            enableShockwave: true
                        });
                    } else if (previewState.customBossManager && previewState.customBossManager.activeBoss) {
                        previewState.customBossManager.activeBoss.update(dt);
                    }
                    
                    // Render
                    pctx.save();
                    pctx.fillStyle = '#000';
                    pctx.fillRect(0, 0, 540, 960);
                    
                    // Background gradient
                    const bassGlow = (this.audio?.bass || 0) * 100;
                    const midGlow = (this.audio?.mid || 0) * 100;
                    const trebleGlow = (this.audio?.treble || 0) * 100;
                    const gradient = pctx.createRadialGradient(270, 480, 0, 270, 480, 600);
                    gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                    gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                    pctx.fillStyle = gradient;
                    pctx.fillRect(0, 0, 540, 960);
                    
                    if (previewState.visualizer) {
                        previewState.visualizer.render(pctx);
                    }
                    
                    pctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                    pctx.fillRect(0, 0, 540, 960);
                    
                    // Draw rising particles (thick grey transparent)
                    if (graphicsLevel !== 'BASIC') {
                        pctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
                        for (const p of previewState.particles) {
                            pctx.globalAlpha = p.alpha;
                            pctx.beginPath();
                            pctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            pctx.fill();
                        }
                        pctx.globalAlpha = 1;
                    }
                    
                    // Draw entities
                    previewState.shards.forEach(s => s.draw(pctx));
                    previewState.rockets.forEach(r => r.draw(pctx));
                    previewState.spirals.forEach(s => s.draw(pctx));
                    
                    // Draw boss
                    if (previewState.boss) {
                        previewState.boss.draw(pctx);
                    } else if (previewState.customBossManager && previewState.customBossManager.activeBoss) {
                        previewState.customBossManager.activeBoss.draw(pctx);
                    }
                    
                    pctx.restore();
                    
                    requestAnimationFrame(updatePreview);
                };
                
                // Replace cover art with live preview canvas
                coverArt.innerHTML = '';
                coverArt.appendChild(previewCanvas);
                
                // Start preview loop
                previewState.running = true;
                updatePreview();
                
                // Initialize preview slider from last chosen volume
                if (typeof this.previewVolume === 'number') {
                    const initialVal = Math.round(this.previewVolume * 100);
                    volumeSlider.value = initialVal;
                    volumeDisplay.innerText = `${initialVal}%`;
                }

                // Stop demo music and hide UI with smooth fade
                const uiLayer = document.getElementById('ui-layer');
                uiLayer.style.transition = 'opacity 0.5s';
                uiLayer.style.opacity = '0';
                
                await demoGame.fadeOutDemo();
                
                await new Promise(resolve => setTimeout(resolve, 500));
                uiLayer.classList.add('hidden');
                uiLayer.style.opacity = '1';
                
                // Show modal with fade in
                modal.style.opacity = '0';
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.style.opacity = '1';
                }, 50);
                
                // Start playing the song at low volume for preview
                try {
                    if (this.audio && this.audio.audioBuffer) {
                        const vol = (typeof this.previewVolume === 'number') ? this.previewVolume : 0.5;
                        this.audio.gainNode.gain.value = vol;
                        this.audio.defaultGain = vol;
                        this.audio.play(0);
                    }
                } catch (e) {
                    console.error('Failed to start preview audio:', e);
                }
                
                // Volume slider control
                const updateVolume = () => {
                    const vol = Number(volumeSlider.value) / 100;
                    volumeDisplay.innerText = volumeSlider.value + '%';
                    this.previewVolume = vol;
                    if (this.audio) {
                        // Apply immediately during preview
                        if (this.audio.gainNode) {
                            this.audio.gainNode.gain.value = vol;
                        }
                        // Persist as default gain so gameplay starts at the same volume
                        this.audio.defaultGain = vol;
                    }
                };
                volumeSlider.oninput = updateVolume;
                
                // Initialize preview volume on modal open (independent of menu slider)
                if (typeof this.previewVolume === 'number') {
                    const initialVol = this.previewVolume;
                    if (this.audio && this.audio.gainNode) {
                        this.audio.gainNode.gain.value = initialVol;
                    }
                    if (this.audio) {
                        this.audio.defaultGain = initialVol;
                    }
                }
                
                // Set initial title and difficulty
                titleEl.innerText = this.currentSongTitle || 'Custom Song';
                
                // Only show difficulty badge for non-career modes
                if (this.isCareerMode) {
                    difficultyEl.innerHTML = '';
                } else if (this.songDifficulty && this.songDifficulty !== 'AUTO') {
                    const diffClass = `difficulty-${this.songDifficulty.replace(/\+/g, '-PLUS')}`;
                    difficultyEl.innerHTML = `<span class="difficulty-badge ${diffClass}">${this.songDifficulty}</span>`;
                } else {
                    difficultyEl.innerHTML = '';
                }
                
                // If career mode, show the story from careerSongs
                if (this.isCareerMode && this.currentCareerSong && this.currentCareerSong.story) {
                    descriptionEl.innerHTML = `<p class="story-text">${this.currentCareerSong.story}</p>`;
                } else {
                    descriptionEl.innerText = 'Generating level information...';
                }
                
                coverArt.innerHTML = '<div class="spinner w-12 h-12 border-4 border-cyan-400 border-t-transparent rounded-full"></div>';
                
                // Generate procedural cover art and pick description
                // (Originally planned to use AI generation, but since most players will download and play offline, we pre-generate everything)
                const difficulty = this.songDifficulty || 'MEDIUM';
                
                // Generate procedural pixel art thumbnail
                const thumbnailCanvas = document.createElement('canvas');
                thumbnailCanvas.width = 25;
                thumbnailCanvas.height = 25;
                const tctx = thumbnailCanvas.getContext('2d');
                
                // Define color palettes for each difficulty
                const colorPalettes = {
                    'EASY': ['#90EE90', '#98FB98', '#00FF7F', '#00FA9A', '#7FFF00'],
                    'MEDIUM': ['#FFD700', '#FFA500', '#FF8C00', '#FF7F50', '#FF6347'],
                    'HARD': ['#DC143C', '#B22222', '#8B0000', '#FF0000', '#FF4500'],
                    'CHALLENGER': ['#8B008B', '#9932CC', '#BA55D3', '#9370DB', '#8A2BE2'],
                    'INSANE': ['#FF0000', '#8B0000', '#DC143C', '#B22222', '#A52A2A'],
                    'EXPERT': ['#4B0082', '#483D8B', '#6A5ACD', '#7B68EE', '#9370DB'],
                    'EXPERT+': ['#FF1493', '#C71585', '#DB7093', '#FF69B4', '#FFB6C1'],
                    'EXPERT++': ['#000000', '#1C1C1C', '#2F2F2F', '#3A3A3A', '#4F4F4F'],
                    'TUTORIAL': ['#00CED1', '#00BFFF', '#1E90FF', '#4169E1', '#6495ED']
                };
                
                const palette = colorPalettes[difficulty] || colorPalettes['MEDIUM'];
                
                // Generate random pixel pattern
                const seed = this.currentSongTitle.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                const rng = (s) => {
                    s = Math.sin(s) * 10000;
                    return s - Math.floor(s);
                };
                
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 25; x++) {
                        const idx = (y * 25 + x + seed) % palette.length;
                        const colorIdx = Math.floor(rng(seed + x * 7 + y * 13) * palette.length);
                        tctx.fillStyle = palette[colorIdx];
                        tctx.fillRect(x, y, 1, 1);
                    }
                }
                
                const thumbnailDataUrl = thumbnailCanvas.toDataURL();
                coverArt.innerHTML = `<img src="${thumbnailDataUrl}" class="w-full h-full rounded-lg" alt="Level Cover" style="image-rendering: pixelated; object-fit: cover;">`;
                
                // If not career mode, pick a random pre-made description
                if (!this.isCareerMode || !this.currentCareerSong || !this.currentCareerSong.story) {
                    const descriptions = {
                        'EASY': [
                            'A gentle introduction to the rhythm. Let the music guide your movements and find your flow.',
                            'Ease into the beat with this relaxing starter level. Perfect for learning the ropes.',
                            'Smooth sailing ahead! This level will help you warm up and get comfortable.',
                            'Take it slow and steady. Master the basics before diving into harder challenges.',
                            'A peaceful journey through sound. Enjoy the ride and build your confidence.',
                            'Light and breezy patterns to get you started. Feel the rhythm, find your groove.',
                            'Start your journey here. Simple patterns, endless possibilities.',
                            'Your first step into audio chaos. Welcome to the rhythm realm!',
                            'Calm waters and gentle beats await. Perfect for beginners.',
                            'An easy-going challenge to test your reflexes without overwhelming you.',
                            'Soft patterns dance across the screen. Follow them and survive.',
                            'A welcoming introduction to bullet hell rhythm. You got this!',
                            'Relaxing beats meet simple patterns. The perfect starting point.',
                            'Gentle projectiles and forgiving timing. Learn the fundamentals here.',
                            'Your training grounds. Master these patterns before moving on.',
                            'Smooth rhythms and predictable patterns. Build your foundation.',
                            'A beginner-friendly challenge that eases you into the chaos.',
                            'Start slow, learn fast. This level teaches you everything you need.',
                            'Simple yet satisfying. Master the basics with style.',
                            'Your journey begins here. Take your time and enjoy the music.',
                            'Easy patterns, hard fun. The perfect warm-up level.',
                            'Gentle introduction to the madness. Welcome aboard!',
                            'Straightforward patterns meet chill vibes. Perfect for practice.',
                            'Learn the ropes without the pressure. This is your safe space.',
                            'A calm beginning to an intense journey. Start here and grow.'
                        ],
                        'MEDIUM': [
                            'The difficulty ramps up! Expect faster projectiles and tighter patterns.',
                            'Things are heating up. Stay focused and keep moving!',
                            'A solid challenge for intermediate players. Test your skills here.',
                            'The rhythm intensifies. Can you keep up with the beat?',
                            'Moderate chaos with room to breathe. Perfect for honing your reflexes.',
                            'Patterns grow complex, but victory is within reach. Stay sharp!',
                            'The real challenge begins. Are you ready to prove yourself?',
                            'Fast-paced action meets strategic dodging. Show us what you got!',
                            'Medium difficulty, maximum fun. Push your limits here.',
                            'The training wheels are off. Time to show your true potential.',
                            'Balanced chaos that rewards skill and precision. Rise to the challenge!',
                            'Projectiles multiply and patterns overlap. Stay calm and survive.',
                            'A true test of your rhythm skills. Can you handle the heat?',
                            'The beat demands respect. Match its intensity or fall behind.',
                            'Intermediate chaos with unforgiving patterns. Prove your worth!',
                            'Speed and precision unite in this adrenaline-pumping level.',
                            'The difficulty curve hits its stride. Adapt or perish!',
                            'Complex patterns emerge from the music. Dance through the danger!',
                            'Your skills will be tested. Only the focused will survive.',
                            'A perfect balance of challenge and reward. Push forward!',
                            'The rhythm accelerates. Keep pace or get overwhelmed.',
                            'Moderate mayhem with intense moments. Stay alert!',
                            'Patterns interweave in beautiful chaos. Navigate with precision.',
                            'The music demands more. Give it everything you have!',
                            'A stepping stone to mastery. Overcome this and ascend.'
                        ],
                        'HARD': [
                            'Brutal patterns and relentless projectiles. Only the skilled survive.',
                            'The gloves are off. Expect no mercy from this intense challenge.',
                            'Fast, chaotic, and unforgiving. Can you handle the pressure?',
                            'Projectile hell unleashed. Every second tests your limits.',
                            'The difficulty spikes hard. Precision is your only weapon.',
                            'Overwhelming patterns rain down. Survive through pure skill.',
                            'This level punishes mistakes. Stay sharp or fall fast.',
                            'Chaos reigns supreme. Navigate the storm or be consumed.',
                            'Your reflexes will be pushed to their absolute limit.',
                            'Unrelenting assault from all angles. Survive if you can.',
                            'The beat becomes your enemy. Fight back with flawless dodging.',
                            'Explosive patterns and tight corridors. Death waits around every corner.',
                            'A true hard mode experience. Only masters need apply.',
                            'Projectiles multiply exponentially. Can your reflexes keep up?',
                            'The music accelerates into madness. Match its pace or perish.',
                            'Every moment demands perfection. One mistake could end it all.',
                            'Patterns overlap in beautiful destruction. Find the gaps and survive.',
                            'The difficulty soars. Only the dedicated will overcome this.',
                            'Relentless chaos with zero forgiveness. Prove your mastery here.',
                            'Speed, precision, and endurance all tested at once. Rise up!',
                            'A hurricane of projectiles. Navigate the storm with skill.',
                            'The beat becomes a weapon. Deflect its assault with perfect timing.',
                            'Hard mode cranked to eleven. Survive this and claim glory.',
                            'Every second is a battle. Fight through the chaos!',
                            'The ultimate test of skill. Only the best will see the end.'
                        ],
                        'CHALLENGER': [
                            'Beyond human limits. Can you transcend the impossible?',
                            'Patterns so complex they defy comprehension. Good luck.',
                            'This level challenges reality itself. Survive if you dare.',
                            'The music warps space and time. Navigate the impossible.',
                            'Challenger difficulty: where legends are forged or broken.',
                            'Patterns evolve mid-flight. Adapt or die instantly.',
                            'The beat shatters all logic. Embrace the chaos.',
                            'Projectiles move in impossible patterns. Trust your instincts.',
                            'This level exists to break you. Will you break first?',
                            'Reality bends under the weight of this challenge. Survive.',
                            'The music has gone mad. Dance with the insanity.',
                            'Patterns from beyond this dimension. Can you comprehend them?',
                            'Challenger mode: where skill meets the supernatural.',
                            'The impossible made real. Conquer it and transcend.',
                            'Chaos refined into an art form. Master it or perish.',
                            'This level laughs at your previous accomplishments. Prove yourself again.',
                            'The beat evolves faster than you can react. Keep up anyway.',
                            'Patterns designed to overwhelm the strongest players. Survive.',
                            'Beyond hard mode lies this nightmare. Welcome to hell.',
                            'The music demands the impossible. Deliver it anyway.',
                            'Challenger difficulty: because hard mode was too easy.',
                            'Projectiles rain from dimensions unknown. Navigate the void.',
                            'The beat transcends mortal understanding. Match it anyway.',
                            'This is where gods are tested. Will you ascend or fall?',
                            'The ultimate challenge awaits. Only the legendary survive.'
                        ],
                        'INSANE': [
                            'Madness incarnate. The patterns make no sense. Survive anyway.',
                            'Insane difficulty: where sanity goes to die.',
                            'The music screams in chaos. Scream back and survive.',
                            'Projectiles spawn from your nightmares. Face them head-on.',
                            'This level breaks minds. Will yours hold?',
                            'Insanity given form. Can you navigate pure chaos?',
                            'The beat loses all structure. Find order in the madness.',
                            'Patterns overlap into incomprehensible chaos. Survive through instinct.',
                            'This level is psychological warfare. Keep your composure.',
                            'The music has gone mad. Dance with the insanity.',
                            'Chaos without reason. Patterns without logic. Survive without hope.',
                            'Your mind will rebel against this challenge. Overcome it.',
                            'Insane mode: the final test before the impossible.',
                            'Projectiles spawn in impossible formations. Trust nothing.',
                            'The beat fractures reality. Navigate the broken pieces.',
                            'This level exists to shatter you. Prove it wrong.',
                            'Madness and music merge into one. Survive the fusion.',
                            'Patterns designed by madmen for madmen. Join them or die.',
                            'The music abandons all rhythm. Find your own beat.',
                            'Insane difficulty where even the game questions itself.',
                            'Chaos reigns eternal. Your only weapon is instinct.',
                            'The level has lost its mind. Keep yours intact.',
                            'Projectiles move in fever-dream patterns. Wake up and survive.',
                            'This is what happens when music goes insane. Survive it.',
                            'The final challenge before true mastery. Break through the madness.'
                        ],
                        'EXPERT': [
                            'Expert mode: the realm of masters. Prove your legend status.',
                            'Perfect execution required. One mistake means death.',
                            'The music demands mastery. Can you deliver?',
                            'Expert patterns designed to filter out the weak. Rise above.',
                            'This level respects only the elite. Earn your place.',
                            'Precision, speed, and endurance tested to their limits.',
                            'Expert difficulty where legends prove themselves daily.',
                            'The beat becomes your judge. Perform flawlessly or fail.',
                            'Patterns crafted for those who have transcended normal play.',
                            'Expert mode: where good players become great.',
                            'The music shows no mercy. Neither should you.',
                            'Master-level patterns await. Only the skilled need apply.',
                            'This level separates experts from pretenders. Which are you?',
                            'Perfect timing, perfect movement, perfect survival. Achieve it.',
                            'Expert difficulty where every frame counts. Make them all count.',
                            'The pinnacle of skill-based challenge. Climb to the top.',
                            'Patterns so refined they\'re works of art. Master the masterpiece.',
                            'Expert mode demands respect. Give it through perfect play.',
                            'The beat tests your limits. Exceed them.',
                            'This level was built for champions. Prove you belong.',
                            'Expert patterns flow like water. Become fluid and survive.',
                            'Mastery is not optional here. It\'s required.',
                            'The music challenges the very best. Answer that challenge.',
                            'Expert difficulty: the gateway to true greatness.',
                            'Perfect play or no play. Choose perfection.'
                        ],
                        'EXPERT+': [
                            'Beyond expert lies this nightmare. Can you survive?',
                            'Expert+ mode: where legends come to train.',
                            'The difficulty transcends normal measurement. Face the unknown.',
                            'Patterns so advanced they seem impossible. Prove otherwise.',
                            'Expert+ challenges the very definition of skill. Redefine it.',
                            'The music pushes beyond all limits. Push back harder.',
                            'This level exists in the space between possible and impossible.',
                            'Expert+ difficulty: because expert wasn\'t enough.',
                            'Patterns designed to humble even the greatest. Stay humble and survive.',
                            'The beat demands more than perfection. Give it anyway.',
                            'This is where experts become legends. Make the leap.',
                            'Expert+ mode tests everything you thought you knew. Learn more.',
                            'The difficulty curve breaks into vertical here. Climb anyway.',
                            'Patterns evolve beyond comprehension. Comprehend them anyway.',
                            'Expert+ challenges your very existence. Exist defiantly.',
                            'The music laughs at your expert status. Laugh back and win.',
                            'This level was designed to be impossible. Make it possible.',
                            'Expert+ mode: the final hurdle before the absolute.',
                            'Patterns from the edge of possibility. Navigate that edge.',
                            'The beat becomes your greatest enemy. Befriend it and survive.',
                            'Expert+ difficulty where heroes are tested. Prove your heroism.',
                            'This level respects only the absolute best. Be the best.',
                            'The music demands the impossible. You demand victory.',
                            'Expert+ mode: the proving grounds of champions.',
                            'Beyond this lies only madness. Conquer this first.'
                        ],
                        'EXPERT++': [
                            'The absolute pinnacle. Nothing harder exists. Survive if you can.',
                            'Expert++ mode: where gods are tested and broken.',
                            'The final challenge. The ultimate test. The impossible made real.',
                            'Patterns from beyond existence. Navigate the void itself.',
                            'Expert++ difficulty transcends all understanding. Understand it anyway.',
                            'This is the end. The final boss. The ultimate truth.',
                            'The music achieves sentience and declares war. Fight back.',
                            'Expert++ mode: because even Expert+ wasn\'t enough for you.',
                            'Patterns designed to be impossible. You exist to prove them wrong.',
                            'The absolute limit of difficulty. Exceed it anyway.',
                            'This level kills gods. Will you join them or surpass them?',
                            'Expert++ challenges existence itself. Exist harder.',
                            'The final test before true mastery. Pass and transcend.',
                            'Patterns from the end of time. Survive beyond time.',
                            'Expert++ mode where reality bends to the music. Bend with it.',
                            'The ultimate difficulty for the ultimate player. Are you?',
                            'This level was designed to be unbeatable. Beat it anyway.',
                            'Expert++ difficulty: the absolute peak of challenge.',
                            'The music becomes one with chaos. Become one with victory.',
                            'This is the final wall. Break through or break trying.',
                            'Expert++ mode where legends become myths. Become a myth.',
                            'The absolute end of all difficulty. The beginning of mastery.',
                            'Patterns that defy physics and logic. Defy them back.',
                            'Expert++ difficulty: you wanted the hardest. Here it is.',
                            'The final challenge. The ultimate test. The end and the beginning.'
                        ],
                        'TUTORIAL': [
                            'Learn the basics of survival. Master dodging, reading patterns, and staying alive.',
                            'Welcome to Amplitude Assault! This tutorial will teach you everything you need.',
                            'Start here to learn the ropes. Each section introduces a new mechanic.',
                            'Your training begins now. Follow the prompts and survive to the end.',
                            'Tutorial mode: where everyone starts. Learn well and thrive.',
                            'Master the fundamentals here before facing real challenges.',
                            'A guided tour through the mechanics. Pay attention and survive.',
                            'Learn by doing. This tutorial teaches through experience.',
                            'Your first steps into bullet hell rhythm. We\'ll guide you through it.',
                            'Tutorial mode designed to prepare you for the chaos ahead.',
                            'Start your journey here. Learn the patterns, master the timing.',
                            'A comprehensive introduction to all game mechanics. Study well.',
                            'Tutorial difficulty: learn without the pressure of failure.',
                            'Every mechanic explained through practice. Complete this to understand the game.',
                            'Your training ground. Master these lessons and face the real challenges.',
                            'Tutorial mode teaches you to survive. Listen, learn, and live.',
                            'Learn the dance of dodging. This tutorial shows you how.',
                            'A step-by-step guide to surviving bullet hell. Follow closely.',
                            'Tutorial difficulty where mistakes are learning opportunities.',
                            'Master the basics here. The real challenges await beyond.',
                            'Your first lesson in survival. Pay attention and thrive.',
                            'Tutorial mode: from zero to hero in one song.',
                            'Learn the patterns, understand the timing, survive the chaos.',
                            'This tutorial prepares you for everything. Complete it to unlock your potential.',
                            'Welcome, student. Your education in rhythm survival begins now.'
                        ],
                        'AUTO': [
                            'Survive the onslaught of audio-reactive projectiles in this intense rhythm challenge. Master the patterns and prove your reflexes!',
                            'The music controls the chaos. Adapt to the rhythm and survive!',
                            'Dynamic difficulty based on the song. Stay alert!',
                            'Every song is unique. Can you handle the unknown?',
                            'Audio-reactive patterns await. Trust your instincts!'
                        ]
                    };
                    
                    const difficultyDescriptions = descriptions[difficulty] || descriptions['AUTO'];
                    const randomIndex = Math.floor(rng(seed + 1000) * difficultyDescriptions.length);
                    descriptionEl.innerText = difficultyDescriptions[randomIndex];
                }
                
                // Use local procedural thumbnail + premade descriptions (NO AI)
                // Ensure the procedural thumbnail is shown (fallback to the generated 25x25 canvas)
                coverArt.innerHTML = `<img src="${thumbnailDataUrl}" class="w-full h-full rounded-lg" alt="Level Cover" style="image-rendering: pixelated; object-fit: cover;">`;

                // Also mirror a compact version of this info in the left sidebar so you can see it in the normal menu layout
                if (sidebarPreview) {
                    const diffLabel = difficultyEl.innerHTML || '';
                    sidebarPreview.innerHTML = `
                        <div class="mt-3 p-3 border border-cyan-500/40 rounded-lg bg-black/40 space-y-2">
                            <div class="flex items-center gap-3">
                                <div class="w-12 h-12 rounded overflow-hidden border border-cyan-400 flex-shrink-0">
                                    <img src="${thumbnailDataUrl}" class="w-full h-full" style="image-rendering: pixelated; object-fit: cover;" alt="">
                                </div>
                                <div class="flex-1">
                                    <div class="text-sm font-semibold text-cyan-300 truncate">${this.currentSongTitle || 'Selected Track'}</div>
                                    <div class="text-[0.7rem] text-gray-400 mt-0.5">${this.isCareerMode ? 'Career Mission' : 'Custom Track'}</div>
                                </div>
                            </div>
                            <div class="text-[0.7rem] text-gray-400">
                                ${diffLabel}
                            </div>
                        </div>
                    `;
                }
                
                // Developer note (not shown in-game):
                // AI generation was removed to keep the game fully offline ‚Äî covers and descriptions use local presets and procedural thumbnails.
                
                // Play button starts the actual game
                playBtn.onclick = async () => {
                    // Fade out modal
                    modal.style.opacity = '0';
                    await new Promise(resolve => setTimeout(resolve, 500));
                    modal.classList.add('hidden');
                    
                    // Stop preview audio
                    if (this.audio && this.audio.isPlaying) {
                        this.audio.stop();
                    }
                    
                    // Start countdown
                    this.startCountdown();
                };

                // Add a Download Song button for the preview (exports current audioBuffer to WAV)
                const downloadSongBtn = document.createElement('button');
                downloadSongBtn.className = 'px-6 py-3 bg-transparent border-2 border-emerald-400 text-emerald-400 hover:bg-emerald-400 hover:text-black transition-all duration-200 rounded-lg glow-button';
                downloadSongBtn.innerText = 'Download Song';
                downloadSongBtn.style.marginRight = '8px';
                downloadSongBtn.onclick = () => {
                    if (!this.audio || !this.audio.audioBuffer) return;
                    
                    // Export AudioBuffer to WAV Blob
                    function makeWav(audioBuffer) {
                        const numOfChannels = audioBuffer.numberOfChannels;
                        const sampleRate = audioBuffer.sampleRate;
                        const format = 1; // PCM
                        const bitsPerSample = 16;

                        // interleave
                        const channels = [];
                        for (let i = 0; i < numOfChannels; i++) channels.push(audioBuffer.getChannelData(i));
                        const length = audioBuffer.length * numOfChannels * (bitsPerSample / 8);
                        const buffer = new ArrayBuffer(44 + length);
                        const view = new DataView(buffer);

                        function writeString(view, offset, string) {
                            for (let i = 0; i < string.length; i++) {
                                view.setUint8(offset + i, string.charCodeAt(i));
                            }
                        }

                        let offset = 0;

                        // RIFF identifier 'RIFF'
                        writeString(view, offset, 'RIFF'); offset += 4;
                        view.setUint32(offset, 36 + length, true); offset += 4;
                        writeString(view, offset, 'WAVE'); offset += 4;
                        writeString(view, offset, 'fmt '); offset += 4;
                        view.setUint32(offset, 16, true); offset += 4;
                        view.setUint16(offset, format, true); offset += 2;
                        view.setUint16(offset, numOfChannels, true); offset += 2;
                        view.setUint32(offset, sampleRate, true); offset += 4;
                        view.setUint32(offset, sampleRate * numOfChannels * (bitsPerSample / 8), true); offset += 4;
                        view.setUint16(offset, numOfChannels * (bitsPerSample / 8), true); offset += 2;
                        view.setUint16(offset, bitsPerSample, true); offset += 2;
                        writeString(view, offset, 'data'); offset += 4;
                        view.setUint32(offset, length, true); offset += 4;

                        // Write interleaved PCM samples
                        const interleaved = new Int16Array(length / 2);
                        let idx = 0;
                        for (let i = 0; i < audioBuffer.length; i++) {
                            for (let ch = 0; ch < numOfChannels; ch++) {
                                const sample = Math.max(-1, Math.min(1, channels[ch][i]));
                                interleaved[idx++] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                            }
                        }

                        for (let i = 0; i < interleaved.length; i++) {
                            view.setInt16(offset, interleaved[i], true);
                            offset += 2;
                        }

                        return new Blob([view], { type: 'audio/wav' });
                    }

                    try {
                        const blob = makeWav(this.audio.audioBuffer);
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = (this.currentSongTitle ? this.currentSongTitle.replace(/\s+/g,'_') : 'preview') + '.wav';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(() => URL.revokeObjectURL(url), 2000);
                    } catch (e) {
                        console.error('Failed to export audio for download:', e);
                    }
                };

                // Insert the download button next to Play in the modal controls
                const controlsRow = playBtn.parentElement;
                if (controlsRow) {
                    controlsRow.insertBefore(downloadSongBtn, playBtn);
                }
                
                // Back button returns to menu
                backBtn.onclick = async () => {
                    // Stop preview loop
                    previewState.running = false;
                    
                    // Stop preview audio
                    if (this.audio && this.audio.isPlaying) {
                        this.audio.stop();
                    }
                    
                    // Fade out modal
                    modal.style.opacity = '0';
                    await new Promise(resolve => setTimeout(resolve, 500));
                    modal.classList.add('hidden');
                    
                    // Show UI and restart demo
                    uiLayer.classList.remove('hidden');

                    // Ensure sidebar and demo area fade back in correctly (fixes black screen after Back)
                    const menuSidebar = document.getElementById('menu-sidebar');
                    const demoContainer = document.getElementById('demo-container');
                    if (menuSidebar) {
                        menuSidebar.style.opacity = '1';
                    }
                    if (demoContainer) {
                        demoContainer.style.opacity = '1';
                        demoContainer.style.display = '';
                    }

                    demoGame.resumeDemo();
                };
            }

            async startCountdown() {
                // Fade out demo
                await demoGame.fadeOutDemo();
                
                // Hide UI layer
                document.getElementById('ui-layer').classList.add('hidden');
                
                // Configure game for countdown state
                this.countdownActive = true;
                this.countdownProgress = 0;
                this.startSequenceActive = false;
                this.startSequenceTimer = 0;
                this.gameScale = 0.6; // Start zoomed out
                this.targetGameScale = 0.6;
                this.isRunning = true;
                this.gameHasEnded = false;
                
                // Reset basic game state for visibility (player, background)
                this.player.health = this.player.maxHealth;
                this.player.x = this.width / 2;
                this.player.y = this.height / 2;
                this.player.isDying = false;
                this.player.deathProgress = 0;
                
                // Clear any enemies/projectiles
                this.shards = [];
                this.lines = [];
                this.bombs = [];
                this.sweepers = [];
                this.spirals = [];
                this.rockets = [];
                if (this.boss) this.boss.setState('hidden');
                if (this.customBossManager) this.customBossManager.reset();
                
                // Re-initialize visualizer so grid is ready
                if (!this.visualizer) this.visualizer = createVisualizer(this.width, this.height);
                this.visualizer.setSize(this.width, this.height);
                
                // Ensure audio is stopped or muted for countdown
                if (this.audio && this.audio.isPlaying) this.audio.stop();
                
                // Start the main loop to render the hover screen
                this.loop();
            }

            start() {
                // Transition from countdown to game
                this.countdownActive = false;
                this.targetGameScale = 1.0; // Zoom in to normal
                
                // Pick layout
                pickRandomLayout();
                
                // Clean up UI - remove any existing game over buttons
                const existingBackBtn = document.getElementById('back-menu-btn');
                if (existingBackBtn) existingBackBtn.remove();
                
                // Show HUD
                const hud = document.getElementById('hud');
                if (hud) hud.classList.remove('hidden');

                // Show deadly mode indicator if active
                const deadlyIndicator = document.getElementById('deadly-mode-indicator');
                if (deadlyIndicator) {
                    if (DEADLY_MODE) deadlyIndicator.classList.remove('hidden');
                    else deadlyIndicator.classList.add('hidden');
                }
                
                // Reset game logic state
                this.score = 0;
                this.lastScore = 0;
                this.combo = 0;
                this.maxCombo = 0;
                this.comboTimer = 0;
                this.lastDamageTime = performance.now();
                this.checkpoints = [];
                
                this._mutantBossPhase = null;
                this._mutantBossPrevPhase = null;
                this._mutantBossDeathTriggered = false;
                if (this.isMutantBoss) {
                    this.boss = new Boss(this.width, this.height);
                    this.boss.setState('hidden');
                    this.boss.setBuffLevel(1);
                } else {
                    this.boss = null;
                }
                
                // Clear checkpoint markers
                const progressTrack = document.getElementById('song-progress-track');
                if (progressTrack) {
                    const markers = progressTrack.querySelectorAll('.absolute.bg-pink-500.opacity-70');
                    markers.forEach(m => m.remove());
                }

                this.updateHealth();
                this.updateCombo();

                this.startTime = performance.now();
                this.lastFrameTime = performance.now();
                this.tutorialStartTime = performance.now();

                // Reset replay recording
                this.replayFrames = [];
                this.replayIndex = 0;

                this.player.setLevel(this.profile.level);
                this.updateLevelDisplay();
                
                // Start audio
                if (this.audio) {
                    const vol = (typeof this.previewVolume === 'number') ? this.previewVolume : 0.5;
                    this.audio.defaultGain = vol;
                    this.audio.play();
                }
            }

            async playDeathAnimation() {
                this.player.initDeathAnimation();
                
                // Play shatter sound using Web Audio API
                try {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioCtx();
                    
                    // Create a shatter sound effect
                    const duration = 0.5;
                    const sampleRate = ctx.sampleRate;
                    const buffer = ctx.createBuffer(1, duration * sampleRate, sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Generate noise with decreasing frequency (glass shattering effect)
                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / sampleRate;
                        const envelope = Math.exp(-t * 8); // Quick decay
                        const noise = (Math.random() * 2 - 1) * envelope;
                        const tone = Math.sin(2 * Math.PI * (1000 - t * 800) * t) * envelope * 0.3;
                        data[i] = noise * 0.7 + tone;
                    }
                    
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    const gainNode = ctx.createGain();
                    gainNode.gain.value = 0.4;
                    source.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    source.start(0);
                } catch (e) {
                    console.error('Failed to play death sound:', e);
                }
                
                // Animate death over 2 seconds
                const deathDuration = 2000;
                const deathStart = performance.now();

                // Vibrate device for the duration of the death animation (if available)
                try {
                    if (navigator && typeof navigator.vibrate === 'function') {
                        // Some browsers throttle very long vibrations; still request full duration and ensure we stop at end.
                        navigator.vibrate(deathDuration);
                    }
                } catch (e) {
                    // ignore vibration errors
                }
                
                return new Promise(resolve => {
                    const animateDeath = () => {
                        const elapsed = performance.now() - deathStart;
                        this.player.deathProgress = Math.min(elapsed / deathDuration, 1);
                        
                        // Continue rendering during death animation
                        if (!this.player.isDying) return;
                        
                        this.ctx.save();
                        
                        const intensity = this.audio.volume;
                        const bassGlow = this.audio.bass * 100;
                        const midGlow = this.audio.mid * 100;
                        const trebleGlow = this.audio.treble * 100;
                        
                        const gradient = this.ctx.createRadialGradient(
                            this.width / 2, this.height / 2, 0,
                            this.width / 2, this.height / 2, Math.max(this.width, this.height)
                        );
                        gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                        gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(0, 0, this.width, this.height);

                        this.visualizer.render(this.ctx);

                        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                        this.ctx.fillRect(0, 0, this.width, this.height);

                        this.player.draw(this.ctx);
                        
                        this.ctx.restore();
                        
                        if (this.player.deathProgress < 1) {
                            requestAnimationFrame(animateDeath);
                        } else {
                            // Ensure we stop any ongoing vibration when the animation finishes
                            try {
                                if (navigator && typeof navigator.vibrate === 'function') {
                                    navigator.vibrate(0);
                                }
                            } catch (e) {}
                            resolve();
                        }
                    };
                    animateDeath();
                });
            }

            async gameOver(reason = "Destroyed") {
                // Stop live game loop so score/EXP and progress stop updating
                if (this.gameHasEnded) return;
                this.gameHasEnded = true;
                this.isRunning = false;

                if (this.player.isDying) return; // Prevent multiple death triggers
                
                // Only play death animation if player died (health <= 0)
                if (this.player.health <= 0) {
                    // Pause game but keep rendering
                    const wasRunning = this.isRunning;
                    this.isRunning = false;
                    
                    // Fade out audio (only if still playing)
                    if (this.audio && this.audio.isPlaying) {
                        await this.audio.fadeOut(500);
                        this.audio.stop();
                    }
                    
                    // Play death animation
                    await this.playDeathAnimation();
                    
                    // Fade to black
                    const fadeOverlay = document.createElement('div');
                    fadeOverlay.style.position = 'fixed';
                    fadeOverlay.style.inset = '0';
                    fadeOverlay.style.backgroundColor = 'black';
                    fadeOverlay.style.opacity = '0';
                    fadeOverlay.style.transition = 'opacity 1.5s';
                    fadeOverlay.style.zIndex = '30';
                    document.body.appendChild(fadeOverlay);
                    
                    // Trigger fade
                    setTimeout(() => {
                        fadeOverlay.style.opacity = '1';
                    }, 50);
                    
                    // Wait for fade to complete
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    // Remove overlay after showing game over screen
                    fadeOverlay.remove();
                }

                // Ensure any pre-game countdown UI is hidden and demo visuals are restored
                const countdownScreen = document.getElementById('countdown-screen');
                if (countdownScreen) countdownScreen.classList.add('hidden');
                const playerCursor = document.getElementById('player-cursor');
                if (playerCursor) playerCursor.classList.add('hidden');
                const demoContainer = document.getElementById('demo-container');
                if (demoContainer) {
                    // restore visibility and opacity so the demo area is shown again
                    demoContainer.style.display = '';
                    demoContainer.style.opacity = '1';
                }
                const ui = document.getElementById('ui-layer');
                if (ui) ui.classList.remove('hidden');
                const hud = document.getElementById('hud');
                if (hud) hud.classList.add('hidden');

                // Try to resume the demo visuals/audio if available to avoid a black menu
                try {
                    if (typeof demoGame !== 'undefined' && demoGame && !demoGame.isRunning) {
                        demoGame.resumeDemo();
                    }
                } catch (e) {
                    console.warn('Failed to resume demoGame:', e);
                }

                // Ensure the left menu/sidebar opacity is restored if it was faded out earlier
                const menuSidebar = document.getElementById('menu-sidebar');
                if (menuSidebar) {
                    // reset any inline opacity set by fade routines
                    menuSidebar.style.transition = 'opacity 0.3s';
                    menuSidebar.style.opacity = '1';
                }
                
                const title = document.querySelector('h1');
                const statusMsg = document.getElementById('status-msg');
                const uploadBtn = document.getElementById('upload-btn');
                const careerBtn = document.getElementById('career-btn');
                const tutorialBtn = document.getElementById('tutorial-btn');
                const startBtn = document.getElementById('start-btn');
                const removeBtn = document.getElementById('remove-song-btn');
                const existingReplayControls = document.getElementById('replay-controls');
                if (existingReplayControls) existingReplayControls.remove();
                
                // Victory screen - only if song finished AND health is above 0
                if (reason === "Song Finished!" && this.player.health > 0) {
                    if (this.isCareerMode) {
                        if (typeof this.currentCareerSongIndex === 'number') {
                            const slot = this.careerSlots[this.currentCareerSlot] || this.careerSlots[0];
                            if (slot) {
                                if (!Array.isArray(slot.completed)) slot.completed = [];
                                slot.completed[this.currentCareerSongIndex] = true;
                                this.saveCareer();
                            }
                        }
                    }
                    
                    title.innerText = "LEVEL COMPLETE!";
                    title.className = "text-5xl font-bold mb-8 neon-text pulse";
                    title.style.color = '#00ff41';
                    title.style.textShadow = '0 0 8px #00ff41, 0 0 16px #00ff41, 0 0 24px #00ff41, 0 0 32px #00ff41';
                    
                    if (statusMsg) {
                        statusMsg.innerHTML = `
                            <span class="text-4xl font-extrabold text-green-400 block mb-2" style="text-shadow: 0 0 14px #00ff41, 0 0 28px #00ff41;">VICTORY!</span>
                            <span class="text-lg text-emerald-300 block mb-4">You absolutely shredded that track.</span>
                            Final Score: ${Math.floor(this.score)}<br>
                            Max Combo: ${this.maxCombo}x<br>
                            Graze Bonus: ${Math.floor(this.grazeScore)}<br>
                            Health Remaining: ${Math.floor(this.player.health)}%<br>
                            Profile Level: ${this.profile.level}
                        `;
                    }

                    // Subtle but hyped victory burst overlay
                    const winOverlay = document.createElement('div');
                    winOverlay.id = 'win-overlay';
                    winOverlay.style.position = 'fixed';
                    winOverlay.style.inset = '0';
                    winOverlay.style.pointerEvents = 'none';
                    winOverlay.style.zIndex = '40';
                    winOverlay.style.background = 'radial-gradient(circle at center, rgba(34,197,94,0.35), transparent 60%)';
                    winOverlay.style.opacity = '0';
                    winOverlay.style.transition = 'opacity 0.4s ease-out';
                    document.body.appendChild(winOverlay);
                    requestAnimationFrame(() => {
                        winOverlay.style.opacity = '1';
                    });
                    setTimeout(() => {
                        winOverlay.style.opacity = '0';
                        setTimeout(() => winOverlay.remove(), 400);
                    }, 1400);

                    // Quick celebratory chord (non-blinding audio hype)
                    try {
                        const AudioCtx = window.AudioContext || window.webkitAudioContext;
                        const ctx = new AudioCtx();
                        const now = ctx.currentTime;
                        const freqs = [392, 523.25, 659.25]; // G major-ish chord
                        freqs.forEach((f, i) => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            osc.frequency.value = f;
                            osc.type = 'sawtooth';
                            gain.gain.setValueAtTime(0, now);
                            gain.gain.linearRampToValueAtTime(0.18, now + 0.02 + i * 0.01);
                            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5 + i * 0.05);
                            osc.connect(gain);
                            gain.connect(ctx.destination);
                            osc.start(now);
                            osc.stop(now + 0.7);
                        });
                    } catch (e) {
                        console.error('Failed to play victory sound:', e);
                    }

                    // Replay controls (watch/download)
                    const replayControls = document.createElement('div');
                    replayControls.id = 'replay-controls';
                    replayControls.className = 'mt-6 flex items-center gap-4';

                    const watchBtn = document.createElement('button');
                    watchBtn.title = 'Watch Replay';
                    watchBtn.className = 'w-10 h-10 rounded-full border-2 border-cyan-400 text-cyan-400 flex items-center justify-center glow-button bg-transparent hover:bg-cyan-400 hover:text-black';
                    watchBtn.innerText = '‚ñ∂';
                    watchBtn.onclick = () => this.startReplay();

                    // Only show preview (no export button)
                    replayControls.appendChild(watchBtn);

                    if (statusMsg && statusMsg.parentElement) {
                        statusMsg.parentElement.appendChild(replayControls);
                    }
                    
                    startBtn.innerText = 'PLAY AGAIN';
                    // If the completed career song is the Mutant final, show an ending modal with lore and closure
                    if (this.isCareerMode && this.currentCareerSong && (this.currentCareerSong.title === 'Mutant' || (this.currentCareerSong.path && this.currentCareerSong.path.toLowerCase().includes('mutant')))) {
                        try {
                            // If the boss already reached its death state during the song, play the scripted victory cutscene now
                            // (only once, and only on actual level completion), then show the ending modal.
                            if (this.isMutantBoss && this._mutantBossDeathTriggered && !this._victoryAnimPlaying) {
                                try { this.startVictoryCutscene(); } catch (e) { console.warn('Failed to start victory cutscene:', e); }
                            }
                            // defer showing the ending modal slightly so any overlays/fades complete and ensure it appears on top
                            setTimeout(() => {
                                try { this.showEndingModal(); } catch (e) { console.warn('Failed to open ending modal:', e); }
                            }, 600);
                        } catch (e) { console.warn('Failed to open ending modal:', e); }
                    }
                } 
                // Defeat screen
                else {
                    title.innerText = "DEFEATED";
                    title.className = "text-5xl font-bold mb-8 neon-text pulse";
                    title.style.color = '#ff0055';
                    title.style.textShadow = '0 0 8px #ff0055, 0 0 16px #ff0055, 0 0 24px #ff0055, 0 0 32px #ff0055';
                    
                    if (statusMsg) {
                        statusMsg.innerHTML = `
                            <span class="text-3xl font-bold text-red-400" style="text-shadow: 0 0 10px #ff0055, 0 0 20px #ff0055;">GAME OVER</span><br><br>
                            Final Score: ${Math.floor(this.score)}<br>
                            Max Combo: ${this.maxCombo}x<br>
                            Graze Bonus: ${Math.floor(this.grazeScore)}<br>
                            Profile Level: ${this.profile.level}
                        `;
                    }
                    
                    startBtn.innerText = 'RETRY';
                }
                
                // Keep the left menu visible on win/lose so player can easily access menu controls
                uploadBtn.style.display = '';
                careerBtn.style.display = '';
                tutorialBtn.style.display = '';
                startBtn.classList.add('start-ready');
                startBtn.onclick = () => this.startCountdown();
                
                if (removeBtn) {
                    removeBtn.remove();
                }
                
                // Remove any existing back button first
                const existingBackBtn = document.getElementById('back-menu-btn');
                if (existingBackBtn) {
                    existingBackBtn.remove();
                }
                
                const backBtn = document.createElement('button');
                backBtn.id = 'back-menu-btn';
                backBtn.className = 'px-6 py-3 bg-transparent border-2 border-gray-400 text-gray-400 hover:bg-gray-400 hover:text-black transition-all duration-200 rounded-lg glow-button';
                backBtn.innerText = 'MAIN MENU';
                backBtn.onclick = () => location.reload();
                startBtn.parentElement.appendChild(backBtn);
                
                document.getElementById('status-msg').innerText = "";
                this.updateLevelDisplay();
            }

            updateHealth() {
                const bar = document.getElementById('health-bar');
                const pct = Math.max(0, (this.player.health /this.player.maxHealth) * 100);
                bar.style.width = pct + "%";
                
                // Animated gradient health bar
                if(pct < 30) {
                    bar.style.background = 'linear-gradient(90deg, #ff0000, #ff4444, #ff0000)';
                    bar.style.backgroundSize = '200% 100%';
                    bar.style.animation = 'healthGradient 2s ease infinite';
                } else if(pct < 60) {
                    bar.style.background = 'linear-gradient(90deg, #ffaa00, #ffdd00, #ffaa00)';
                    bar.style.backgroundSize = '200% 100%';
                    bar.style.animation = 'healthGradient 2s ease infinite';
                } else {
                    bar.style.background = 'linear-gradient(90deg, #00ff00, #00ff88, #00ff00)';
                    bar.style.backgroundSize = '200% 100%';
                    bar.style.animation = 'healthGradient 2s ease infinite';
                }

                if(this.player.health <= 0) {
                    // In non-deadly mode, try to respawn at the last reached checkpoint instead of immediate game over
                    if (!DEADLY_MODE && this.checkpoints && this.checkpoints.length > 0) {
                        const reached = this.checkpoints.filter(c => c.reached);
                        if (reached.length > 0) {
                            const lastCheckpoint = reached[reached.length - 1];

                            // Smooth respawn: pause game, clear hazards, short countdown, then drop you back in safely
                            const doRespawn = async () => {
                                this.isRunning = false;

                                // Stop current audio so you clearly "died"
                                if (this.audio && this.audio.isPlaying) {
                                    try {
                                        await this.audio.fadeOut(400);
                                    } catch (e) {}
                                    this.audio.stop();
                                }

                                // Clear active hazards so you don't die instantly on respawn
                                this.shards = [];
                                this.lines = [];
                                this.bombs = [];
                                this.sweepers = [];
                                this.spirals = [];
                                this.rockets = [];

                                // Simple respawn overlay
                                const overlay = document.createElement('div');
                                overlay.style.position = 'fixed';
                                overlay.style.inset = '0';
                                overlay.style.background = 'rgba(0,0,0,0.8)';
                                overlay.style.display = 'flex';
                                overlay.style.alignItems = 'center';
                                overlay.style.justifyContent = 'center';
                                overlay.style.zIndex = '80';
                                overlay.style.pointerEvents = 'none';

                                const text = document.createElement('div');
                                text.style.fontFamily = 'Orbitron, sans-serif';
                                text.style.fontSize = '2.5rem';
                                text.style.fontWeight = '700';
                                text.style.color = '#00ff41';
                                text.style.textShadow = '0 0 12px #00ff41, 0 0 24px #00ff41';
                                text.innerText = 'RESPAWNING 3';
                                overlay.appendChild(text);
                                document.body.appendChild(overlay);

                                let count = 3;
                                await new Promise(resolve => {
                                    const interval = setInterval(() => {
                                        count -= 1;
                                        if (count <= 0) {
                                            clearInterval(interval);
                                            resolve();
                                        } else {
                                            text.innerText = `RESPAWNING ${count}`;
                                        }
                                    }, 600);
                                });

                                overlay.remove();

                                // Restore player state
                                // Always respawn with full health regardless of what the checkpoint stored
                                this.player.health = this.player.maxHealth;
                                this.score = lastCheckpoint.score || this.score;
                                this.combo = 0;
                                this.comboTimer = 0;
                                this.updateCombo();
                                this.lastDamageTime = performance.now();

                                // Move player to safe position and give extended invulnerability (~3 seconds at 60fps)
                                this.player.x = this.width / 2;
                                this.player.y = this.height * 0.8;
                                this.player.invulnerable = 180; // ~3 seconds of grace

                                // Restart audio from checkpoint time, slightly after the saved beat
                                if (this.audio && this.audio.audioBuffer && typeof lastCheckpoint.time === 'number') {
                                    const restartTime = Math.max(0, lastCheckpoint.time - 0.5);
                                    this.audio.stop();
                                    this.audio.play(restartTime);
                                    this.startTime = performance.now() - restartTime * 1000;
                                }

                                // Update health bar to reflect restored HP
                                const restoredPct = Math.max(0, (this.player.health / this.player.maxHealth) * 100);
                                bar.style.width = restoredPct + "%";

                                // Resume game loop
                                this.isRunning = true;
                                this.loop();
                            };

                            // Kick off async respawn flow and skip gameOver
                            doRespawn();
                            return;
                        }
                    }

                    // Deadly mode (or no checkpoints): straight to game over
                    this.gameOver();
                }
            }

            registerDamage() {
                this.lastDamageTime = performance.now();
                // Combo no longer resets on damage
                this.comboTimer = 0; // But stop the timer so it won't grow
            }

            triggerShake(amount) {
                // Remove shake on low settings
                if (window.GRAPHICS_LEVEL === 'BASIC') return;
                this.shake = amount;
            }

            showHitFlash() {
                this.hitFlashOpacity = 0.3;
            }

            showLevelUpNotification() {
                this.levelUpNotification = {
                    text: `LEVEL UP! Now Level ${this.profile.level}`,
                    opacity: 1,
                    y: this.height / 2
                };
            }

            processTutorialEvents() {
                if (!this.isTutorialMode) return;
                
                const now = performance.now();
                const elapsed = (now - this.tutorialStartTime) / 1000; // seconds
                
                if (!this.tutorialSpawnTimers) {
                    this.tutorialSpawnTimers = {
                        shard: 0,
                        bomb: 0,
                        sweeper: 0,
                        spiral: 0,
                        rocket: 0,
                        mixed: 0
                    };
                }

                const trackInfo = document.getElementById('track-info');

                // Apply deadly mode multiplier to tutorial spawns
                const deadlyMult = DEADLY_MODE ? 0.5 : 1;

                // 0‚Äì60s: constant shards, gradually faster
                if (elapsed >= 0 && elapsed < 60) {
                    if (trackInfo && trackInfo.innerText === 'Tutorial Mode') {
                        trackInfo.innerText = 'Avoid the purple shards!';
                        trackInfo.style.color = '#00ffff';
                        setTimeout(() => {
                            if (trackInfo.innerText === 'Avoid the purple shards!') {
                                trackInfo.style.color = '';
                            }
                        }, 3000);
                    }
                    const interval = (600 - Math.min(elapsed * 5, 300)) * deadlyMult;
                    if (now >= this.tutorialSpawnTimers.shard) {
                        // Reduce shard volume: base lowered and growth slowed
                        const count = 2 + Math.floor(elapsed / 12);
                        for (let i = 0; i < count; i++) {
                            const x = Math.random() * this.width;
                            const angle = Math.atan2(this.player.y, this.player.x - x) + (Math.random() - 0.5) * 0.35;
                            this.shards.push(new Shard(x, -10, angle, 2.0 * getSpeedFactor()));
                        }
                        this.tutorialSpawnTimers.shard = now + interval;
                    }
                }
                // 60‚Äì120s: constant explosions (bombs)
                else if (elapsed >= 60 && elapsed < 120) {
                    if (trackInfo && trackInfo.innerText !== 'Yellow bombs explode into shards!') {
                        trackInfo.innerText = 'Yellow bombs explode into shards!';
                        trackInfo.style.color = '#ffeb3b';
                        setTimeout(() => {
                            if (trackInfo.innerText === 'Yellow bombs explode into shards!') {
                                trackInfo.style.color = '';
                            }
                        }, 3000);
                    }
                    const interval = (1200 - Math.min((elapsed - 60) * 10, 700)) * deadlyMult;
                    if (now >= this.tutorialSpawnTimers.bomb) {
                        // Fewer bombs overall and slower escalation
                        const count = 1 + Math.floor((elapsed - 60) / 20);
                        for (let i = 0; i < count; i++) {
                            this.bombs.push(new Bomb());
                        }
                        this.tutorialSpawnTimers.bomb = now + interval;
                    }
                }
                // 120‚Äì180s: sweepers entering regularly
                else if (elapsed >= 120 && elapsed < 180) {
                    if (trackInfo && trackInfo.innerText !== 'Cyan sweepers - find the gap!') {
                        trackInfo.innerText = 'Cyan sweepers - find the gap!';
                        trackInfo.style.color = '#00ffff';
                        setTimeout(() => {
                            if (trackInfo.innerText === 'Cyan sweepers - find the gap!') {
                                trackInfo.style.color = '';
                            }
                        }, 3000);
                    }
                    const interval = Math.floor((1600 - Math.min((elapsed - 120) * 12, 800)) * 1.6 * deadlyMult);
                    if (now >= this.tutorialSpawnTimers.sweeper) {
                        const originalCount = 1 + Math.floor((elapsed - 120) / 20);
                        const count = Math.max(1, Math.floor(originalCount * 0.67));
                        const spawnCount = (elapsed < 140) ? Math.max(0, Math.floor(count * 0.6)) : count;
                        if (spawnCount > 0) {
                            for (let i = 0; i < spawnCount; i++) {
                                this.sweepers.push(new Sweeper());
                            }
                        }
                        this.tutorialSpawnTimers.sweeper = now + interval;
                    }
                }
                // 180‚Äì240s: spirals and rockets join in
                else if (elapsed >= 180 && elapsed < 240) {
                    if (trackInfo && trackInfo.innerText !== 'Tracking orbs & rockets incoming!') {
                        trackInfo.innerText = 'Tracking orbs & rockets incoming!';
                        trackInfo.style.color = '#ff9800';
                        setTimeout(() => {
                            if (trackInfo.innerText === 'Tracking orbs & rockets incoming!') {
                                trackInfo.style.color = '';
                            }
                        }, 3000);
                    }
                    const spiralInterval = (1200 - Math.min((elapsed - 180) * 10, 600)) * deadlyMult;
                    const rocketInterval = (1600 - Math.min((elapsed - 180) * 8, 800)) * deadlyMult;
                    if (now >= this.tutorialSpawnTimers.spiral) {
                        const count = 1 + Math.floor((elapsed - 180) / 20);
                        for (let i = 0; i < count; i++) {
                            this.spirals.push(new Spiral());
                        }
                        this.tutorialSpawnTimers.spiral = now + spiralInterval;
                    }
                    if (now >= this.tutorialSpawnTimers.rocket) {
                        const count = 1 + Math.floor((elapsed - 180) / 30);
                        for (let i = 0; i < count; i++) {
                            this.rockets.push(new Rocket());
                        }
                        this.tutorialSpawnTimers.rocket = now + rocketInterval;
                    }
                }
                // 240s to end (~281s): constant everything mixed
                else if (elapsed >= 240 && elapsed < 281) {
                    if (trackInfo && trackInfo.innerText !== 'Final exam: everything at once!') {
                        trackInfo.innerText = 'Final exam: everything at once!';
                        trackInfo.style.color = '#ff00ff';
                        setTimeout(() => {
                            if (trackInfo.innerText === 'Final exam: everything at once!') {
                                trackInfo.style.color = '';
                            }
                        }, 3000);
                    }
                    const base = Math.max(300, (900 - (elapsed - 240) * 10) * deadlyMult);
                    if (now >= this.tutorialSpawnTimers.mixed) {
                        const packs = 2 + Math.floor((elapsed - 240) / 12);
                        for (let i = 0; i < packs; i++) {
                            const type = Math.floor(Math.random() * 6);
                            switch (type) {
                                case 0: {
                                    const x = Math.random() * this.width;
                                    const angle = Math.atan2(this.player.y, this.player.x - x);
                                    this.shards.push(new Shard(x, -10, angle, 2.3 * getSpeedFactor()));
                                    break;
                                }
                                case 1:
                                    this.lines.push(new Line());
                                    break;
                                case 2:
                                    this.bombs.push(new Bomb());
                                    break;
                                case 3:
                                    this.sweepers.push(new Sweeper());
                                    break;
                                case 4:
                                    this.spirals.push(new Spiral());
                                    break;
                                case 5:
                                    this.rockets.push(new Rocket());
                                    break;
                            }
                        }
                        this.tutorialSpawnTimers.mixed = now + base;
                    }
                }
            }

            recordFrame() {
                if (!this.isRunning) return;

                // Compute song progress percentage for this frame
                let progressPct = 0;
                if (this.audio && this.audio.audioBuffer) {
                    const currentTime = this.audio.getCurrentTime();
                    const dur = this.audio.audioBuffer.duration || 1;
                    progressPct = Math.max(0, Math.min(100, (currentTime / dur) * 100));
                }

                // Record absolute audio time instead of elapsed time so checkpoints don't break replay
                const audioTime = (this.audio && this.audio.audioBuffer) ? this.audio.getCurrentTime() : 0;
                
                const frame = {
                    audioTime: audioTime,
                    player: {
                        x: this.player.x,
                        y: this.player.y,
                        r: this.player.r,
                        visualR: this.player.visualR,
                        health: this.player.health
                    },
                    shards: this.shards.map(s => ({ x: s.x, y: s.y, r: s.r })),
                    rockets: this.rockets.map(r => ({
                        x: r.x,
                        y: r.y,
                        r: r.r,
                        angle: Math.atan2(r.vy, r.vx || 0.0001)
                    })),
                    spirals: this.spirals.map(s => ({
                        x: s.x,
                        y: s.y,
                        r: s.r,
                        angle: s.angle,
                        spiralRadius: s.spiralRadius
                    })),
                    lines: this.lines.map(l => ({
                        p1: { x: l.p1.x, y: l.p1.y },
                        p2: { x: l.p2.x, y: l.p2.y },
                        width: l.width,
                        isLethal: l.isLethal
                    })),
                    sweepers: this.sweepers.map(s => ({
                        orientation: s.orientation,
                        x: s.x || 0,
                        y: s.y || 0,
                        gapPos: s.gapPos,
                        thickness: s.thickness
                    })),
                    bombs: this.bombs.map(b => ({
                        x: b.x,
                        y: b.y,
                        radius: b.radius,
                        timer: b.timer
                    })),
                    score: this.score,
                    combo: this.combo,
                    time: (performance.now() - this.startTime) / 1000,
                    progressPct
                };

                this.replayFrames.push(frame);
            }

            startReplay() {
                if (!this.replayFrames || this.replayFrames.length === 0) return;

                // Pause live state and audio from gameplay
                this.isRunning = false;
                if (this.audio && this.audio.isPlaying) this.audio.stop();

                // Restart song audio for the replay so visuals/audio line up
                try {
                    if (this.audio && this.audio.audioBuffer) {
                        this.audio.play(0);
                    }
                } catch (e) {
                    console.error('Failed to start audio for replay:', e);
                }

                // Create fullscreen modal with temporary canvas for preview so background/visuals render correctly
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.inset = '0';
                modal.style.background = 'rgba(0,0,0,0.95)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '60';

                const closeBtn = document.createElement('button');
                closeBtn.innerText = '‚úï';
                closeBtn.style.position = 'absolute';
                closeBtn.style.top = '18px';
                closeBtn.style.right = '18px';
                closeBtn.style.zIndex = '70';
                closeBtn.className = 'px-3 py-1 rounded-full border-2 border-red-400 text-red-400 bg-transparent glow-button';

                const downloadBtn = document.createElement('button');
                downloadBtn.innerText = 'Download';
                downloadBtn.title = 'Download replay video';
                downloadBtn.style.position = 'absolute';
                downloadBtn.style.bottom = '18px';
                downloadBtn.style.right = '18px';
                downloadBtn.style.zIndex = '70';
                downloadBtn.className = 'px-4 py-2 rounded-full border-2 border-cyan-400 text-cyan-400 bg-transparent glow-button';
                downloadBtn.onclick = () => {
                    this.exportReplayToVideo();
                };

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.width;
                tempCanvas.height = this.height;
                tempCanvas.style.maxWidth = '100%';
                tempCanvas.style.maxHeight = '100%';
                tempCanvas.style.boxShadow = '0 0 20px rgba(0,0,0,0.6)';
                const tctx = tempCanvas.getContext('2d');

                modal.appendChild(tempCanvas);
                modal.appendChild(closeBtn);
                modal.appendChild(downloadBtn);
                document.body.appendChild(modal);

                let i = 0;
                const fps = 60;
                const step = 1000 / fps;

                // Make sure the visualizer matches the preview canvas size
                if (this.visualizer) {
                    this.visualizer.setSize(tempCanvas.width, tempCanvas.height);
                }

                const drawFrame = (frame) => {
                    // Update audio analysis + visualizer for this frame so background matches the music
                    if (this.audio) {
                        this.audio.update();
                    }
                    if (this.visualizer && this.audio && this.audio.dataArray) {
                        this.visualizer.update(this.audio.dataArray, this.audio.volume || 0);
                    }

                    tctx.save();
                    tctx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

                    // Dynamic gradient background similar to gameplay
                    const bassGlow = (this.audio?.bass || 0) * 100;
                    const midGlow = (this.audio?.mid || 0) * 100;
                    const trebleGlow = (this.audio?.treble || 0) * 100;
                    const gradient = tctx.createRadialGradient(
                        tempCanvas.width / 2,
                        tempCanvas.height / 2,
                        0,
                        tempCanvas.width / 2,
                        tempCanvas.height / 2,
                        Math.max(tempCanvas.width, tempCanvas.height)
                    );
                    gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                    gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                    tctx.fillStyle = gradient;
                    tctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                    // Checkerboard visualizer on top
                    if (this.visualizer) {
                        this.visualizer.render(tctx);
                    }

                    // Slight dark overlay like in-game
                    tctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                    tctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                    // Draw same elements used in drawReplayFrame but to temp canvas (keeps visuals consistent)
                    // Player
                    if (frame.player) {
                        tctx.shadowBlur = 15;
                        tctx.shadowColor = '#ffffff';
                        tctx.beginPath();
                        tctx.arc(frame.player.x, frame.player.y, frame.player.visualR || 15, 0, Math.PI * 2);
                        tctx.fillStyle = 'rgba(255,255,255,0.18)';
                        tctx.fill();
                        tctx.strokeStyle = '#ffffff';
                        tctx.lineWidth = 2;
                        tctx.stroke();
                        tctx.shadowBlur = 0;
                    }

                    // Shards
                    if (Array.isArray(frame.shards)) {
                        tctx.fillStyle = '#cc00ff';
                        tctx.shadowBlur = 8;
                        tctx.shadowColor = '#cc00ff';
                        for (const s of frame.shards) {
                            if (s && typeof s.x === 'number' && typeof s.y === 'number') {
                                tctx.beginPath();
                                tctx.arc(s.x, s.y, s.r || 4, 0, Math.PI * 2);
                                tctx.fill();
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Rockets
                    if (Array.isArray(frame.rockets)) {
                        for (const r of frame.rockets) {
                            if (!r) continue;
                            tctx.save();
                            tctx.translate(r.x || 0, r.y || 0);
                            tctx.rotate(r.angle || 0);
                            tctx.fillStyle = '#ff8800';
                            tctx.shadowBlur = 10;
                            tctx.shadowColor = '#ff8800';
                            tctx.beginPath();
                            tctx.moveTo(12, 0);
                            tctx.lineTo(-8, 5);
                            tctx.lineTo(-8, -5);
                            tctx.closePath();
                            tctx.fill();
                            tctx.restore();
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Spirals
                    if (Array.isArray(frame.spirals)) {
                        tctx.fillStyle = '#ffdd00';
                        tctx.shadowBlur = 12;
                        tctx.shadowColor = '#ff9900';
                        for (const s of frame.spirals) {
                            const angle = s.angle || 0;
                            const spiralRadius = s.spiralRadius || 0;
                            const fx = (s.x || 0) + Math.cos(angle) * spiralRadius;
                            const fy = (s.y || 0) + Math.sin(angle) * spiralRadius;
                            tctx.beginPath();
                            tctx.arc(fx, fy, s.r || 6, 0, Math.PI * 2);
                            tctx.fill();
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Lines
                    if (Array.isArray(frame.lines)) {
                        for (const l of frame.lines) {
                            if (!l || !l.p1 || !l.p2) continue;
                            tctx.beginPath();
                            tctx.moveTo(l.p1.x, l.p1.y);
                            tctx.lineTo(l.p2.x, l.p2.y);
                            if (l.isLethal) {
                                tctx.strokeStyle = '#ff0055';
                                tctx.lineWidth = l.width || 10;
                                tctx.shadowBlur = 20;
                                tctx.shadowColor = '#ff0055';
                            } else {
                                tctx.strokeStyle = 'rgba(255,0,85,0.5)';
                                tctx.lineWidth = 1;
                                tctx.setLineDash([10, 10]);
                                tctx.shadowBlur = 8;
                                tctx.shadowColor = '#ff0055';
                            }
                            tctx.stroke();
                            tctx.setLineDash([]);
                            tctx.shadowBlur = 0;
                        }
                    }

                    // Sweepers
                    if (Array.isArray(frame.sweepers)) {
                        tctx.fillStyle = '#00ffff';
                        tctx.shadowBlur = 18;
                        tctx.shadowColor = '#00ffff';
                        for (const s of frame.sweepers) {
                            if (!s) continue;
                            const gap = s.gapPos || 0;
                            const thick = s.thickness || 40;
                            if (s.orientation === 'H') {
                                const y = typeof s.y === 'number' ? s.y : 0;
                                if (gap > 0) tctx.fillRect(0, y, gap, thick);
                                const rightStart = gap + (s.gapSize || 150);
                                if (rightStart < this.width) tctx.fillRect(rightStart, y, this.width - rightStart, thick);
                            } else {
                                const x = typeof s.x === 'number' ? s.x : 0;
                                if (gap > 0) tctx.fillRect(x, 0, thick, gap);
                                const bottomStart = gap + (s.gapSize || 150);
                                if (bottomStart < this.height) tctx.fillRect(x, bottomStart, thick, this.height - bottomStart);
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Bombs
                    if (Array.isArray(frame.bombs)) {
                        tctx.strokeStyle = 'yellow';
                        tctx.lineWidth = 2;
                        tctx.shadowBlur = 15;
                        tctx.shadowColor = 'yellow';
                        for (const b of frame.bombs) {
                            if (b && typeof b.x === 'number' && typeof b.y === 'number') {
                                tctx.beginPath();
                                tctx.arc(b.x, b.y, b.radius || 80, 0, Math.PI * 2);
                                tctx.stroke();
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    tctx.restore();
                };

                let intervalId = setInterval(() => {
                    if (i >= this.replayFrames.length) {
                        clearInterval(intervalId);
                        intervalId = null;
                        // leave modal visible until user closes
                        return;
                    }
                    const frame = this.replayFrames[i];
                    drawFrame(frame);
                    i++;
                }, step);

                const cleanup = () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                        intervalId = null;
                    }
                    // Stop replay audio when closing preview
                    try {
                        if (this.audio && this.audio.isPlaying) {
                            this.audio.stop();
                        }
                    } catch (e) {
                        console.error('Error stopping audio after replay preview:', e);
                    }
                    if (modal && modal.parentElement) modal.remove();
                    // Restore HUD/menu visibility
                    const ui = document.getElementById('ui-layer');
                    if (ui) ui.classList.remove('hidden');
                    const hud = document.getElementById('hud');
                    if (hud) hud.classList.add('hidden');
                };

                closeBtn.onclick = () => {
                    cleanup();
                };

                // also close on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) cleanup();
                });
            }

            runReplayLoop() {
                // legacy no-op kept for compatibility
                return;
            }

            drawReplayFrame(frame) {
                const ctx = this.ctx;
                ctx.save();
                ctx.clearRect(0, 0, this.width, this.height);

                // Simple dark background for replay
                ctx.fillStyle = 'rgba(0,0,0,0.95)';
                ctx.fillRect(0, 0, this.width, this.height);

                // Player
                if (frame.player) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(frame.player.x, frame.player.y, frame.player.visualR || 15, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.18)';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Shards (purple circles)
                if (Array.isArray(frame.shards)) {
                    ctx.fillStyle = '#cc00ff';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#cc00ff';
                    for (const s of frame.shards) {
                        if (s && typeof s.x === 'number' && typeof s.y === 'number') {
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, s.r || 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.shadowBlur = 0;
                }

                // Rockets (orange triangles)
                if (Array.isArray(frame.rockets)) {
                    for (const r of frame.rockets) {
                        if (!r) continue;
                        ctx.save();
                        ctx.translate(r.x || 0, r.y || 0);
                        ctx.rotate(r.angle || 0);
                        ctx.fillStyle = '#ff8800';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff8800';
                        ctx.beginPath();
                        ctx.moveTo(12, 0);
                        ctx.lineTo(-8, 5);
                        ctx.lineTo(-8, -5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.shadowBlur = 0;
                }

                // Spirals (yellow orbs)
                if (Array.isArray(frame.spirals)) {
                    ctx.fillStyle = '#ffdd00';
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff9900';
                    for (const s of frame.spirals) {
                        const angle = s.angle || 0;
                        const spiralRadius = s.spiralRadius || 0;
                        const fx = (s.x || 0) + Math.cos(angle) * spiralRadius;
                        const fy = (s.y || 0) + Math.sin(angle) * spiralRadius;
                        ctx.beginPath();
                        ctx.arc(fx, fy, s.r || 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }

                // Lines
                if (Array.isArray(frame.lines)) {
                    for (const l of frame.lines) {
                        if (!l || !l.p1 || !l.p2) continue;
                        ctx.beginPath();
                        ctx.moveTo(l.p1.x, l.p1.y);
                        ctx.lineTo(l.p2.x, l.p2.y);
                        if (l.isLethal) {
                            ctx.strokeStyle = '#ff0055';
                            ctx.lineWidth = l.width || 10;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ff0055';
                        } else {
                            ctx.strokeStyle = 'rgba(255,0,85,0.5)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([10, 10]);
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#ff0055';
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.shadowBlur = 0;
                    }
                }

                // Sweepers
                if (Array.isArray(frame.sweepers)) {
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#00ffff';
                    for (const s of frame.sweepers) {
                        if (!s) continue;
                        const gap = s.gapPos || 0;
                        const thick = s.thickness || 40;
                        if (s.orientation === 'H') {
                            const y = typeof s.y === 'number' ? s.y : 0;
                            if (gap > 0) ctx.fillRect(0, y, gap, thick);
                            const rightStart = gap + (s.gapSize || 150);
                            if (rightStart < this.width) ctx.fillRect(rightStart, y, this.width - rightStart, thick);
                        } else {
                            const x = typeof s.x === 'number' ? s.x : 0;
                            if (gap > 0) ctx.fillRect(x, 0, thick, gap);
                            const bottomStart = gap + (s.gapSize || 150);
                            if (bottomStart < this.height) ctx.fillRect(x, bottomStart, thick, this.height - bottomStart);
                        }
                    }
                    ctx.shadowBlur = 0;
                }

                // Bombs (yellow circles)
                if (Array.isArray(frame.bombs)) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'yellow';
                    for (const b of frame.bombs) {
                        if (b && typeof b.x === 'number' && typeof b.y === 'number') {
                            ctx.beginPath();
                            ctx.arc(b.x, b.y, b.radius || 80, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            }

            async exportReplayToVideo() {
                if (!this.replayFrames || this.replayFrames.length === 0) return;
                // Create a temporary canvas for rendering the replay frames
                const exportWidth = Math.max(640, this.width);
                const exportHeight = Math.max(360, this.height);
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = exportWidth;
                tempCanvas.height = exportHeight;
                const tctx = tempCanvas.getContext('2d');

                // Helper to draw a single replay frame to the temp canvas
                const drawFrameToTemp = (frame) => {
                    if (!frame) return; // Guard against null frames
                    
                    tctx.save();
                    tctx.clearRect(0, 0, exportWidth, exportHeight);

                    // Dark background
                    tctx.fillStyle = 'rgba(0,0,0,0.95)';
                    tctx.fillRect(0, 0, exportWidth, exportHeight);

                    // Player (scaled to export canvas)
                    if (frame.player) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        const px = (frame.player.x || 0) * scaleX;
                        const py = (frame.player.y || 0) * scaleY;
                        const vR = (frame.player.visualR || 15) * ((scaleX + scaleY) / 2);

                        tctx.shadowBlur = 15;
                        tctx.shadowColor = '#ffffff';
                        tctx.beginPath();
                        tctx.arc(px, py, vR, 0, Math.PI * 2);
                        tctx.fillStyle = 'rgba(255,255,255,0.18)';
                        tctx.fill();
                        tctx.strokeStyle = '#ffffff';
                        tctx.lineWidth = 2;
                        tctx.stroke();
                        tctx.shadowBlur = 0;
                    }

                    // Shards
                    if (Array.isArray(frame.shards)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        tctx.fillStyle = '#cc00ff';
                        tctx.shadowBlur = 8;
                        tctx.shadowColor = '#cc00ff';
                        for (const s of frame.shards) {
                            if (s && typeof s.x === 'number' && typeof s.y === 'number') {
                                tctx.beginPath();
                                tctx.arc(s.x * scaleX, s.y * scaleY, (s.r || 4) * ((scaleX + scaleY)/2), 0, Math.PI * 2);
                                tctx.fill();
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Rockets
                    if (Array.isArray(frame.rockets)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        for (const r of frame.rockets) {
                            if (!r) continue;
                            tctx.save();
                            tctx.translate((r.x || 0) * scaleX, (r.y || 0) * scaleY);
                            tctx.rotate(r.angle || 0);
                            tctx.fillStyle = '#ff8800';
                            tctx.shadowBlur = 10;
                            tctx.shadowColor = '#ff8800';
                            tctx.beginPath();
                            tctx.moveTo(12 * ((scaleX+scaleY)/2), 0);
                            tctx.lineTo(-8 * ((scaleX+scaleY)/2), 5 * ((scaleX+scaleY)/2));
                            tctx.lineTo(-8 * ((scaleX+scaleY)/2), -5 * ((scaleX+scaleY)/2));
                            tctx.closePath();
                            tctx.fill();
                            tctx.restore();
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Spirals
                    if (Array.isArray(frame.spirals)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        tctx.fillStyle = '#ffdd00';
                        tctx.shadowBlur = 12;
                        tctx.shadowColor = '#ff9900';
                        for (const s of frame.spirals) {
                            const angle = s.angle || 0;
                            const spiralRadius = s.spiralRadius || 0;
                            const fx = ((s.x || 0) + Math.cos(angle) * spiralRadius) * scaleX;
                            const fy = ((s.y || 0) + Math.sin(angle) * spiralRadius) * scaleY;
                            tctx.beginPath();
                            tctx.arc(fx, fy, (s.r || 6) * ((scaleX+scaleY)/2), 0, Math.PI * 2);
                            tctx.fill();
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Lines
                    if (Array.isArray(frame.lines)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        for (const l of frame.lines) {
                            if (!l || !l.p1 || !l.p2) continue;
                            tctx.beginPath();
                            tctx.moveTo(l.p1.x * scaleX, l.p1.y * scaleY);
                            tctx.lineTo(l.p2.x * scaleX, l.p2.y * scaleY);
                            if (l.isLethal) {
                                tctx.strokeStyle = '#ff0055';
                                tctx.lineWidth = (l.width || 10) * ((scaleX+scaleY)/2);
                                tctx.shadowBlur = 20;
                                tctx.shadowColor = '#ff0055';
                            } else {
                                tctx.strokeStyle = 'rgba(255,0,85,0.5)';
                                tctx.lineWidth = 1;
                                tctx.setLineDash([10, 10]);
                                tctx.shadowBlur = 8;
                                tctx.shadowColor = '#ff0055';
                            }
                            tctx.stroke();
                            tctx.setLineDash([]);
                            tctx.shadowBlur = 0;
                        }
                    }

                    // Sweepers
                    if (Array.isArray(frame.sweepers)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        tctx.fillStyle = '#00ffff';
                        tctx.shadowBlur = 18;
                        tctx.shadowColor = '#00ffff';
                        for (const s of frame.sweepers) {
                            if (!s) continue;
                            const gap = s.gapPos || 0;
                            const thick = (s.thickness || 40) * ((scaleX+scaleY)/2);
                            if (s.orientation === 'H') {
                                const y = (typeof s.y === 'number' ? s.y : 0) * scaleY;
                                if (gap > 0) tctx.fillRect(0, y, gap * scaleX, thick);
                                const rightStart = gap + (s.gapSize || 150);
                                if (rightStart < this.width) tctx.fillRect(rightStart * scaleX, y, (this.width - rightStart) * scaleX, thick);
                            } else {
                                const x = (typeof s.x === 'number' ? s.x : 0) * scaleX;
                                if (gap > 0) tctx.fillRect(x, 0, thick, gap * scaleY);
                                const bottomStart = gap + (s.gapSize || 150);
                                if (bottomStart < this.height) tctx.fillRect(x, bottomStart * scaleY, thick, (this.height - bottomStart) * scaleY);
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    // Bombs
                    if (Array.isArray(frame.bombs)) {
                        const scaleX = exportWidth / this.width;
                        const scaleY = exportHeight / this.height;
                        tctx.strokeStyle = 'yellow';
                        tctx.lineWidth = 2;
                        tctx.shadowBlur = 15;
                        tctx.shadowColor = 'yellow';
                        for (const b of frame.bombs) {
                            if (b && typeof b.x === 'number' && typeof b.y === 'number') {
                                tctx.beginPath();
                                tctx.arc(b.x * scaleX, b.y * scaleY, (b.radius || 80) * ((scaleX+scaleY)/2), 0, Math.PI * 2);
                                tctx.stroke();
                            }
                        }
                        tctx.shadowBlur = 0;
                    }

                    tctx.restore();
                };

                // Prepare MediaRecorder on the temp canvas stream
                const fps = 60;
                const stream = tempCanvas.captureStream(fps);
                const recordedChunks = [];
                let mime = 'video/webm; codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mime)) {
                    mime = 'video/webm; codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(mime)) {
                        mime = 'video/webm';
                    }
                }
                const recorder = new MediaRecorder(stream, { mimeType: mime });

                recorder.ondataavailable = (e) => {
                    if (e.data && e.data.size) recordedChunks.push(e.data);
                };

                const durationMs = Math.floor((this.replayFrames.length / fps) * 1000);
                recorder.start();

                // Play frames to the temp canvas at fixed fps and stop recorder when done
                let i = 0;
                const step = 1000 / fps;
                const interval = setInterval(() => {
                    const frame = this.replayFrames[i];
                    if (!frame) {
                        clearInterval(interval);
                        // give recorder a tick to flush
                        setTimeout(() => {
                            recorder.stop();
                        }, 100);
                        return;
                    }
                    drawFrameToTemp(frame);
                    i++;
                }, step);

                recorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (this.currentSongTitle ? this.currentSongTitle.replace(/\s+/g,'_') : 'replay') + '.webm';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    setTimeout(() => URL.revokeObjectURL(url), 2000);
                };
            }

            loop() {
                if (!this.isRunning) return;

                if (this.paused) {
                    // Draw pause screen
                    this.ctx.save();
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 48px Orbitron';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.width / 2, this.height / 2);
                    this.ctx.font = '24px Orbitron';
                    this.ctx.fillText('Press P or ESC to Resume', this.width / 2, this.height / 2 + 50);
                    this.ctx.restore();
                    requestAnimationFrame(() => this.loop());
                    return;
                }

                // Smoothly interpolate scale
                this.gameScale += (this.targetGameScale - this.gameScale) * 0.05;

                // Frame delta
                const nowTs = performance.now();
                const dt = (nowTs - (this.lastFrameTime || nowTs)) / 1000;
                this.lastFrameTime = nowTs;

                if (!this.countdownActive) {
                    this.audio.update();
                    this.visualizer.update(this.audio.dataArray, this.audio.volume);
                    
                    // Boss wrap effect logic (gameplay only)
                    let wrapAlpha = 0, wrapX = 0, wrapY = 0, wrapR = 0;
                    if (this.isMutantBoss && this.boss) {
                        if (this.boss.state === 'intro' || this.boss.state === 'attack' || this.boss.state === 'easy') {
                            wrapAlpha = this.boss.alpha;
                            wrapX = this.boss.x;
                            wrapY = this.boss.y;
                            wrapR = this.boss.r;
                        }
                    } else if (!this.isMutantBoss && this.customBossManager && this.customBossManager.activeBoss) {
                        const b = this.customBossManager.activeBoss;
                        wrapAlpha = 0.9;
                        wrapX = b.x;
                        wrapY = b.y;
                        wrapR = b.r || 50;
                    }
                    this.visualizer.setBossWrap(wrapAlpha > 0 ? wrapAlpha : 0, wrapX, wrapY, wrapR);
                    
                    if (this.isTutorialMode) this.processTutorialEvents();
                    else this.spawnLogic();

                    if (!this.isMutantBoss && !this.isCareerMode && !this.isTutorialMode && this.isCustomSongBossEligible && this.customBossManager) {
                        this.customBossManager.update(dt, this.audio);
                    }

                    if (this.comboTimer > 0) {
                        this.comboTimer--;
                        if (this.comboTimer === 0) this.resetCombo();
                    }
                    
                    if (this.player.health > 0 && this.player.health < this.player.maxHealth) {
                        if (nowTs - this.lastDamageTime > this.regenDelay) {
                            this.player.health = Math.min(this.player.maxHealth, this.player.health + this.regenRate);
                            this.updateHealth();
                        }
                    }
                } else {
                    // Update player following mouse during countdown (scaled coords)
                    // We need to inverse map the mouse coordinates because canvas is scaled
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;
                    const invScale = 1 / this.gameScale;
                    const worldMouseX = centerX + (this.mouseX - centerX) * invScale;
                    const worldMouseY = centerY + (this.mouseY - centerY) * invScale;
                    this.player.update(worldMouseX, worldMouseY, 1);
                }

                // Render Start
                this.ctx.save();
                
                // Apply Camera Scale
                this.ctx.translate(this.width / 2, this.height / 2);
                this.ctx.scale(this.gameScale, this.gameScale);
                this.ctx.translate(-this.width / 2, -this.height / 2);

                if (this.shake > 0 && !this.countdownActive) {
                    const dx = (Math.random() - 0.5) * this.shake;
                    const dy = (Math.random() - 0.5) * this.shake;
                    this.ctx.translate(dx, dy);
                    this.shake *= 0.9;
                    if (this.shake < 0.5) this.shake = 0;
                }

                // Background
                let bassGlow = 0, midGlow = 0, trebleGlow = 0;
                if (!this.countdownActive) {
                    bassGlow = this.audio.bass * 100;
                    midGlow = this.audio.mid * 100;
                    trebleGlow = this.audio.treble * 100;
                }
                const radius = Math.max(this.width, this.height) * 1.5;
                const gradient = this.ctx.createRadialGradient(
                    this.width / 2, this.height / 2, 0,
                    this.width / 2, this.height / 2, radius
                );
                gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                
                this.ctx.fillStyle = gradient;
                // Draw large rect to cover scaled-out view
                this.ctx.fillRect(-this.width, -this.height, this.width * 3, this.height * 3);

                // Pass scale to visualizer so it can prevent black borders
                this.visualizer.render(this.ctx, this.gameScale);

                // Overlay
                this.ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                this.ctx.fillRect(-this.width, -this.height, this.width * 3, this.height * 3);

                // Game Entities
                if (!this.countdownActive) {
                    // Poll gamepad
                    let gamepadX = 0, gamepadY = 0;
                    if (this.gamepadIndex !== null) {
                        const gamepads = navigator.getGamepads();
                        const gamepad = gamepads[this.gamepadIndex];
                        if (gamepad) {
                            let rawX = gamepad.axes[0] || 0;
                            let rawY = gamepad.axes[1] || 0;
                            if (Math.abs(rawX) < this.gamepadDeadzone) rawX = 0;
                            if (Math.abs(rawY) < this.gamepadDeadzone) rawY = 0;
                            gamepadX = rawX * this.gamepadSensitivity;
                            gamepadY = rawY * this.gamepadSensitivity;
                        }
                    }
                    this.player.update(this.mouseX, this.mouseY, this.canvasScale, gamepadX, gamepadY);
                }
                
                // Draw player
                this.player.draw(this.ctx);

                if (!this.countdownActive) {
                    if (this.customBossManager && this.customBossManager.activeBoss) {
                         try {
                            this.ctx.save();
                            this.ctx.globalAlpha = 1;
                            this.customBossManager.activeBoss.draw(this.ctx);
                            this.ctx.restore();
                        } catch (e) {}
                    }
                }

                // Countdown UI Rendering (In-World)
                if (this.countdownActive) {
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;

                    // Hover logic
                    const dist = Math.hypot(this.player.x - centerX, this.player.y - centerY);
                    const hoverRadius = 45;
                    
                    if (dist < hoverRadius) {
                         if (!this._hovering) {
                             this._hovering = true;
                             // Play sticks sound
                             try {
                                if (window.sticksAudioCtx && window.sticksAudioBuffer) {
                                    const ctx = window.sticksAudioCtx;
                                    if (ctx.state === 'suspended') ctx.resume();
                                    const source = ctx.createBufferSource();
                                    source.buffer = window.sticksAudioBuffer;
                                    source.connect(ctx.destination);
                                    source.start(0);
                                    window.sticksCurrentSource = source;
                                }
                            } catch (e) {}
                         }
                         // Sync to 3s audio clip (approx 0.006 per frame at 60fps)
                         this.countdownProgress = Math.min(1, this.countdownProgress + 0.006);
                    } else {
                        if (this._hovering) {
                            this._hovering = false;
                            try {
                                if (window.sticksCurrentSource) {
                                    window.sticksCurrentSource.stop();
                                    window.sticksCurrentSource = null;
                                }
                            } catch (e) {}
                        }
                        this.countdownProgress = Math.max(0, this.countdownProgress - 0.03);
                    }

                    // Draw Red Dot Target
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#ff0055';
                    this.ctx.fillStyle = `rgba(255, 0, 85, ${0.5 + this.countdownProgress * 0.5})`;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, 15 + (this.countdownProgress * 5), 0, Math.PI * 2);
                    this.ctx.fill();

                    // Draw Progress Ring
                    const r = 45;
                    this.ctx.strokeStyle = '#ff0055';
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 10;
                    this.ctx.beginPath();
                    // Background ring
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                    // Foreground ring
                    this.ctx.globalAlpha = 1;
                    this.ctx.beginPath();
                    const startAngle = -Math.PI / 2;
                    const endAngle = startAngle + (Math.PI * 2 * this.countdownProgress);
                    this.ctx.arc(centerX, centerY, r, startAngle, endAngle);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;

                    // Text
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '24px Orbitron';
                    this.ctx.textAlign = 'center';
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowColor = 'black';
                    this.ctx.fillText("HOVER TO START", centerX, centerY - 60);

                    // Sync start directly to the hover fill (approx 4.5s fill)
                    if (this.countdownProgress >= 1) {
                        this.start();
                    }
                }

                if (!this.countdownActive && this.isMutantBoss && this.boss && this.audio && this.audio.audioBuffer) {
                    const bossTime = this.audio.getCurrentTime() || 0;
                    this.updateMutantBoss(bossTime, dt);
                    
                    // Check puddle collision
                    if (this.boss.checkPuddleCollision && this.boss.checkPuddleCollision(this.player)) {
                        this.player.hit(this.player.maxHealth); // Instant death from puddle
                    }

                    // Only draw boss if not in cutscene
                    if (!this._victoryAnimPlaying) {
                        this.boss.draw(this.ctx);
                    }
                }

                // If currently counting down, we don't update/draw enemies
                if (this.countdownActive) {
                    this.ctx.restore();
                    requestAnimationFrame(() => this.loop());
                    return;
                }

                this.lines = this.lines.filter(l => l.active);
                this.lines.forEach(l => {
                    l.update();
                    l.draw(this.ctx);
                    // Reduce line damage to 1/4 of max health
                    if (l.checkCollision(this.player)) this.player.hit(this.player.maxHealth / 4);
                });

                this.bombs = this.bombs.filter(b => b.active);
                this.bombs.forEach(b => {
                    b.update();
                    b.draw(this.ctx);
                });

                this.sweepers = this.sweepers.filter(s => s.active);
                this.sweepers.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                    // Reduce sweeper damage to 1/6 of max health
                    if (s.checkCollision(this.player)) this.player.hit(this.player.maxHealth / 6);
                });

                this.shards = this.shards.filter(s => s.active);
                this.shards.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                    
                    const dist = Math.hypot(s.x - this.player.x, s.y - this.player.y);
                    const graceRadius = this.comboGraceRadius || 0;
                    const hitRadius = this.player.r + graceRadius;
                    
                    // Near-miss graze scoring
                    const grazeRange = hitRadius + 20;
                    if (dist < grazeRange && dist > hitRadius) {
                        const now = performance.now();
                        if (now - this.player.lastGrazeTime > 100) {
                            this.player.lastGrazeTime = now;
                            this.grazeScore += 10;
                            this.grazeCount += 1;
                            this.score += 10;
                            // Update graze HUD
                            const grazeDisplay = document.getElementById('graze-display');
                            if (grazeDisplay) {
                                grazeDisplay.innerText = this.grazeCount;
                            }
                            // Show graze indicator
                            if (!IS_MOBILE && this.particleSystem) {
                                this.particleSystem.addParticle(
                                    this.player.x,
                                    this.player.y,
                                    'rgb(255, 255, 0)',
                                    2,
                                    0.3
                                );
                            }
                        }
                    }
                    
                    // Actual collision
                    if (dist < hitRadius) {
                        this.player.hit(this.player.maxHealth / 6);
                        s.active = false;
                        this.incrementCombo();
                        this.addFloatingText(s.x, s.y, "+10", "#ffff00");
                        // Desktop-only: spawn particles on shard destruction
                        if (!IS_MOBILE && this.particleSystem) {
                            for (let i = 0; i < 5; i++) {
                                this.particleSystem.addParticle(
                                    s.x,
                                    s.y,
                                    'rgb(204, 0, 255)',
                                    3,
                                    0.6
                                );
                            }
                        }
                    }
                });

                this.rockets = this.rockets.filter(r => r.active);
                this.rockets.forEach(r => {
                    r.update();
                    r.draw(this.ctx);
                    
                    const dist = Math.hypot(r.x - this.player.x, r.y - this.player.y);
                    const graceRadius = this.comboGraceRadius || 0;
                    const hitRadius = this.player.r + r.r + graceRadius;
                    
                    // Quick destruction bonus
                    const spawnBonus = (r.totalFrames < 30) ? 50 : 0;
                    
                    if (dist < hitRadius) {
                        this.player.hit(this.player.maxHealth / 6);
                        r.active = false;
                        this.incrementCombo();
                        this.score += spawnBonus;
                        // Desktop-only: spawn particles on rocket destruction
                        if (!IS_MOBILE && this.particleSystem) {
                            for (let i = 0; i < 6; i++) {
                                this.particleSystem.addParticle(
                                    r.x,
                                    r.y,
                                    'rgb(255, 136, 0)',
                                    4,
                                    0.7
                                );
                            }
                        }
                    }
                });

                this.spirals = this.spirals.filter(s => s.active);
                this.spirals.forEach(s => {
                    s.update();
                    s.draw(this.ctx);
                    
                    // Quick destruction bonus
                    const spawnBonus = (s.life < 60) ? 30 : 0;
                    
                    const graceRadius = this.comboGraceRadius || 0;
                    if (s.checkCollision(this.player)) {
                        this.player.hit(this.player.maxHealth / 6);
                        s.active = false;
                        this.incrementCombo();
                        this.score += spawnBonus;
                        // Desktop-only: spawn particles on spiral destruction
                        if (!IS_MOBILE && this.particleSystem) {
                            for (let i = 0; i < 5; i++) {
                                this.particleSystem.addParticle(
                                    s.x + Math.cos(s.angle) * s.spiralRadius,
                                    s.y + Math.sin(s.angle) * s.spiralRadius,
                                    'rgb(255, 221, 0)',
                                    3,
                                    0.6
                                );
                            }
                        }
                    }
                });

                this.particleSystem.update();
                this.particleSystem.render(this.ctx);

                // Update and draw floating texts
                this.floatingTexts = this.floatingTexts.filter(t => t.life > 0);
                this.floatingTexts.forEach(t => {
                    t.update();
                    t.draw(this.ctx);
                });

                // Draw hit flash overlay
                if (this.hitFlashOpacity > 0) {
                    this.ctx.fillStyle = `rgba(255, 0, 85, ${this.hitFlashOpacity})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.hitFlashOpacity -= 0.02;
                }

                // Draw level-up notification
                if (this.levelUpNotification) {
                    const notif = this.levelUpNotification;
                    this.ctx.save();
                    this.ctx.globalAlpha = notif.opacity;
                    this.ctx.fillStyle = '#00ff41';
                    this.ctx.font = 'bold 48px Orbitron';
                    this.ctx.textAlign = 'center';
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#00ff41';
                    this.ctx.fillText(notif.text, this.width / 2, notif.y);
                    this.ctx.restore();
                    
                    // Animate notification (fade out and move up)
                    notif.opacity -= 0.01;
                    notif.y -= 1;
                    
                    if (notif.opacity <= 0) {
                        this.levelUpNotification = null;
                    }
                }

                this.ctx.restore();

                // Record frame for replay
                this.recordFrame();

                if (this.player.health > 0) {
                    const prevScore = this.score;
                    const comboMultiplier = Math.min(Math.floor(this.combo / 10) + 1, 5);
                    this.score += (0.1 + (this.audio.volume * 0.5)) * comboMultiplier;
                    const scoreDisplay = document.getElementById('score-display');
                    const scoreContainer = document.getElementById('score-container');
                    scoreDisplay.innerText = Math.floor(this.score);

                    // Desktop-only: pulse score when it increases significantly
                    if (!IS_MOBILE && this.score - this.lastScore > 5) {
                        scoreContainer.style.animation = 'none';
                        setTimeout(() => {
                            scoreContainer.style.animation = 'scorePulse 0.3s ease-out';
                        }, 10);
                        this.lastScore = this.score;
                    }

                    const deltaScore = this.score - prevScore;
                    this.gainExp(deltaScore);
                } else {
                    document.getElementById('score-display').innerText = Math.floor(this.score);
                }

                const elapsedSeconds = (performance.now() - this.startTime) / 1000;
                document.getElementById('time-display').innerText = elapsedSeconds.toFixed(1) + "s";

                // Song progress bar with checkpoints
                if (this.audio && this.audio.audioBuffer && this.progressBarEl) {
                    const currentTime = this.audio.getCurrentTime();
                    const dur = this.audio.audioBuffer.duration || 1;
                    const progressPct = Math.max(0, Math.min(100, (currentTime / dur) * 100));
                    this.progressBarEl.style.width = progressPct + "%";

                    const head = document.getElementById('song-progress-head');
                    if (head) {
                        head.style.left = `${progressPct}%`;
                    }
                    
                    const progressTrack = document.getElementById('song-progress-track');

                    // Create checkpoints every 90 seconds for songs longer than 90s
                    // Deadly mode skips checkpoints entirely for maximum punishment
                    if (!DEADLY_MODE && dur > 90 && this.checkpoints.length === 0) {
                        const numCheckpoints = Math.floor(dur / 90);
                        for (let i = 1; i <= numCheckpoints; i++) {
                            const time = i * 90;
                            this.checkpoints.push({
                                time: time,
                                reached: false,
                                health: this.player.maxHealth,
                                score: 0
                            });

                            // Add visual marker to the track
                            const marker = document.createElement('div');
                            marker.className = 'absolute top-0 bottom-0 w-0.5 bg-pink-500 opacity-70 rounded-full glow';
                            marker.style.left = `${(time / dur) * 100}%`;
                            marker.style.boxShadow = '0 0 8px #ec4899';
                            marker.dataset.time = time;
                            progressTrack.appendChild(marker);
                        }
                    }
                    
                    // Check if we reached a checkpoint
                    for (const checkpoint of this.checkpoints) {
                        if (!checkpoint.reached && currentTime >= checkpoint.time) {
                            checkpoint.reached = true;
                            checkpoint.health = this.player.health;
                            checkpoint.score = this.score;
                            
                            // Visual feedback
                            this.triggerShake(20);

                            // Update visual marker style
                            const progressTrack = document.getElementById('song-progress-track');
                            if (progressTrack) {
                                const marker = progressTrack.querySelector(`[data-time="${checkpoint.time}"]`);
                                if (marker) {
                                    marker.classList.remove('bg-pink-500');
                                    marker.classList.add('bg-green-500', 'pulse');
                                    marker.style.boxShadow = '0 0 8px #00ff41';
                                }
                            }
                            
                            // Show checkpoint notification
                            const checkpointNotif = document.createElement('div');
                            checkpointNotif.style.position = 'fixed';
                            checkpointNotif.style.top = '50%';
                            checkpointNotif.style.left = '50%';
                            checkpointNotif.style.transform = 'translate(-50%, -50%)';
                            checkpointNotif.style.fontSize = '3rem';
                            checkpointNotif.style.fontWeight = 'bold';
                            checkpointNotif.style.color = '#00ff41';
                            checkpointNotif.style.textShadow = '0 0 20px #00ff41, 0 0 40px #00ff41';
                            checkpointNotif.style.zIndex = '100';
                            checkpointNotif.style.pointerEvents = 'none';
                            checkpointNotif.innerText = `CHECKPOINT ${this.checkpoints.indexOf(checkpoint) + 1}`;
                            document.body.appendChild(checkpointNotif);
                            
                            setTimeout(() => {
                                checkpointNotif.style.transition = 'opacity 1s';
                                checkpointNotif.style.opacity = '0';
                                setTimeout(() => checkpointNotif.remove(), 1000);
                            }, 2000);
                        }
                    }
                }

                requestAnimationFrame(() => this.loop());
            }

            // show a large top intro title whenever the boss appears (intro/attack/easy)
            showBossName(name) {
                // remove existing if present
                const old = document.getElementById('boss-title');
                if (old) old.remove();

                const el = document.createElement('div');
                el.id = 'boss-title';
                el.style.position = 'fixed';
                el.style.top = '6%';
                el.style.left = '50%';
                el.style.transform = 'translateX(-50%) translateY(-20px)';
                el.style.zIndex = '120';
                el.style.pointerEvents = 'none';
                el.style.textAlign = 'center';
                el.style.color = '#ffdddd';
                el.style.textShadow = '0 0 20px rgba(255,80,80,0.9), 0 0 40px rgba(255,40,40,0.6)';
                el.style.fontFamily = 'Orbitron, sans-serif';

                const small = document.createElement('div');
                small.innerText = 'BOSS';
                small.style.fontSize = '18px';
                small.style.letterSpacing = '6px';
                small.style.opacity = '0.9';
                small.style.color = '#ffb6b6';

                const big = document.createElement('div');
                big.innerText = name;
                big.style.fontSize = '48px';
                big.style.fontWeight = '900';
                big.style.marginTop = '6px';
                big.style.opacity = '0';
                big.style.transform = 'translateY(6px)';
                big.style.color = '#ff6666';

                el.appendChild(small);
                el.appendChild(big);
                document.body.appendChild(el);

                // animate in/out
                setTimeout(() => {
                    el.style.transition = 'opacity 0.12s, transform 0.35s';
                    el.style.transform = 'translateX(-50%) translateY(0)';
                    big.style.opacity = '1';
                    big.style.transform = 'translateY(0)';
                }, 20);

                // auto remove after 2.1s
                setTimeout(() => {
                    el.style.transition = 'opacity 0.5s, transform 0.5s';
                    el.style.opacity = '0';
                    el.style.transform = 'translateX(-50%) translateY(-24px)';
                    setTimeout(() => {
                        if (el.parentElement) el.remove();
                    }, 520);
                }, 2100);
            }

            updateMutantBoss(t, dt) {
                if (!this.boss) return;

                // Scripted timeline (seconds)
                // 13‚Äì26: default attack
                // 26‚Äì38.5: default + fan + shockwave (secondary)
                // 38.5‚Äì58: break (hidden)
                // 58‚Äì67: reappear intro only
                // 67‚Äì77: default
                // 77‚Äì90: default + rockets
                // 90‚Äì96: break (hidden)
                // 96‚Äì102.5: intro
                // 102.5‚Äì115: default
                // 115‚Äì125: default + spiral
                // 125‚Äì141: break (hidden)
                // 141‚Äì154: default
                // 154‚Äì166: default + fan
                // 166‚Äì182: break (hidden, boss slightly buffed starting next)
                // 182‚Äì204: buffed default + rockets + spiral + shockwave
                // 204‚Äì230: easiest phase (slow default only)
                // 230+: boss goes into death state (still rendered, fading), cutscene plays, song continues

                let phase = 'hidden';
                let cfg = {
                    enableRadial: false,
                    enableFan: false,
                    enableSpiral: false,
                    enableRockets: false,
                    isIntroOnly: false,
                    isEasyPhase: false,
                    enableShockwave: false
                };
                let buffLevel = 1;

                if (t >= 13 && t < 26) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                } else if (t >= 26 && t < 38.5) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                    cfg.enableFan = true;
                    cfg.enableShockwave = true; // make 2nd attack visible
                    cfg.enableSlam = true; // NEW: Slam attack
                } else if (t >= 38.5 && t < 58) {
                    phase = 'hidden';
                } else if (t >= 58 && t < 67) {
                    phase = 'intro';
                    cfg.isIntroOnly = true;
                } else if (t >= 67 && t < 77) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                } else if (t >= 77 && t < 90) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                    cfg.enableRockets = true;
                } else if (t >= 90 && t < 96) {
                    phase = 'hidden';
                } else if (t >= 96 && t < 102.5) {
                    phase = 'intro';
                    cfg.isIntroOnly = true;
                } else if (t >= 102.5 && t < 115) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                } else if (t >= 115 && t < 125) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                    cfg.enableSpiral = true;
                } else if (t >= 125 && t < 141) {
                    phase = 'hidden';
                } else if (t >= 141 && t < 154) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                } else if (t >= 154 && t < 166) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                    cfg.enableFan = true;
                } else if (t >= 166 && t < 182) {
                    phase = 'hidden';
                } else if (t >= 182 && t < 204) {
                    phase = 'attack';
                    cfg.enableRadial = true;
                    cfg.enableRockets = true;
                    cfg.enableSpiral = true;
                    cfg.enableShockwave = true;
                    cfg.enableSlam = true; // Slam active in final rage too
                    buffLevel = 1.25;
                } else if (t >= 204 && t < 230) {
                    phase = 'easy';
                    cfg.enableRadial = true;
                    cfg.isEasyPhase = true;
                    buffLevel = 0.85;
                } else if (t >= 230) {
                    // Boss enters death state and slowly fades ‚Äî mark death but DO NOT start the cutscene here.
                    // The final victory cutscene should only play when the player truly completes the level (song finished).
                    if (!this._mutantBossDeathTriggered) {
                        this._mutantBossDeathTriggered = true;
                        this.boss.setState('death');
                        // NOTE: startVictoryCutscene() intentionally not called here so the animation waits until victory
                    }
                    phase = 'death';
                }

                this._mutantBossPrevPhase = this._mutantBossPhase;
                this._mutantBossPhase = phase;

                // Show boss name when it transitions from hidden -> visible
                if (this._mutantBossPrevPhase === 'hidden' && (phase === 'intro' || phase === 'attack' || phase === 'easy')) {
                    const bossName = (this.currentCareerSong && this.currentCareerSong.title) ? this.currentCareerSong.title : 'MUTANT CORE';
                    this.showBossName(bossName.toUpperCase());
                }

                if (this._mutantBossPrevPhase !== this._mutantBossPhase) {
                    if (phase === 'hidden') {
                        this.boss.setState('hidden');
                    } else if (phase === 'intro') {
                        this.boss.setState('intro');
                    } else if (phase === 'attack') {
                        this.boss.setState('attack');
                    } else if (phase === 'easy') {
                        this.boss.setState('easy');
                    }
                }

                if (this._mutantBossDeathTriggered) {
                    this.boss.update(this, dt, t, {
                        enableRadial: false,
                        enableFan: false,
                        enableSpiral: false,
                        enableRockets: false,
                        isIntroOnly: false,
                        isEasyPhase: false,
                        enableShockwave: false
                    });
                } else if (phase !== 'hidden') {
                    this.boss.setBuffLevel(buffLevel);
                    this.boss.update(this, dt, t, cfg);
                } else {
                    // hidden phase just fades out
                    this.boss.setState('hidden');
                    this.boss.update(this, dt, t, {
                        enableRadial: false,
                        enableFan: false,
                        enableSpiral: false,
                        enableRockets: false,
                        isIntroOnly: true,
                        isEasyPhase: false,
                        enableShockwave: false
                    });
                }
            }

            async startVictoryCutscene() {
                // Don't stop the song! Keep playing through the cutscene
                this._victoryAnimPlaying = true;
                
                // Cutscene state - player shoots down the corrupted core
                const cutscene = {
                    startTime: performance.now(),
                    playerX: this.width / 2,
                    playerY: this.height * 0.8,
                    bossX: this.boss.x,
                    bossY: this.boss.y,
                    phase: 'aim', // aim, shoot, explode, fade
                    projectiles: [],
                    particles: [],
                    textAlpha: 0,
                    bossAlpha: 1
                };

                const animate = () => {
                    if (!this._victoryAnimPlaying) return;

                    const elapsed = (performance.now() - cutscene.startTime) / 1000;
                    this.audio.update();

                    this.ctx.save();
                    this.ctx.clearRect(0, 0, this.width, this.height);

                    // Background with current song audio
                    const bassGlow = (this.audio.bass || 0) * 100;
                    const midGlow = (this.audio.mid || 0) * 100;
                    const trebleGlow = (this.audio.treble || 0) * 100;
                    const gradient = this.ctx.createRadialGradient(
                        this.width / 2, this.height / 2, 0,
                        this.width / 2, this.height / 2, Math.max(this.width, this.height)
                    );
                    gradient.addColorStop(0, `rgba(${bassGlow * 2}, ${midGlow}, ${trebleGlow * 2}, 0.3)`);
                    gradient.addColorStop(0.5, `rgba(${bassGlow}, ${midGlow * 1.5}, ${trebleGlow}, 0.2)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    this.visualizer.update(this.audio.dataArray, this.audio.volume);
                    this.visualizer.render(this.ctx);

                    this.ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    // Phase transitions
                    if (elapsed < 2) {
                        cutscene.phase = 'aim';
                    } else if (elapsed >= 2 && elapsed < 4) {
                        if (cutscene.phase === 'aim') {
                            cutscene.phase = 'shoot';
                            // Fire barrage of projectiles at boss
                            for (let i = 0; i < 30; i++) {
                                const angle = Math.atan2(cutscene.bossY - cutscene.playerY, cutscene.bossX - cutscene.playerX);
                                const spread = (Math.random() - 0.5) * 0.3;
                                cutscene.projectiles.push({
                                    x: cutscene.playerX,
                                    y: cutscene.playerY,
                                    vx: Math.cos(angle + spread) * 8,
                                    vy: Math.sin(angle + spread) * 8,
                                    color: '#00ffff',
                                    size: 4
                                });
                            }
                        }
                    } else if (elapsed >= 4) {
                        if (cutscene.phase === 'shoot') {
                            cutscene.phase = 'explode';
                            // Big explosion from boss
                            for (let i = 0; i < 300; i++) {
                                const angle = (Math.PI * 2 * i) / 300;
                                cutscene.particles.push({
                                    x: cutscene.bossX,
                                    y: cutscene.bossY,
                                    vx: Math.cos(angle) * (4 + Math.random() * 6),
                                    vy: Math.sin(angle) * (4 + Math.random() * 6),
                                    color: ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#a855f7'][i % 5],
                                    life: 1,
                                    size: 3 + Math.random() * 4
                                });
                            }
                        }
                    }

                    // Draw boss (fade out during explosion)
                    // Check if boss exists to prevent null errors
                    if (this.boss) {
                        if (cutscene.phase === 'explode' || cutscene.phase === 'fade') {
                            const explodeProgress = Math.min(1, (elapsed - 4) / 3);
                            cutscene.bossAlpha = 1 - explodeProgress;
                            this.ctx.globalAlpha = cutscene.bossAlpha;
                            this.boss.draw(this.ctx);
                            this.ctx.globalAlpha = 1;
                        } else {
                            this.boss.draw(this.ctx);
                        }
                    }

                    // Draw player
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = '#00ffff';
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.arc(cutscene.playerX, cutscene.playerY, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;

                    // Draw projectiles
                    if (cutscene.phase === 'shoot') {
                        for (let i = cutscene.projectiles.length - 1; i >= 0; i--) {
                            const p = cutscene.projectiles[i];
                            p.x += p.vx;
                            p.y += p.vy;

                            const dist = Math.hypot(p.x - cutscene.bossX, p.y - cutscene.bossY);
                            if (dist < this.boss.r || p.x < 0 || p.x > this.width || p.y < 0 || p.y > this.height) {
                                cutscene.projectiles.splice(i, 1);
                                continue;
                            }

                            this.ctx.fillStyle = p.color;
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = p.color;
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        this.ctx.shadowBlur = 0;
                    }

                    // Explosion particles
                    if (cutscene.phase === 'explode' || cutscene.phase === 'fade') {
                        for (let i = cutscene.particles.length - 1; i >= 0; i--) {
                            const p = cutscene.particles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vx *= 0.97;
                            p.vy *= 0.97;
                            p.life -= 0.008;

                            if (p.life <= 0) {
                                cutscene.particles.splice(i, 1);
                                continue;
                            }

                            this.ctx.fillStyle = p.color;
                            this.ctx.globalAlpha = p.life;
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.globalAlpha = 1;
                        }

                        // Fade to text
                        if (elapsed >= 8) {
                            cutscene.phase = 'fade';
                            cutscene.textAlpha = Math.min(1, (elapsed - 8) / 2);
                        }
                    }

                    // Final text overlay
                    if (cutscene.phase === 'fade') {
                        this.ctx.save();
                        this.ctx.globalAlpha = cutscene.textAlpha;
                        this.ctx.fillStyle = '#00ff41';
                        this.ctx.font = 'bold 48px Orbitron';
                        this.ctx.textAlign = 'center';
                        this.ctx.shadowBlur = 30;
                        this.ctx.shadowColor = '#00ff41';
                        this.ctx.fillText('CORE DESTROYED', this.width / 2, this.height / 2 - 40);
                        this.ctx.font = 'bold 24px Orbitron';
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = '#ffffff';
                        this.ctx.fillText('The corruption dissolves...', this.width / 2, this.height / 2 + 20);
                        this.ctx.restore();
                    }

                    this.ctx.restore();
                    requestAnimationFrame(animate);
                };

                animate();
            }

            showGamepadNotification(gamepadId) {
                const notif = document.createElement('div');
                notif.style.position = 'fixed';
                notif.style.top = '20px';
                notif.style.right = '20px';
                notif.style.padding = '16px 24px';
                notif.style.background = 'rgba(0, 0, 0, 0.9)';
                notif.style.border = '2px solid #22d3ee';
                notif.style.borderRadius = '8px';
                notif.style.color = '#22d3ee';
                notif.style.fontFamily = 'Orbitron, sans-serif';
                notif.style.fontSize = '14px';
                notif.style.fontWeight = 'bold';
                notif.style.zIndex = '150';
                notif.style.boxShadow = '0 0 20px rgba(34, 211, 238, 0.5)';
                notif.style.textShadow = '0 0 8px #22d3ee';
                
                // Detect device type from gamepad ID
                let deviceName = 'Controller';
                const id = gamepadId.toLowerCase();
                if (id.includes('xbox') || id.includes('xinput')) {
                    deviceName = 'Xbox Controller';
                } else if (id.includes('playstation') || id.includes('dualshock') || id.includes('dualsense')) {
                    deviceName = 'PlayStation Controller';
                } else if (id.includes('switch') || id.includes('joy-con')) {
                    deviceName = 'Nintendo Switch Controller';
                } else if (id.includes('steam') || id.includes('deck')) {
                    deviceName = 'Steam Deck';
                } else if (id.includes('stadia')) {
                    deviceName = 'Stadia Controller';
                }
                
                notif.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 18px; margin-bottom: 4px;">üéÆ ${deviceName} Connected</div>
                        <div style="font-size: 11px; opacity: 0.8;">Use left stick to move</div>
                    </div>
                `;
                
                document.body.appendChild(notif);
                
                setTimeout(() => {
                    notif.style.transition = 'opacity 0.5s, transform 0.5s';
                    notif.style.opacity = '0';
                    notif.style.transform = 'translateX(20px)';
                    setTimeout(() => notif.remove(), 500);
                }, 3000);
            }

            // Show the Mutant ending modal with story + simple visual flourish
            showEndingModal() {
                const modal = document.getElementById('ending-modal');
                const title = document.getElementById('ending-title');
                const body = document.getElementById('ending-body');
                const close = document.getElementById('ending-close');
                const exit = document.getElementById('ending-exit');

                // Fill with the final lore, prefer career story if available
                let endingText = '';
                if (this.currentCareerSong && this.currentCareerSong.story) {
                    endingText = this.currentCareerSong.story + "\n\nYou collapsed the corrupted core and freed the system ‚Äî the echoes of its melody linger as a memory.";
                } else {
                    endingText = "The core has been cleansed. The corruption's rhythm fades, leaving only silence and a new beginning.";
                }

                body.innerHTML = `<p>${endingText.replace(/\n/g, '<br>')}</p>`;
                title.innerText = "THE CORE HAS BEEN PURGED";

                // Ensure modal appears on top and fully opaque; remove any accidental inline hidden states
                try {
                    modal.style.zIndex = '120';
                    modal.classList.remove('hidden');
                    // small delay to ensure display state is applied then fade in for reliability
                    setTimeout(() => {
                        modal.style.opacity = '1';
                    }, 20);
                } catch (e) {
                    modal.classList.remove('hidden');
                }

                // Close handlers
                close.onclick = () => {
                    modal.style.opacity = '0';
                    setTimeout(() => modal.classList.add('hidden'), 220);
                };
                exit.onclick = () => {
                    modal.style.opacity = '0';
                    setTimeout(() => {
                        modal.classList.add('hidden');
                        // return to menu state
                        try {
                            const ui = document.getElementById('ui-layer');
                            if (ui) ui.classList.remove('hidden');
                            const demo = document.getElementById('demo-container');
                            if (demo) demo.style.display = '';
                            if (typeof demoGame !== 'undefined') demoGame.resumeDemo();
                        } catch (e) {}
                    }, 220);
                };
            }

            spawnLogic() {
                for(let k in this.cooldowns) {
                    if(this.cooldowns[k] > 0) this.cooldowns[k]--;
                }

                // Global difficulty ramps faster so standing still is much less viable
                const difficulty = 1 + (this.score / 1200);
                const beatStrength = this.audio.beatStrength || 0;
                const onBeat = this.audio.beat === 1;

                // During the Mutant fight, suppress generic spawns by 80% when boss is visible (not hidden/death)
                let mutantSuppression = 1;
                if (this.isMutantBoss && this.boss && (this.boss.state === 'intro' || this.boss.state === 'attack' || this.boss.state === 'easy')) {
                    mutantSuppression = 5; // 5x cooldown = ~80% reduction in spawn rate
                }

                // In Mutant fight, reduce exterior spawns by 50% when boss is hidden too
                const mutantReduction = this.isMutantBoss ? 2 : 1;

                if (this.audio.bass > 0.65 && this.cooldowns.bomb <= 0) {
                    this.bombs.push(new Bomb());
                    this.cooldowns.bomb = Math.ceil((32 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                }

                if (this.audio.mid > 0.5 && this.cooldowns.line <= 0) {
                    this.lines.push(new Line());
                    this.cooldowns.line = Math.ceil((18 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                }

                if (this.audio.volume > 0.7 && this.cooldowns.sweeper <= 0) {
                    // Quickdraw (career mission 1) has no sweepers to keep the first level gentler
                    const isQuickdraw =
                        this.isCareerMode &&
                        this.currentCareerSong &&
                        this.currentCareerSong.title === 'Quickdraw';
                    
                    if (!isQuickdraw) {
                        this.sweepers.push(new Sweeper());
                        // During the Mutant fight, make sweepers far rarer so they don't overwhelm the scripted boss phases
                        const sweeperBase = Math.ceil((70 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                        this.cooldowns.sweeper = this.isMutantBoss ? Math.max(180, sweeperBase * 3) : sweeperBase;
                    } else {
                        // Still advance the cooldown a bit so logic timing stays stable even without spawning
                        this.cooldowns.sweeper = Math.ceil((70 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                    }
                }

                // Treble-driven shard spawning, with extra bursts based on intensity
                if (this.audio.treble > 0.35 && this.cooldowns.shard <= 0) {
                    const baseCount = 1 + Math.floor(this.audio.treble * 2);
                    const count = baseCount + (beatStrength > 0.15 ? 1 : 0);
                    for (let i = 0; i < count; i++) {
                        const x = Math.random() * this.width;
                        const angle = Math.atan2(this.player.y - 0, this.player.x - x) + (Math.random()-0.5);
                        const speedBoost = 2.3 + (this.audio.treble * 3.2) + beatStrength * 1.6;
                        this.shards.push(new Shard(x, -10, angle, speedBoost * getSpeedFactor()));
                    }
                    this.cooldowns.shard = Math.ceil(7 * getSpawnScale() * mutantSuppression * mutantReduction);
                }

                // Rocket attack: spawns on strong bass, scales with difficulty
                if (this.audio.bass > 0.7 && this.cooldowns.rocket <= 0) {
                    this.rockets.push(new Rocket());
                    this.cooldowns.rocket = Math.ceil((110 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                }

                // Spiral attack: mainly on beat so it feels tied to kicks
                if (onBeat && this.cooldowns.spiral <= 0) {
                    const count = 1 + Math.floor(beatStrength * 3);
                    for (let i = 0; i < count; i++) {
                        this.spirals.push(new Spiral());
                    }
                    this.cooldowns.spiral = Math.ceil((55 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                } else if (this.audio.mid > 0.6 && this.cooldowns.spiral <= 0) {
                    this.spirals.push(new Spiral());
                    this.cooldowns.spiral = Math.ceil((70 / difficulty) * getSpawnScale() * mutantSuppression * mutantReduction);
                }
            }
        }

        const demoGame = new DemoGame();
        const game = new Game();
        // Sync demo player skin
        demoGame.player.setSkin(game.profile.currentSkin);
        demoGame.init();
    </script>
</body>
</html>

